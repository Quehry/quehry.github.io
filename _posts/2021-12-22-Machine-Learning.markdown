---
layout: postwithlatex
read_time: true
show_date: true
title:  机器学习
date:   2021-12-22  
description: 《机器学习》周志华读书笔记
img: posts/20211222/1.jpg 
tags: [note]
author: Quehry
---

# 目录

<!-- TOC -->

- [目录](#目录)
- [1. 第1章 绪论](#1-第1章-绪论)
- [2. 第2章 模型评估与选择](#2-第2章-模型评估与选择)
    - [2.1. 思维导图](#21-思维导图)
    - [2.2. 经验误差与过拟合](#22-经验误差与过拟合)
    - [2.3. 评估方法](#23-评估方法)
        - [2.3.1. 留出法](#231-留出法)
        - [2.3.2. 交叉验证法](#232-交叉验证法)
        - [2.3.3. 自助法](#233-自助法)
    - [2.4. 性能度量](#24-性能度量)
        - [2.4.1. 错误率与精度](#241-错误率与精度)
        - [2.4.2. 查准率、查全率与F1](#242-查准率查全率与f1)
        - [2.4.3. ROC与AUC](#243-roc与auc)
        - [2.4.4. 代价敏感错误率与代价曲线](#244-代价敏感错误率与代价曲线)
    - [2.5. 比较检验](#25-比较检验)
        - [2.5.1. 假设检验](#251-假设检验)
        - [2.5.2. 交叉验证t检验](#252-交叉验证t检验)
        - [2.5.3. McNemar检验](#253-mcnemar检验)
        - [2.5.4. Friedman检验与Nemenyi后续检验](#254-friedman检验与nemenyi后续检验)
    - [2.6. 偏差与方差](#26-偏差与方差)
- [3. 第3章 线性模型](#3-第3章-线性模型)
    - [3.1. 思维导图](#31-思维导图)
    - [3.2. 基本形式](#32-基本形式)
    - [3.3. 线性回归](#33-线性回归)
    - [3.4. 对数几率回归](#34-对数几率回归)
    - [3.5. 线性判别分析](#35-线性判别分析)
    - [3.6. 多分类学习](#36-多分类学习)
    - [3.7. 类别不平衡问题](#37-类别不平衡问题)
- [4. 第4章 决策树](#4-第4章-决策树)
    - [4.1. 思维导图](#41-思维导图)
        - [4.1.1. 章节导图](#411-章节导图)
        - [4.1.2. 如何生成一棵决策树](#412-如何生成一棵决策树)
    - [4.2. 基本流程](#42-基本流程)
    - [4.3. 划分选择](#43-划分选择)
        - [4.3.1. 信息增益](#431-信息增益)
        - [4.3.2. 增益率](#432-增益率)
        - [4.3.3. 基尼指数](#433-基尼指数)
    - [4.4. 剪枝处理](#44-剪枝处理)
        - [4.4.1. 预剪枝](#441-预剪枝)
        - [4.4.2. 后剪枝](#442-后剪枝)
    - [4.5. 连续与缺失值](#45-连续与缺失值)
        - [4.5.1. 连续值处理](#451-连续值处理)
        - [4.5.2. 缺失值处理](#452-缺失值处理)
    - [4.6. 多变量决策树](#46-多变量决策树)
    - [4.7. 阅读材料](#47-阅读材料)
- [5. 第5章 神经网络](#5-第5章-神经网络)
    - [5.0. 思维导图](#50-思维导图)
    - [5.1. 神经元模型](#51-神经元模型)
    - [5.2. 感知机与多层网络](#52-感知机与多层网络)
    - [5.3. 误差逆传播算法](#53-误差逆传播算法)
    - [5.4. 全局最小与局部极小](#54-全局最小与局部极小)
    - [5.5. 其他常见神经网络](#55-其他常见神经网络)
        - [5.5.1. RBF网络](#551-rbf网络)
        - [5.5.2. ART网络](#552-art网络)
        - [5.5.3. SOM网络](#553-som网络)
        - [5.5.4. 级联相关网络](#554-级联相关网络)
        - [5.5.5. Elman网络](#555-elman网络)
        - [5.5.6. Boltzmann机](#556-boltzmann机)
    - [5.6. 深度学习](#56-深度学习)
- [6. 第6章 支持向量机](#6-第6章-支持向量机)
    - [6.0. 思维导图](#60-思维导图)
    - [6.1. 间隔与支持向量](#61-间隔与支持向量)
    - [6.2. 对偶问题](#62-对偶问题)
    - [6.3. 核函数](#63-核函数)
    - [6.4. 软间隔与正则化](#64-软间隔与正则化)
    - [6.5. 支持向量回归](#65-支持向量回归)
    - [6.6. 核方法](#66-核方法)

<!-- /TOC -->

# 1. 第1章 绪论

# 2. 第2章 模型评估与选择

## 2.1. 思维导图

<center><img src='../assets/img/posts/20211222/16.jpg'></center>

## 2.2. 经验误差与过拟合
**定义：**
- **错误率(error rate)**: 如果m个样本中有a个样本分类错误，则错误率E=a/m。
- **精度(accuracy)**：精度=1-错误率。
- **训练误差**：学习器在训练集上的误差称为训练误差或者经验误差。
- **泛化误差(generalization error)**：学习器在新样本上的误差称为泛化误差。
- **过拟合(overfitting)**：当学习器把训练样本学得太好了的时候，很可能把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，这就会导致泛化性能下降。
- **欠拟合(underfitting)**：对训练样本的一般性质尚未学好。

## 2.3. 评估方法
通常我们可通过实验测试来对学习器的泛化误差进行评估而做出选择，于是我们需要一个**测试集(testing set)**，然后以测试集上的测试误差作为泛化误差的近似。下面介绍一些常见的处理数据集D的方法(数据集D->训练集S+测试集T)[^1]

[^1]:注意这里的测试集其实是验证集，我们通常把实际情况中遇到的数据集称为测试集。

### 2.3.1. 留出法
- 留出发(hold-out)直接将数据集D划分为两个互斥的集合，其中一个集合作为训练集S，另一个作为测试集T。在S上训练出模型后，用T来评估其测试误差。
- 以采样的角度来看待数据集划分的过程，则保留类别比例的采样方式通常称为**分层采样**。比如1000个样本，50%的正例，50%负例，以7：3划分数据集，那么训练集包含350个正例和350个负例就是分层采样。
- 在使用留出法评估结果时，一般要采用若干次随即划分、重复进行实验评估后取平均值作为留出法的评估结果。
- 常用做法时将大约2/3~4/5的样本用于训练。

### 2.3.2. 交叉验证法
- **交叉验证法(cross validation)**先将数据集D划分为k个大小相似的互斥子集，每个子集D<sub>i</sub>都尽可能保持数据分布的一致性。然后每次用k-1个自己的并集作为训练集，余下的那个子集作为测试集，这样就可以获得k组训练/测试集，从而可进行k次训练和测试，最终返回的是这k个测试结果的均值。
- 交叉验证也称为k折交叉验证。k的常见取值有10、5、20。
- **留一法**就是k=m，其中数据集D有m个样本。

### 2.3.3. 自助法
- **自助法(bootstrapping)**：给定包含m个样本的数据集D，每次随机从D中挑选一个样本，将其拷贝放入D', 然后再将该样本放回最初的数据集D中，这个过程重复执行m次后，我们获得了包含m个样本的数据集D'。我们将D'作为训练集，D\D'作为测试集。
- 不难发现大概有36.8%(m趋于无限大时)的样本在m次采样中始终不被采到。

<center>$\lim\limits_{m\rightarrow\infty}(1-\frac{1}{m})^m = \frac{1}{e} ≈ 0.368$</center>

- 缺点：自助法产生的数据集改变了初始数据集的分布，这样会引入估计偏差。因此，在初始数据量足够时，留出法和交叉验证法更常用一些。

## 2.4. 性能度量
- 对学习器的泛化性能进行评估，不仅需要有效可行的实验估计方法，还需要有衡量模型泛化能力的评价标准，这就是**性能度量(performance measure)**。
- 在预测任务中，给定D = {(x<sub>1</sub>,y<sub>1</sub>), (x<sub>2</sub>,y<sub>2</sub>)...(x<sub>m</sub>,y<sub>m</sub>)}, 其中y<sub>i</sub>是x<sub>i</sub>的真实标记。学习器f。
- **均方误差(mean squared error)**：回归任务最常用的性能度量是均方误差：

<center>$E(f;D)=\frac{1}{m}\sum_1^m(f(x_i)-y_i)^2$</center>

接下来我将介绍**分类任务**中常用的性能度量

### 2.4.1. 错误率与精度
本章开头提到了错误率和精度，这是分类任务中最常用的两种性能度量，既适用于二分类任务，也适用于多分类任务。

### 2.4.2. 查准率、查全率与F1

- 针对二分类问题，可将样例根据其真实类别与学习器预测类别的组合划分为真正例(true positive)、假正例(false positive)、真反例(true negative)、假反例(false negative)，分别记为TP、FP、TN、FN。
- 混淆矩阵(confusion matrix)


|真\预|正例|反例|
|正例|TP|FN|
|反例|FP|TN|

- 查准率(precision)，记为P，它表示选择的好瓜中有多少是真正的好瓜

<center>$P=\frac{TP}{TP+FP}$</center>

- 查全率(recall)，记为R，它表示好瓜中有多少被选出来了

<center>$R=\frac{TP}{TP+FN}$</center>

- 一般来说，查准率高时，查全率往往偏低；而查全率高时，查准率往往偏低。

- P-R曲线：在很多情形下，我们可根据学习器的预测结果对样例进行排序，排在前面的是学习器认为最可能是正例的样本，排在最后的则是学习器认为最不可能是正例的样本，按此顺序逐个把样本作为正例进行预测，则每次可以计算出当前的查全率、查准率，也得到了P-R图。

<center><img src='../assets/img/posts/20211222/2.jpg'></center>

- 如果一个学习器的P-R曲线被另一个学习器的曲线完全包住，则可断言后者的性能优于前者。如果两者曲线相交，则可以通过比较平衡点(break-even-point)来比较，越大越好。

- F1度量：F1综合考虑了查准率和查全率，是他们的调和平均

<center>$F1=\frac{2*P*R}{P+R}$</center>

- F1的一般形式：有时候我们希望赋予查准率和查重率不同的权重：

<center>$F_\beta=\frac{(1+\beta^2)*P*R}{\beta^2*P+R}$</center>

其中β大于1表示查全率有更大影响

- 有时候我们有多个二分类混淆矩阵，我们希望在这n个混淆矩阵上综合考虑查准率和查全率，那么我们有以下的度量

- 宏查准率macro-P，宏查全率macro-R，宏F1：

<center>$macro-P=\frac{1}{n}\sum_1^nP_i$</center>

<center>$macro-R=\frac{1}{n}\sum_1^nR_i$</center>

- 微查准率micro-P，微查全率micro-P，微F1：

对TP、FP、TN、FN进行平均

<center>$micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FP}}$</center>

<center>$micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FN}}$</center>

### 2.4.3. ROC与AUC
- 很多学习器是为测试样本产生一个实值或概率预测，然后将这个预测值与一个分类阈值进行比较，若大于阈值则分为正类，否则为反类。

- ROC曲线是从排序角度来出发研究学习器的泛化性能的工具。ROC的全称是Receiver Operating Characteristic。

- 与P-R曲线类似，我们根据学习器的预测结果进行排序，按此顺序逐个把样本作为正例进行预测，计算出真正例率TPR(true positive rate)与假正例率FPR(false positive rate)并以它们分别为横纵坐标画出ROC曲线

<center>$TPR=\frac{TP}{TP+FN}$</center>

<center>$FPR=\frac{FP}{FP+TN}$</center>

<center><img src='../assets/img/posts/20211222/3.jpg'></center>

- 同样的，如果一个学习器的ROC曲线被另一个学习器完全包住，则认为后者的性能优于前者。若两个曲线相交，则比较曲线下的面积AUC(area under curve)

- 形式化的看，AUC考虑的是样本预测的排序质量，那么我们可以定义一个排序损失l<sub>rank</sub>

<center><img src='../assets/img/posts/20211222/4.jpg'></center>

<center>AUC=1-l<sub>rank</sub></center>


### 2.4.4. 代价敏感错误率与代价曲线
- 有时候将正例误判断为负例与将负例误判断为正例所带来的后果不一样，我们赋予它们非均等代价
- 代价矩阵(cost matrix)


|真\预|第0类|第1类|
|第0类|0|cost<sub>01</sub>|
|第1类|cost<sub>10</sub>|0|

其中cost<sub>ij</sub>表示将第i类样本预测为第j类样本的代价

- 代价敏感错误率

<center><img src='../assets/img/posts/20211222/5.jpg'></center>

- 在非均等代价下，ROC曲线不能直接反映出学习器的期望总代价，而代价曲线则可达到此目的，横轴是正例概率代价，纵轴是归一化代价

<center><img src='../assets/img/posts/20211222/6.jpg'></center>

&nbsp;

<center><img src='../assets/img/posts/20211222/7.jpg'></center>

&nbsp;

<center><img src='../assets/img/posts/20211222/8.jpg'></center>

## 2.5. 比较检验
我们有了实验评估方法与性能度量，是否就可以对学习器的性能进行评估比较了呢？实际上，机器学习中性能比较这件事比大家想象的要复杂很多，我们需要考虑多种因素的影响，下面介绍一些对学习器性能进行比较的方法，本小节默认以错误率作为性能度量。(但我觉得似乎同一个数据集下就可以比较)

### 2.5.1. 假设检验
- 假设检验中的假设是对学习器泛化错误率分布的某种猜想或者判断，例如“ε=ε<sub>0</sub>”这样的假设
- 现实任务中我们并不知道学习器的泛化错误率，我们只能获知其测试错误率$\hat{\epsilon}$，但直观上，两者接近的可能性比较大，因此可根据测试错误率估推出泛化错误率的分布。
- 泛化错误率为$\epsilon$的学习器被测得测试错误率为$\hat{\epsilon}$的概率：

<center><img src='../assets/img/posts/20211222/9.jpg'></center>

- 我们发现$\epsilon$符合二项分布

<center><img src='../assets/img/posts/20211222/10.jpg'></center>

- 二项检验：我们可以使用**二项检验(binomial test)**来对“$\epsilon$<0.3”这样的假设进行检验，即在$\alpha$显著度下，$1-\alpha$置信度下判断假设是否成立。

- t检验：我们也可以用t检验(t-test)来检验。

- 上面介绍的都是针对单个学习器泛化性能的假设进行检验

### 2.5.2. 交叉验证t检验

- 对于两个学习器A和B，若我们使用k折交叉验证法得到的测试错误率分别是$\epsilon_1^A$, $\epsilon_2^A$...$\epsilon_k^A$和$\epsilon_1^B$, $\epsilon_2^B$...$\epsilon_k^B$。其中$\epsilon_i^A$和$\epsilon_i^B$是在相同第i折训练集上得到的结果。则可以用k折交叉验证“成对t检验”来进行比较检验。

- 我们这里的基本思想是若两个学习器的性能相同，则它们使用相同的训练测试集得到的错误率应该相同，即$\epsilon_i^A=\epsilon_1^B$

- $\Delta_i$ = $\epsilon_i^A$ - $\epsilon_i^B$，然后对$\Delta$进行分析

### 2.5.3. McNemar检验
- 对于二分类问题，使用留出法不仅可以估计出学习器A和B的测试错误率，还可获得两学习器分类结果的差别，即两者都正确、都错误...的样本数

<center><img src='../assets/img/posts/20211222/11.jpg'></center>

- 若我们假设两学习器性能相同，则应有e<sub>01</sub>=e<sub>10</sub>，那么变量\|e<sub>01</sub>-e<sub>10</sub>\|应该服从正态分布/卡方分布，然后用McNemar检验

### 2.5.4. Friedman检验与Nemenyi后续检验

- 交叉验证t检验与McNemar检验都是在一个数据集上比较两个算法的性能，但是很多时候，我们会在一组数据集上比较多个算法。

- 当有多个算法参与比较时，一种做法是在每个数据集上本别列出两两比较的结果。另一种方法则是基于算法排列的**Friedman检验**

- 假定我们用D<sub>1</sub>, D<sub>2</sub>, D<sub>3</sub>, D<sub>4</sub>四个数据集对算法A、B、C进行比较。首先，使用留出法或交叉验证法得到每个算法在每个数据集上的测试结果。然后在每个数据集上根据测试性能由好到坏排序，并赋予序值1,2,...若算法的测试性能相同，则平分序值。

<center><img src='../assets/img/posts/20211222/12.jpg'></center>

- 然后使用Fredman检验来判断这些算法是否性能都相同，若相同，那么它们的平均序值应当相同。r<sub>i</sub>表示第i个算法的平均序值，那么它的均值和方差应该满足...

- 若“所有算法的性能相同”这个假设被拒绝，则说明算法的性能显著不同，这时需要后续检验(post-hoc test)来进一步区分各算法，常用的有Nemenyi后续检验

- Nemenyi检验计算出平均序值差别的临界值域

<center><img src='../assets/img/posts/20211222/13.jpg'></center>

- 在表中找到k=3时q<sub>0.05</sub>=2.344，根据公式计算出临界值域CD=1.657，由表中的平均序值可知A与B算法的差距，以及算法B与C的差距均未超过临界值域，而算法A与C的差距超过临界值域，因此检验结果认为算法A与C的性能显著不同，而算法A与B以及算法B与C的性能没有显著差别。

<center><img src='../assets/img/posts/20211222/14.jpg'></center>

## 2.6. 偏差与方差

- 对学习算法除了通过实验估计其泛化性能，人们往往还希望了解它“为什么”具有这样的性能。偏差-方差分解是解释学习算法泛化性能的一种重要工具

- **偏差**度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力
- **方差**度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响
- **噪声**则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度

- 一般来说，偏差与方差是有冲突的，也就是偏差大的方差小，偏差小的方差大

<center><img src='../assets/img/posts/20211222/15.jpg'></center>

# 3. 第3章 线性模型
## 3.1. 思维导图

<center><img src='../assets/img/posts/20211222/42.jpg'></center>

## 3.2. 基本形式

- 给定由d个属性描述的示例$x=(x_1;x_2;...x_d)$，这是一个列向量，其中$x_i$是$x$在第i个属性上的取值。

- **线性模型(linear model)**试图学得一个通过属性线性组合来进行预测的函数：

<center><img src='../assets/img/posts/20211222/17.jpg'></center>

- 向量形式：

<center>$f(x)=\omega^Tx+b$</center>

其中$\omega=(\omega_1;\omega_2...\omega_d)$

- 当$\omega$和b学得后，模型就得以确定

- 线性模型的优点：形式简单，易于建模，良好的可解释性(comprehensibility)

## 3.3. 线性回归
- 对离散属性的处理，若属性值存在“序”的关系，可通过连续化将其转化为连续值，比如高、矮变成1、0；2.若不存在序的关系，可转化为k维向量。

- 均方误差是回归任务中最常用的性能度量，试图让均方误差最小化：

<center><img src='../assets/img/posts/20211222/18.jpg'></center>

- 均方误差有非常好的几何意义，它对应了欧氏距离。基于均方误差最小化来进行模型求解的方法称为**最小二乘法(least square method)**。在线性回归中，最小二乘法就是试图找到一条直线，使得样本到直线上的欧氏距离之和最小

- 首先观察一个属性值的情况。求解$\omega$和$b$使得均方误差最小化的过程，称为线性回归的最小二乘“参数估计”，我们令均方误差分别对$\omega$和$b$求导令其为零，可以得到最优解的**闭式解(closed-form)**,即解析解

<center><img src='../assets/img/posts/20211222/19.jpg'></center>

&nbsp;

<center><img src='../assets/img/posts/20211222/20.jpg'></center>

- 更一般的情况是d个属性，称其为“多元线性回归”，同样的步骤，只是$\omega$变成向量形式，自变量写成m*(d+1)的矩阵形式，m对应了m个样本，d+1对应了d个属性和偏置。同样的求导为0然后得出$\hat{\omega}$最优解的闭式解，其中$\hat{\omega}=(\omega;b)$。当$X^TX$为满秩矩阵[^2]或正定矩阵时，有唯一的解：

<center><img src='../assets/img/posts/20211222/21.jpg'></center>

&nbsp;

<center><img src='../assets/img/posts/20211222/22.jpg'></center>

&nbsp;

<center><img src='../assets/img/posts/20211222/23.jpg'></center>

&nbsp;

<center><img src='../assets/img/posts/20211222/24.jpg'></center>

&nbsp;

<center><img src='../assets/img/posts/20211222/25.jpg'></center>


[^2]:满秩矩阵指方阵的秩等于矩阵的行数/列数，满秩矩阵有逆矩阵且对于y=Xb有唯一的解


- 然而现实任务中往往不是满秩矩阵，例如在许多任务中我们会遇到大量的变量其数目甚至超过样例数。那么我们会求出$\hat{\omega}=(\omega;b)$的多个解，它们都能使均方误差最小化。选择哪一个解作为输出与学习算法的归纳偏好决定，常见的做法是**引入正则化(regularization)**

- **广义线性模型(generalized linear model)**:

<center><img src='../assets/img/posts/20211222/26.jpg'></center>

<center>$g(y)=\omega^Tx+b$</center>

其中g()单调可微，被称为联系函数。比如当g()=ln()时称为对数线性回归

## 3.4. 对数几率回归
- 上一节讨论的是线性回归进行回归学习。那么如果我们要做的是分类任务应该怎么改变？我们只需要找到一个单调可微函数将分类任务的真实标记y与线性回归模型的预测值联系起来。

- 考虑二分类问题，那么我们可以用单位阶跃函数/Heaviside函数联系y与z，其中y是真是标记，z是预测值，$z=\omega^Tx+b$

<center><img src='../assets/img/posts/20211222/27.jpg'></center>

- 但是它有个问题就是不连续，所以我们希望找到能在一定程度上近似它的替代函数。

- **对数几率函数(logistic function)**就是一个替代函数：

<center>$y=\frac{1}{1+e^{-z}}$</center>

<center><img src='../assets/img/posts/20211222/28.jpg'></center>

- 那么这个式子可以转化为：可以把y视为样本x作为正例的可能性，则1-y是其反例的可能性，两者的比值称为几率(odds)：

<center><img src='../assets/img/posts/20211222/29.jpg'></center>

- 若将y视为类后验概率估计。则式子可以重写为：

<center><img src='../assets/img/posts/20211222/30.jpg'></center>

- 接下来我们可以通过**极大似然法(maximum likelihood method)**来估计$\omega$和$b$。给定数据集，对数似然函数[^3]为：

<center><img src='../assets/img/posts/20211222/31.jpg'></center>

即每个样本属于其真实标记的概率越大越好。

[^3]: 统计学中，似然函数是一种关于统计模型参数的函数。给定输出x时，关于参数θ的似然函数L(θ\|x)（在数值上）等于给定参数θ后变量X的概率：L(θ\|x)=P(X=x\|θ)。

- 推导过程：

<center><img src='../assets/img/posts/20211222/32.jpg'></center>

上面有个式子应该有问题，(3.26)应该是

<center>$p(y_i|x_i;\omega,b) = p_1(\hat{x_i};\beta)^{y_i}p_0(\hat{x_i};\beta)^{1-y_i}$</center>

因为$\beta$是高阶可导连续凸函数，根据凸优化理论，经典的数值优化算法如**梯度下降法(gradient descent method)**和牛顿法都可以求得最优解

## 3.5. 线性判别分析

- 线性判别分析(Linear Discriminant Analysis，简称LDA)是一种经典的线性学习方法。

- LDA的思想非常朴素: 给定训练样例集，设法将样例投影到一条直线上，使得同类样例的投影点尽可能接近、异类样例的投影点尽可能远离;在对新样本进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定样本的类别。

<center><img src='../assets/img/posts/20211222/33.jpg'></center>

- 令$X_i$、$\mu_i$、$\Sigma_i$分别表示第i类示例的集合、均值向量[^4]、协方差矩阵[^5]。

[^4]: 随机变量的期望组成的向量称为期望向量或者均值向量

[^5]: 协方差矩阵的每个元素是各个向量元素之间的协方差。协方差就是Covariance

- 欲使同类样例的投影点尽可能接近，可以让同类样例投影点的协方差尽可能小，即$\omega^T\Sigma_0\omega+\omega^T\Sigma_1\omega$尽可能小;而欲使异类样例的投影点尽可能远离，可以让类中心之间的距离尽可能大，即$\|\|\omega^T\mu_0-\omega^T\mu_1\|\|$尽可能大:

<center><img src='../assets/img/posts/20211222/34.jpg'></center>

- 剩余推导过程：

<center><img src='../assets/img/posts/20211222/35.jpg'></center>

&nbsp;

<center><img src='../assets/img/posts/20211222/36.jpg'></center>

- 值得一提的是，LDA可从贝时斯决策理论的角度来阐释，并可证明，当两类数据同先验、满足高斯分布且协方差相等时，LDA可达到最优分类。

## 3.6. 多分类学习
- 现实中常遇到多分类学习任务，有些二分类学习方法可直接推广到多分类，但在更多情形下，我们是基于一些基本策略，利用二分类学习器来解决多分类问题。

- 不失一般性，考虑N个类别$C_1$、$C_2$...$C_N$，多分类学习的基本思路是"**拆解法**”，即将多分类任务拆为若干个二分类任务求解。具体来说，先对问题进行拆分，然后为拆出的每个二分类任务训练一个分类器;在测试时，对这些分类器的预测结果进行集成以获得最终的多分类结果。

- 这里我们着重介绍如何拆分，最经典的拆分策略有三种：一对一(One vs One)、一对其余(One vs Rest)、多对多(Many vs Many)

- 一对一：将这N个类别两两配对，从而产生 N(N-1)/2个二分类任务。在测试阶段，新样本将同时提交给所有分类器，于是我们将得到N(N-1)/2个分类结果，最终结果可通过投票产生:即把被预测得最
多的类别作为最终分类结果。

<center><img src='../assets/img/posts/20211222/37.jpg'></center>

- 一对其余：OvR则是每次将一个类的样例作为正例，所有其他类的样例作为反例来训练N个分类器。在测试时若仅有一个分类器预测为正类，则对应的类别标记作为最终分类结果。若有多个分类器预测为正类，则通常考虑各分类器的预测置信度，选择置信度最大的类别标记作为分类结果。

<center><img src='../assets/img/posts/20211222/38.jpg'></center>

- 多对多MvM是每次将若干个类作为正类，若干个其他类作为反类。这里我们介绍一种最常用的MvM技术：**纠错输出码(ECOC)**

- ECOC是将编码的思想引入类别拆分，主要分为两步：

&emsp;&emsp;1.编码： 对N个类别做M次划分，每次划分将一部分类别划为正类，一部分划为反类，从而形成一个二分类训练集;这样一共产生M个训练集，可训练出M个分类器

&emsp;&emsp;2.解码：:M个分类器分别对测试样本进行预测，这些预测标记组成一个编码.将这个预测编码与每个类别各自的编码进行比较，返回其中距离最小的类别作为最终预测结果。

- 类别划分通过**编码矩阵**指定。编码矩阵有多种形式，常见的有二元码和三元码，前者将每个类别分别指定为正类和反类，后者在正、反类之外，还可指定“停用类”

<center><img src='../assets/img/posts/20211222/39.jpg'></center>

## 3.7. 类别不平衡问题

- 前面介绍的分类学习方法都有一个共同的基本假设：即不同类别的训练样例数目相当。如果不同类别的样例数差别很大，会对学习过程造成困扰。

- **类别不平衡(class-imbalance)**就是指分类任务中不同类别的训练样例数目差别很大的情况。

- **再缩放(rescaling)**是类别不平衡中的一个基本策略：比如在最简单的二分类问题中，我们假设y大于0.5为正例，y小于0.5为负例，但是在类别不平衡时，我们可以改变阈值来达到再平衡：

&emsp;&emsp;将

<center><img src='../assets/img/posts/20211222/40.jpg'></center>

&emsp;&emsp;变成

<center><img src='../assets/img/posts/20211222/41.jpg'></center>

- 现有的解决类别不平衡的技术大体上有三类做法(这里我们均假设正例样本少):

&emsp;&emsp;1.第一类是直接对训练集里的反类样例进行"欠采样" (undersampling)，即去除一些反例使得正、反例数日接近，然后再进行学习;

&emsp;&emsp;2.第二类是对训练集里的正类样例进行"过采样" (oversampling)，即增加一些正例使得正、反例数目接近，然后再进行学习;

&emsp;&emsp;3.第三类则是直接基于原始训练集进行学习，但在用训练好的分类器进行预测时，将上面的公式(改变阈值)嵌入到其决策过程中，称为"阔值移动" (threshold-moving)

- 需注意的是，过采样法不能简单地对初始正例样本进行重复来样，否则会招致严重的过拟合；过采样法的代表性算法SMOTE是通过对训练集里的正例进行插值来产生额外的正例.另一方面，欠采样法若随机丢弃反例可能丢失一些重要信息;欠采样法的代表性算法EasyEnsemble则是利用集成学习机制，将反例划分为若干个集合供不同学习器使用，这样对每个学习器来看都进行了欠采样，但在全局来看却不会丢失重要信息。

# 4. 第4章 决策树
## 4.1. 思维导图
### 4.1.1. 章节导图

<center><img src='../assets/img/posts/20211222/61.jpg'></center>

### 4.1.2. 如何生成一棵决策树

<center><img src='../assets/img/posts/20211222/62.jpg'></center>

## 4.2. 基本流程
- 决策树是基于树结构来进行决策，其中包含一个根结点，多个内部结点和多个叶结点
- 叶结点对应决策结果，其他每个结点都对应一个属性测试
- 每个结点包含的样本集合根据属性测试被划分到子结点中，那么根结点包含样本全集
- 决策树学习的目的是为了产生一棵泛化能力强的决策树
- 决策树的生成是一个递归过程，下面这张图展示了递归的过程：

<center><img src='../assets/img/posts/20211222/43.jpg'></center>

对于每个结点，首先判断该结点的样本集是否属于同一个类别C，如果是，则将该结点标记为C类叶结点。再判断该结点的样本集的属性值是否完全相同(或者是否为空集)，如果是，则将该结点标记为D类叶结点，其中D类是这些样本中最多的类别。如果该结点即不是**同属于一个类别**也不是**属性值取值相同**，那么则需要继续划分，选择一个最优的划分属性$a_*$,创建新的分支，对于每个分支结点首先判断是否为空，如果为空则判定为E类叶结点，其中E类是父结点中类别最多的类。如果子结点不为空则递归。

## 4.3. 划分选择
可以发现生成决策树最关键的步骤就是选择最优划分属性，我们希望决策树的分支结点所包含的样本尽可能属于同一类别，即结点的**纯度**越来越高。我们有很多指标来确定选择哪一个属性作为最优划分选择，下面将分别介绍：

### 4.3.1. 信息增益
- **信息熵(information entropy)**是度量样本集合纯度最常用的一种指标。下面是信息熵的定义公式：

<center><img src='../assets/img/posts/20211222/44.jpg'></center>

&emsp;&emsp;其中$p_k$表示第k类样本在样本集D中所占比例，信息熵越小表示D的纯度越高。

- 假设离散属性a有V个可能的取值${a^1,a^2...a^V}$,那么我们可以计算出在使用a作为划分属性前后的信息熵差别，也就是**信息增益(information gain)**：

<center><img src='../assets/img/posts/20211222/45.jpg'></center>

&emsp;&emsp;对每一个子结点$D^v$都赋予权重同时相加。

- 著名的ID3决策树学习算法就是以信息增益作为准则来选择划分属性，我们希望找到信息增益最大的属性。

- 书上使用信息增益划分的例子：

<center><img src='../assets/img/posts/20211222/46.jpg'></center>

### 4.3.2. 增益率
- 信息增益对可取值数目较多的属性有所偏好，比如我们使用编号这一属性来划分，每一个编号都只有一个样本，那么信息增益肯定增大了，但是决策树的泛化能力显然下降了。

- **增益率(gain ratio)**，我们通过对信息增益除以IV来平衡属性数目带来的影响，增益率的定义如下：

<center><img src='../assets/img/posts/20211222/47.jpg'></center>

&emsp;&emsp;IV(intrinsic value)的定义如下：

<center><img src='../assets/img/posts/20211222/48.jpg'></center>

&emsp;&emsp;IV是属性a的固有值，属性a可取的数值数目越多，那么IV就越大

- 但是增益率也有问题，那就是对于可取值数目较少的属性有偏好，所以著名的C4.5决策树算法并不是直接使用增益率，而是先从候选划分属性中找出信息增益高于平均水平的属性，然后再从中选择增益率最高的属性

### 4.3.3. 基尼指数
- CART决策树使用基尼指数来选择划分属性
- 数据集D的纯度定义如下

<center><img src='../assets/img/posts/20211222/49.jpg'></center>

&emsp;&emsp;直观来说，Gini反映了从数据集随便抽取两个样本，它们类别不一致概率

- **基尼指数**定义如下：

<center><img src='../assets/img/posts/20211222/50.jpg'></center>

&emsp;&emsp;很明显，我们希望基尼指数越小越好，所以我们选择基尼指数最小的属性最为最优划分属性。

## 4.4. 剪枝处理
- 不难发现，上面对于属性的划分很容易过拟合，所以针对过拟合现象，决策树选择**剪枝(pruning)**来对付过拟合
- 剪枝就是去掉一些分支来降低过拟合的风险，剪枝可以分为预剪枝和后剪枝
- **预剪枝(prepruning)**:在决策树生成的过程中，对每个结点在划分前进行估计，若当前结点的划分不能带来决策树泛化性能的提升，则停止划分
- **后剪枝(postpruning)**:从训练集生成了一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能的提升，则将该子树替换为叶结点。

### 4.4.1. 预剪枝
- 如何判断决策树泛化性能？可以使用留出法预留一部分数据用作验证集进行性能评估，性能度量可以用之前介绍的那些，本小节使用精度作为性能度量
- 预剪枝生成的决策树：

<center><img src='../assets/img/posts/20211222/51.jpg'></center>

- 可以发现预剪枝显著减少了分支的数量，这样可以减少决策树的训练时间开销。但是这样也有一个问题，就是有些分支的当前划分虽然不能提升泛化性能，但是后续划分却有可能导致性能显著提高，这样就带来了欠拟合的风险

### 4.4.2. 后剪枝
- 首先生成决策树，然后对每个结点进行评估是否需要剪枝

<center><img src='../assets/img/posts/20211222/52.jpg'></center>

- 虽然后剪枝决策树的欠拟合风险小，泛化性能也往往优于预剪枝决策树，但是后剪枝的时间开销大

## 4.5. 连续与缺失值
### 4.5.1. 连续值处理
- 到目前为止仅讨论了基于离散属性来生成决策树，但是现实学习任务中通常会遇到连续属性
- 很明显连续属性不能根据连续属性的可取值来对结点进行划分，我们需要用到**连续属性离散化**的技术，最简单的策略是**二分法**
- 给定样本集D和和连续属性a，假定a在D上出现了n个不同的取值，将这些值从小到大排序，然后每次选择每两个数的中位数t作为划分点，那么连续值就可以当作离散值来处理了，分出的子样本集分别记作$D_t^+$和$D_t^-$

<center><img src='../assets/img/posts/20211222/53.jpg'></center>

- 划分结果：

<center><img src='../assets/img/posts/20211222/54.jpg'></center>

- 需要注意的是：**连续属性在划分后并不会被丢失，后续划分仍然可以使用**

### 4.5.2. 缺失值处理
- 在实际数据中一般都有很多缺失值，所以我们需要考虑如何对含有缺失值的数据进行学习
- 给几个定义：$\tilde{D}$表示D中属性a上没有缺失值的样本子集，假设属性值a可取值{$a^1$,$a^2$...$a^V$}, $\tilde{D}^v$表示$\tilde{D}$中属性值a取值为$a^v$的子集，$\tilde{D}_k$表示样本子集，我们为每个样本赋予权重$\omega_x$(决策树开始阶段，根结点中权重初始化为1)并定义：

<center><img src='../assets/img/posts/20211222/55.jpg'></center>

- 直观地看，对属性a，$\rho$表示无缺失值样本所占比例，$\tilde{p}_k$表示无缺失样本中第k类样本所占的比例，$\tilde{r}_v$表示无缺失值样本在属性上取值为$a^v$所占的比例

- 那么我们可以将信息增益的公式推广为

<center><img src='../assets/img/posts/20211222/56.jpg'></center>

&nbsp;

<center><img src='../assets/img/posts/20211222/57.jpg'></center>

- 那么对于那些在该属性上缺失的值如何处理呢？分两种情况：若样本$x$在划分属性$a$上的取值己知, 则将$x$划入与其取值对应的子结点，且样本权值在于结点中保持为$\omega_x$, 若样本$x$在划分属性$a$上的取值未知，则将$x$同时划入所有子结点, 且样本权值在与属性值$a^v$对应的子结点中调整为$\tilde{r}_v*\omega_x$，直观地看，这就是让同一个样本以不同的概率划入到不同的子结点中去。

- C4.5就是使用了上述的解决方法

## 4.6. 多变量决策树
- 若我们把每个属性视为坐标空间中的一个坐标轴，则d个属性描述的样本就对应了d维空间中的一个数据点，对样本分类则意味着在这个坐标空间中寻找不同类样本之间的分类边界，决策树生成的分类边界有个明显的特点：**轴平行**，即它的分类边界由若干个与坐标轴平行的分段组成

<center><img src='../assets/img/posts/20211222/58.jpg'></center>

- 这样的决策树由于要进行大量的属性测试，预测时间开销会很大，所以我们希望使用如下图红线所示的斜划分。**多变量决策树**就是能实现这样斜划分甚至更复杂划分的决策树

<center><img src='../assets/img/posts/20211222/59.jpg'></center>

- 以实现斜划分的决策树为例，非叶结点不再是仅对某一个属性，而是对属性的线性组合进行测试

<center><img src='../assets/img/posts/20211222/60.jpg'></center>

## 4.7. 阅读材料
- 多变量决策树算法主要有OC1，还有一些算法试图在决策树的叶结点上嵌入神经网络，比如感知机树在每个叶结点上训练一个感知机

- 有些决策树学习算法可进行**“增量学习”(incrementallearning)**，即在接收到新样本后可对己学得的模型进行调整，而不用完全重新学习。主要机制是通过调整分支路径上的划分属性次序来对树进行部分重构，代表性算法ID4、ID5R、ITI等。增量学习可有效地降低每次接收到新样本后的训练时间开销，但多步增量学习后的模型会与基于全部数据训练而得的模型有较大差别。

# 5. 第5章 神经网络

## 5.0. 思维导图

<center><img src='../assets/img/posts/20211222/73.jpg'></center>

## 5.1. 神经元模型
- 神经网络定义: 神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应
- 神经网络中最基本的成分是神经元模型(neuron)
- M-P神经元模型: 

<center><img src='../assets/img/posts/20211222/63.jpg'></center>

- 在这个模型中，神经元接收来自n个其他神经元传递过来的输入信号，这些输入信号通过带权重的连接进行传递，神经元接收到的总输入值将与神经元的阈值进行比较，然后通过激活函数处理以产生神经元的输出
- 激活函数: 有**阶越函数**和**Sigmoid函数**等等

<center><img src='../assets/img/posts/20211222/64.jpg'></center>

## 5.2. 感知机与多层网络
- 感知机(perceptron)由两层神经元组成，如下图所示

<center><img src='../assets/img/posts/20211222/65.jpg'></center>

- 权重$\omega_i$以及阈值$\theta$可通过学习得到

- 感知机的学习规则非常简单，对训练样例(x, y)，若当前感知机的输出为$\hat{y}$, 则感知机权重将这样调整

<center><img src='../assets/img/posts/20211222/66.jpg'></center>

- 其中$\eta$称为学习率(learning rate)
- 感知机只有输出层神经元进行激活函数处理，即只拥有一层功能神经元，其学习能力非常有限
- 要解决非线性可分问题，需考虑使用多层功能神经元，比如下图，输入层和输出层之间的一层神经元被称为隐含层(hidden layer)，隐含层和输出层神经元都是拥有激活函数的功能神经元

<center><img src='../assets/img/posts/20211222/67.jpg'></center>

- 多层前馈神经网络(multi-layer feedforward neural networks): 每层神经元与下一层神经元全互连，神经元之间不存在同层连接，也不存在跨层连接

## 5.3. 误差逆传播算法
- 误差逆传播算法(error BackPropagation)简称BP算法，可用于很多类型的神经网络

<center><img src='../assets/img/posts/20211222/68.jpg'></center>

- 误差采用均方误差:

<center><img src='../assets/img/posts/20211222/69.jpg'></center>

- BP算法基于梯度下降(gradient descent)策略，以目标的负梯度方向对参数进行调整

<center><img src='../assets/img/posts/20211222/70.jpg'></center>

- 学习率控制着算法每一轮迭代中的更新步长，若太大则容易振荡，太小则收敛速度又会过慢

- 上面介绍的标准BP算法每次仅针对**一个训练样例**更新连接权和阈值，我们也可以简单推出基于累积误差最小化的更新规则，就得到了累积BP算法
- 正是由于其强大的表达能力，BP神经网络经常遭遇过拟合，其训练误差持续降低，但测试误差却可能上升，由两种策略常用来缓解BP网络的过拟合。
    - 第一种策略是**早停(early stopping)**: 若训练集误差降低但验证集误差升高，则停止训练
    - 第二种策略是正则化，其基本思路是在误差目标函数中增加一个用于描述网络复杂度的部分，例如连接权和阈值的平方和，那么误差目标函数变成:

<center><img src='../assets/img/posts/20211222/71.jpg'></center>

## 5.4. 全局最小与局部极小
- 我们常常会谈到两种最优: **局部极小(local minimum)**和**全局最小(global minimum)**
- 直观地看，局部极小解是参数空间中的某个点，其领域点的误差函数值均不小于该点的函数值
- 全局最小解是指参数空间中所有点的误差函数值均不小于该点的误差函数值

<center><img src='../assets/img/posts/20211222/72.jpg'></center>

- 在现实任务中，人们常采用以下策略来试图跳出局部极小，从而进一步实现全局最小
    - 以多组不同参数值初始化多个神经网络
    - 使用“模拟退火”(simulated annealing)技术，每一步都以一定概率接受比当前解更差的结果，从而有助于跳出局部极小
    - 随机梯度下降，即每次使用随机的样本进行误差计算

## 5.5. 其他常见神经网络

### 5.5.1. RBF网络
- RBF(Radial Basis Function, 径向基函数)网络是一种单隐层前馈神经网络，它使用径向基函数作为隐层神经元激活函数，而输出层则是对隐层神经元输出的线性组合
- 具有足够多隐层神经元的RBF网络能以任意精度逼近任意连续函数

### 5.5.2. ART网络
- 竞争型学习(competitive learning)是神经网络中一种常用的无监督学习策略，在使用该策略时，网络的输出神经元相互竞争，每一时刻仅有一个竞争获胜的神经元被激活，其他神经元的状态被抑制。这种机制亦称胜者通吃(winner-take-all)原则
- ART(Adaptive Resonance Theory，自适应谐振理论)网络是竞争型学习的重要代表。该网络由比较层、识别层、识别阔值和重置模块构成。其中，比较层负责接受输入样本，并将其传递给识别层神经元。识别层每个神经元对应一个模式类，神经元数目可在训练过程中动态增长以增加新的模式类

### 5.5.3. SOM网络
- SOM(Self-Organizing Map，自组织映射)网络是一种竞争学习型的无监督神经网络，它能将高维输入数据映射到低维空间(通常为二维) ，同时保持输入数据在高维空间的拓扑结构，即将高维空间中相似的样本点映射到网络输出层中的邻近神经元

<center><img src='../assets/img/posts/20211222/74.jpg'></center>

### 5.5.4. 级联相关网络
- 一般的神经网络模型通常假定网络结构是事先固定的，训练的目的是利用训练样本来确定合适的连接权、阈值等参数。与此不同，结构自适网络则将网络结构也当作学习的目标之一，并希望能在训练过程中找到最符合数据特点的网络结构-级联相关(Cascade-Correlation)网络是结构自适应网络的重要代表

<center><img src='../assets/img/posts/20211222/75.jpg'></center>

### 5.5.5. Elman网络
- 与前馈神经网络不同**递归神经网络(recurrent neural networks)**允许网络中出现环形结构，从而可让一些神经元的输出反馈回来作为输入信号。这样的结构与信息反馈过程，使得网络在t时刻的输出状态不仅与t时刻的输入有关，还与t-1时刻的网络状态有关，从而能处理与时间有关的动态变化
- Elman网络是最常用的递归神经网络之一，其结构如图所示，它的结构与多层前馈网络很相似，但隐层神经元的输出被反馈回来，与下一时刻输入层神经元提供的信号一起，作为隐层神经元在下一时刻的输入。隐层神经元通常采用Sigmoid激活函数，而网络的训练则常通过推广的BP算法进行

<center><img src='../assets/img/posts/20211222/76.jpg'></center>

### 5.5.6. Boltzmann机
- 神经网络中有一类模型是为网络状态定义一个能量(energy)，能量最小化时网络达到理想状态，而网络的训练就是在最小化这个能量函数。Boltzmann机就是一种基于能量的模型(energy-based model)，常见结构如图所示，其神经元分为两层:显层与隐层。显层用于表示数据的输入与输出，隐层则被理解为数据的内在表达

<center><img src='../assets/img/posts/20211222/77.jpg'></center>

## 5.6. 深度学习
- 理论上来说，参数越多的模型复杂度越高、 "容量" (capacity) 越大，这意味着它能完成更复杂的学习任务。但一般情形下，复杂模型的训练效率低，易陷入过拟合，因此难以受到人们青睐。而随着云计算、大数据时代的到来，计算能力的大幅提高可缓解训练低效性，训练数据的大幅增加则可降低过拟合风险，因此，以"深度学习"(deep learning)为代表的复杂模型开始受到人们的关注。
- 无监督逐层训练(unsupervised layer-wise training)是多隐层网络训练的有效手段，其基本思想是每次训练一层隐结点，训练时将上一层隐结点的输出作为输入，向本层隐结点的输出作为下一层隐结点的输入，这称为**预训练(pre-training)**;在预训练全部完成后，再对整个网络进行**微调(fine-tuning)**训练
- 另一种节省训练开销的策略是权共享，即让一组神经元使用相同的连接权，比如CNN
- 以往在机器学习用于现实任务时，描述样本的特征通常需由人类专家来设计，这称为**特征工程(feature engineering)**，深度学习则通过机器学习技术自身产生好特征
- 神经网络是一种难以解释的黑箱模型

# 6. 第6章 支持向量机

## 6.0. 思维导图

<center><img src='../assets/img/posts/20211222/134.jpg'></center>

## 6.1. 间隔与支持向量
- 给定训练样本集$D={(x_1, y_1),(x_2, y_2),...,(x_m, y_m)}$, 其中$y_i\in${$-1, +1$}, 也就是一个传统的分类问题。分类学习最基本的想法就是基于训练集D在样本空间中找到一个划分超平面，将不同类别的样本分开，但能将训练样本分开的划分超平面可能有很多，如下图

<center><img src='../assets/img/posts/20211222/78.jpg'></center>

- 直观上看，应该去找位于两类训练样本正中间的划分超平面，因为该划分超平面对训练样本局部扰动的容忍性最好
- 在样本空间中，划分超平面可通过如下线性方程来描述: $\omega^Tx+b=0$, 其中$\omega$为法向量, 决定了超平面的方向, b为位移项, 决定了超平面与原点的距离, 显然划分超平面可被法向量$\omega$和b确定
- 样本空间中任意点x到超平面的距离可写为

<center><img src='../assets/img/posts/20211222/79.jpg'></center>

- 假设超平面能将训练样本正确分类, 即对($x_i, y_i$)$\in$D, 我们有以下结果: 

<center><img src='../assets/img/posts/20211222/80.jpg'></center>

- **支持向量**: 距离超平面最近的几个训练样本点使得上述条件等号成立，它们就被称为支持向量(support vector), 两个异类支持向量到超平面的距离之和为**间隔**$\gamma$

<center><img src='../assets/img/posts/20211222/81.jpg'></center>

- 图示:

<center><img src='../assets/img/posts/20211222/82.jpg'></center>

- 欲找到具有最大间隔的划分超平面，也就是找到能满足约束的最大的$\gamma$

<center><img src='../assets/img/posts/20211222/83.jpg'></center>

- 为了最大化间隔，仅需最大化\|\|$\omega$\|\|$^{-1}$, 这等价于最小化\|\|$\omega$\|\|$^{2}$, 于是上述式子可重写为: 

<center><img src='../assets/img/posts/20211222/84.jpg'></center>

- 这就是支持向量机(Support Vector Machine, SVM)的基本型

## 6.2. 对偶问题
- 我们注意到SVM的基本型本身是一个凸二次规划问题[^6], 能直接用现成的优化计算包求解，但我们可以有更高效的方法

[^6]: 二次规划(Quadratic Programming)是一种典型的优化问题，在此类问题中，目标函数是变量的二次函数，而约束条件是变量的线性不等式，假定变量个数为d，约束条件的个数为m，则标准的二次规划问题形如: <center><img src='../assets/img/posts/20211222/85.jpg'></center> 其中x为d维向量，Q为实对称矩阵，A为实矩阵，若Q为半正定矩阵，则目标函数为凸函数，相应的二次规划是凸二次优化问题。半正定矩阵即满足: A是n阶方阵，如果对任何非零向量X，都有X'AX≥0，其中X'表示X的转置，就称A为半正定矩阵。正定矩阵定义类似，只是把大于等于变成大于。此时若约束条件Ax≤b定义的可行域不为空，且目标函数在此可行域有下界，则该问题将有全局最小值。若Q为正定矩阵，则该问题有唯一全局最小值

- 对上述式子使用拉格朗日乘子法[^7]可得到其对偶问题，则该问题的拉格朗日函数可写为

<center><img src='../assets/img/posts/20211222/91.jpg'></center>

[^7]: 拉格朗日乘子法是一种寻找多元函数在一组约束下的极值的方法，通过引入拉格朗日乘子, 可将d个变量与k个约束条件的最优化问题转化为具有d+k个变量的无约束优化问题求解。首先考虑等式约束的优化问题，假定x为d维向量，欲寻找x的某个取值$x^\*$, 使目标函数f(x)最小且同时满足g(x)=0的约束，从几何角度看，该问题的目标是在由方程g(x)=0确定的d-1维曲面上寻找能使目标函数f(x)最小化的点，此时不难得到如下结论: 1.对于约束曲面上的任意点x, 该点的梯度▽g(x)正交于约束曲面; 2.在最优点$x^\*$，目标函数在该点的梯度▽f($x^\*$)正交于约束曲面<center><img src='../assets/img/posts/20211222/86.jpg'></center> 由此可知，在最优点$x^\*$，存在$\lambda$≠0使得<center><img src='../assets/img/posts/20211222/87.jpg'></center>$\lambda$称为拉格朗日算子，定义拉格朗日函数<center><img src='../assets/img/posts/20211222/88.jpg'></center>现在考虑不等式约束g(x)≤0,如图所示<center><img src='../assets/img/posts/20211222/89.jpg'></center> 此时最优点$x^\*$或在g(x)<0的区域中，或在边界g(x)=0上。对于g(x)<0的情形，约束g(x)≤0不起作用，可直接通过条件▽f(x)=0来获得最优点，这相当于将$\lambda$置零，g(x)=0的情形类似于上面等式约束的分析。因此，在约束g(x)≤0下最小化f(x)，可转化为在如下约束下最小化拉格朗日函数: <center><img src='../assets/img/posts/20211222/90.jpg'></center>上述约束条件称为KTT条件。一个优化问题可以从两个角度来考察，即主问题和对偶问题，主问题就是没有引入拉格朗日乘子的原始目标函数，对偶问题就是加上了拉格朗日乘子的目标函数，这个目标函数是原始目标函数的最优值的一个下界，所以我们希望找到最好的下界，也就是最大的下界，所以对偶函数是寻找最大值

- 其中$\alpha$=($\alpha_1$;$\alpha_2$...;$\alpha_m$), 令L($\omega$, b, $\alpha$)对$\omega$和b的偏导为零可得

<center><img src='../assets/img/posts/20211222/92.jpg'></center>

- 将这两个条件带入之前的拉格朗日函数中，即可将$\omega$和b消去，得到以下的对偶问题: 

<center><img src='../assets/img/posts/20211222/93.jpg'></center>

<center><img src='../assets/img/posts/20211222/94.jpg'></center>

- 从对偶问题中解出的$\alpha_i$是拉格朗日乘子，它恰对应着训练样本($x_i$, $y_i$), 在主问题中有不等式约束，因此上述过程需满足**KTT条件**, 即要求:

<center><img src='../assets/img/posts/20211222/96.jpg'></center>

- 解出$\alpha$后，求出$\omega$与b即可得到模型: 

<center><img src='../assets/img/posts/20211222/95.jpg'></center>

- 于是, 对任意训练样本($x_i$, $y_i$), 总有$\alpha_i=0$或者$y_if(x_i)=1$。若$\alpha_i=0$，则该样本将不会在最终的模型的求和中出现，也就不会对f(x)有任何影响;若$\alpha_i>0$, 则必有$y_if(x_i)=1$，所对应的样本点位于最大间隔边界上，是一个支持向量。这显示出支持向量机的一个重要性质:训练完成后, 大部分的训练样本都不需保留，最终模型仅与支持向量有关
- 那么如何求解对偶问题解出$\alpha_i$呢？这是一个二次规划问题, 可使用通用的二次规划算法求解，然而，该问题的规模正比于训练样本数，这会在实际任务中造成很大的开销，为了避开这个障碍，人们通过利用问题本身的特性，提出了很多高效算法, SMO是其中一个著名的代表
- SMO的基本思路是先固定$\alpha_i$之外的所有参数，然后求$\alpha_i$上的极值，由于存在约束$\sum_1^m\alpha_iy_i=0$,若固定$\alpha_i$之外的其他变量，则$\alpha_i$可由其他变量导出，于是SMO每次选择两个变量$\alpha_i$和$\alpha_j$，并固定其他参数。这样，在参数初始化后，SMO不断执行如下两个步骤直至收敛
    - 选取一对需更新的变量$\alpha_i$和$\alpha_j$
    - 固定$\alpha_i$和$\alpha_j$以外的参数，求解获得更新后的$\alpha_i$和$\alpha_j$
- 如何确定偏移项b呢？注意到对任意支持向量($x_s$, $y_s$)都有$y_sf(x_s)=1$: 

<center><img src='../assets/img/posts/20211222/97.jpg'></center>

- 其中S为所有支持向量的下标集，理论上可以选取任意支持向量来求出b，但现实任务中常采用一种更鲁棒的做法: 使用所有支持向量求解的平均值

<center><img src='../assets/img/posts/20211222/98.jpg'></center>

## 6.3. 核函数
- 在本章前面的讨论中，我们假设训练样本是线性可分的，然而在现实任务中，原始样本空间内也许并不存在一个能正确划分两类样本的超平面，例如异或问题就不是线性可分的
- 对这样的问题，可将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分，例如将异或问题的原始二维空间映射到一个合适的三维空间，就能找到一个合适的划分超平面。如果原始空间是有限维，即属性数有限，那么一定存在一个高维特征空间使样本可分

<center><img src='../assets/img/posts/20211222/99.jpg'></center>

- 令$\phi(x)$表示将x映射后的特征向量，于是在特征空间中划分超平面所对应的模型可表示为

<center><img src='../assets/img/posts/20211222/100.jpg'></center>

- 其中$\omega$和b是模型参数，我们有以下二次规划:

<center><img src='../assets/img/posts/20211222/101.jpg'></center>

- 其对偶问题是: 

<center><img src='../assets/img/posts/20211222/102.jpg'></center>

<center><img src='../assets/img/posts/20211222/103.jpg'></center>

- 我们观察到在对偶问题中涉及到计算$\phi(x_i)^T\phi(x_j)$, 这是样本$x_i$与$x_j$映射到特征空间之后的内积。由于特征空间维数可能很高，甚至是无穷维，因此直接计算$\phi(x_i)^T\phi(x_j)$通常是困难的，为了避开这个障碍，可以设想这样一个函数: 

<center><img src='../assets/img/posts/20211222/104.jpg'></center>

- 即$x_i$与$x_j$在特征空间的内积等于它们在原始样本空间中通过函数$\kappa(·,·)$计算的结果, 有了这样的函数，我们就不必直接去计算高维甚至无穷维特征空间中的内积，于是式子可重写为

<center><img src='../assets/img/posts/20211222/105.jpg'></center>

- 求解后可得到: 

<center><img src='../assets/img/posts/20211222/106.jpg'></center>

- 上面式子显示出模型最优解可通过训练样本的核函数展开，这一展式亦称**支持向量展式**
- 显然，若已知合适映射$\phi(·)$的具体形式，则可写出核函数$\kappa(·,·)$，但在现实任务中我们通常不知道$\phi(·)$是什么形式，那么合适的核函数是否一定存在呢？什么样的函数能做核函数呢？我们有以下定理: 

<center><img src='../assets/img/posts/20211222/107.jpg'></center>

- 核函数选择成为支持向量机的最大变数，若核函数选择不合适，则意味着将样本映射到一个不合适的特征空间，很可能导致性能不佳
- 常用核函数: 

<center><img src='../assets/img/posts/20211222/108.jpg'></center>

- 此外，还可通过函数组合得到:
    - 两个核函数的线性组合
    - 两个核函数的直积

    <center><img src='../assets/img/posts/20211222/109.jpg'></center>

    - 若$\kappa_1$为核函数，则对任意函数g(x): 

    <center><img src='../assets/img/posts/20211222/110.jpg'></center>
    
    也是核函数

## 6.4. 软间隔与正则化
- 在前面的讨论中，我们一直假定训练样本在样本空间或特征空间中是线性可分的，即存在一个超平面能将不同类的样本完全划分开。然而，在现实任务中往往很难确定合适的核函数使得训练样本在特征空间中线性可分
- 缓解该问题的一个方法是允许支持向量机在一些样本上出错，为此，要引入软间隔(soft margin)的概念
- 具体来说，前面介绍的支持向量机形式都是要求所有样本均满足约束，即所有样本必须划分正确，这称为硬间隔，而软间隔则允许某些样本不满足约束
- 优化目标可写为: 

<center><img src='../assets/img/posts/20211222/111.jpg'></center>

- 其中C>0是一个常数，$l_{0/1}$是0/1损失函数

<center><img src='../assets/img/posts/20211222/112.jpg'></center>

- 显然，当C无穷大时，上面式子迫使所有样本均满足约束，当C取有限值时，式子允许一些样本不满足约束
- 然而0/1损失函数非凸、非连续，数学性质不太好，于是人们通常用其他一些函数来替代它，下面给出三个常用的替代损失函数： 

<center><img src='../assets/img/posts/20211222/113.jpg'></center>

- 若采用hinge损失，则式子变成: 

<center><img src='../assets/img/posts/20211222/114.jpg'></center>

- 引入松弛变量$\xi_i$≥0，可将式子重写为

<center><img src='../assets/img/posts/20211222/115.jpg'></center>

<center><img src='../assets/img/posts/20211222/116.jpg'></center>

- 这就是常用的软间隔支持向量机，可以看出每个样本都有一个对应的松弛变量，用以表征样本不满足约束的程度
- 这仍是一个二次规划的问题，于是，通过拉格朗日乘子法可得到拉格朗日函数: 

<center><img src='../assets/img/posts/20211222/117.jpg'></center>

- 其中$\alpha_i≥0$, $\mu_i≥0$是拉格朗日乘子
- 偏导为0后可得到对偶问题: 

<center><img src='../assets/img/posts/20211222/118.jpg'></center>

- KTT条件: 

<center><img src='../assets/img/posts/20211222/119.jpg'></center>

- 可以发现软间隔支持向量机的最终模型仅与支持向量有关
- 我们还可以把0/1损失函数替换成别的替代损失函数以得到其他学习模型，这些模型的性质与所用的替代函数直接相关，但它们具有一个共性: 优化目标中的第一项用来描述划分超平面的间隔大小，另一项用来描述训练集上的误差

<center><img src='../assets/img/posts/20211222/120.jpg'></center>

- 其中$\Omega(f)$称为“结构风险”(structural risk)，用于描述模型f的某些性质;第二项$\sum_i^ml(f(x_i),y_i)$称为“经验风险”(empirical risk)，用于描述模型与训练数据的契合程度; C用于对二者进行折中。从经验风险最小化的角度来看，$\Omega(f)$表述了我们希望获得具有何种性质的模型(例如希望获得复杂度较小的模型)，这为引入领域知识和用户意图提供了途径; 另一方面，该信息有助于削减假设空间，从而降低了最小化训练误差的过拟合风险。从这个角度来说，上面的公式为“正则化”(regularization)问题，$\Omega(f)$称为正则化项，C则称为正则化常数。$L_p$范数(norm)是常用的正则化项，其中$L_2$范数$\|\|\omega\|\|_2$倾向于$\omega$的分量取值尽量均衡，即非零分量个数尽量稠密，而$L_0$范数$\|\|\omega\|\|_0$和$L_1$范数$\|\|\omega\|\|_1$则倾向于$\omega$的分量尽量稀疏，即非零分量个数尽量少

## 6.5. 支持向量回归
- 现在我们来考虑回归问题，给定训练样本$D={(x_1, y_1), (x_2, y_2), ..., (x_m, y_m))}，希望学得一个形如$f(x)=\omega^Tx+b$的回归模型，使得f(x)与y尽可能接近。
- 传统回归模型通常直接基于输出f(x)与真实输出y之间的差别来计算损失，当且仅当f(x)与y完全相同时，损失才为0。与此不同，支持向量回归(Support Vector Regression, 简称SVR)假设我们能容忍f(x)与y之间最多有$\epsilon$的偏差，如下图所示，若样本落入此间隔带，则被认为预测正确

<center><img src='../assets/img/posts/20211222/121.jpg'></center>

- 于是SVR问题可形式化为: 

<center><img src='../assets/img/posts/20211222/122.jpg'></center>

- 其中C为正则化常数，$l_{\epsilon}$是$\epsilon$-不敏感损失函数: 

<center><img src='../assets/img/posts/20211222/123.jpg'></center>

- 引入松弛变量$\xi_i$和$\hat{\xi_i}$，可将上述式子重写为: 

<center><img src='../assets/img/posts/20211222/124.jpg'></center>

<center><img src='../assets/img/posts/20211222/125.jpg'></center>

- 类似地，通过引入拉格朗日乘子可得到拉格朗日函数: 

<center><img src='../assets/img/posts/20211222/126.jpg'></center>

- 偏导为零得到对偶问题: 

<center><img src='../assets/img/posts/20211222/127.jpg'></center>

- KTT条件:

<center><img src='../assets/img/posts/20211222/128.jpg'></center>

- 将上述条件代入，SVR的解形如: 

<center><img src='../assets/img/posts/20211222/129.jpg'></center>

- 能使式子中$(\hat{\alpha}_i-\alpha_i)≠0$的样本即为SVR的支持向量，它们必落在$\epsilon$-间隔带之外
- 由KTT条件可看出，对每个样本($x_i, y_i$)都有$(C-\alpha_i)\xi_i=0$且$\alpha_i(f(x_i)-y_i-\epsilon-\xi_i)=0$，于是在得到$\alpha_i$后，若0\<$\alpha_i$\<C, 则必有$\xi_i=0$,进而有: 

<center><img src='../assets/img/posts/20211222/130.jpg'></center>

- 理论上说，可任意选取满足的$\alpha_i$来得到b，但是实践中常采用一种更鲁棒的方法: 选取多个满足0\<$\alpha_i$\<C的样本通过上述公式求解b后取平均值
- 若考虑特征映射，则:

<center><img src='../assets/img/posts/20211222/131.jpg'></center>

<center><img src='../assets/img/posts/20211222/132.jpg'></center>

## 6.6. 核方法
- 若不考虑偏移项b，则无论SVM还是SVR，学得的模型总能表示成核函数的线性组合。不仅如此，事实上我们有下面这个称为“表示定理”(representer theorem)的更一般的结论

<center><img src='../assets/img/posts/20211222/133.jpg'></center>

- 人们发展出一系列基于核函数的学习方法，统称为核方法，最常见的是通过引入核函数来将线性学习器拓展为非线性学习器
- 支持向量机是针对二分类任务设计的，对多分类任务要进行专门的推广


------------

