<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-09-28T00:20:39+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Quehry</title><subtitle>Artificial Intelligence trends and concepts made easy.</subtitle><author><name>Quehry</name></author><entry><title type="html">GAN</title><link href="http://localhost:4000/GAN.html" rel="alternate" type="text/html" title="GAN" /><published>2022-09-27T00:00:00+08:00</published><updated>2022-09-27T00:00:00+08:00</updated><id>http://localhost:4000/GAN</id><content type="html" xml:base="http://localhost:4000/GAN.html"><![CDATA[<h1 id="1-gan简介">1. GAN简介</h1>
<ul>
  <li><a href="https://arxiv.org/abs/1406.2661" target="_blank">论文链接</a></li>
</ul>]]></content><author><name>Quehry</name></author><category term="note" /><summary type="html"><![CDATA[arrange notes]]></summary></entry><entry><title type="html">重要时间点及事件</title><link href="http://localhost:4000/Important-Event.html" rel="alternate" type="text/html" title="重要时间点及事件" /><published>2022-09-26T00:00:00+08:00</published><updated>2022-09-26T00:00:00+08:00</updated><id>http://localhost:4000/Important-Event</id><content type="html" xml:base="http://localhost:4000/Important-Event.html"><![CDATA[<!-- 2022.9.23 报9月工资 -->]]></content><author><name>Quehry</name></author><category term="daily" /><summary type="html"><![CDATA[for query]]></summary></entry><entry><title type="html">T5模型</title><link href="http://localhost:4000/T5%E6%A8%A1%E5%9E%8B.html" rel="alternate" type="text/html" title="T5模型" /><published>2022-09-19T00:00:00+08:00</published><updated>2022-09-19T00:00:00+08:00</updated><id>http://localhost:4000/T5%E6%A8%A1%E5%9E%8B</id><content type="html" xml:base="http://localhost:4000/T5%E6%A8%A1%E5%9E%8B.html"><![CDATA[<!-- TOC -->

<ul>
  <li><a href="#1-t5简介">1. T5简介</a></li>
  <li><a href="#2-读论文">2. 读论文</a>
    <ul>
      <li><a href="#21-introduction">2.1. Introduction</a></li>
      <li><a href="#22-setup">2.2. Setup</a>
        <ul>
          <li><a href="#221-model">2.2.1. Model</a></li>
          <li><a href="#222-the-colossai-clean-crawled-corpusc4">2.2.2. THE Colossai Clean Crawled Corpus(C4)</a></li>
          <li><a href="#223-downstream-tasks">2.2.3. Downstream Tasks</a></li>
          <li><a href="#224-input-and-output-format">2.2.4. Input and Output Format</a></li>
        </ul>
      </li>
      <li><a href="#23-experiments">2.3. Experiments</a>
        <ul>
          <li><a href="#231-baseline">2.3.1. Baseline</a>
            <ul>
              <li><a href="#2311-model">2.3.1.1. Model</a></li>
              <li><a href="#2312-training">2.3.1.2. Training</a></li>
              <li><a href="#2313-vocabulary">2.3.1.3. Vocabulary</a></li>
              <li><a href="#2314-unsupervised-objective">2.3.1.4. Unsupervised Objective</a></li>
              <li><a href="#2315-baseline-performance">2.3.1.5. Baseline Performance</a></li>
            </ul>
          </li>
          <li><a href="#232-architectures">2.3.2. Architectures</a>
            <ul>
              <li><a href="#2321-model-structures">2.3.2.1. Model Structures</a></li>
              <li><a href="#2322-comparing-different-model-structures">2.3.2.2. Comparing Different Model Structures</a></li>
              <li><a href="#2323-objectives">2.3.2.3. Objectives</a></li>
              <li><a href="#2324-results">2.3.2.4. Results</a></li>
            </ul>
          </li>
          <li><a href="#233-unsupervised-objectives">2.3.3. Unsupervised Objectives</a></li>
          <li><a href="#234-pre-training-data-set">2.3.4. Pre-training Data Set</a></li>
          <li><a href="#235-training-strategy">2.3.5. Training Strategy</a></li>
          <li><a href="#236-scaling">2.3.6. Scaling</a></li>
          <li><a href="#237-putting-it-all-together">2.3.7. Putting It All Together</a></li>
        </ul>
      </li>
      <li><a href="#24-reflection">2.4. Reflection</a></li>
    </ul>
  </li>
  <li><a href="#3-个人总结">3. 个人总结</a></li>
</ul>

<!-- /TOC -->

<h1 id="1-t5简介">1. T5简介</h1>
<p>T5的全称是text-to-text transfer transformer，是google于2019年推出的NLP领域的大型预训练模型，T5模型将NLP领域的任务均看成text to text类型，在众多任务的表现十分优异，模型本身的结构就是transformer的encoder-decoder结构，但是预训练目标以及其他细节有所区别</p>

<p>相关链接:</p>
<ul>
  <li><a href="https://arxiv.org/abs/1910.10683" target="_blank">论文</a></li>
  <li><a href="https://github.com/google-research/text-to-text-transfer-transformer" target="_blank">github</a></li>
  <li><a href="https://ai.googleblog.com/2020/02/exploring-transfer-learning-with-t5.html" target="_blank">google博客</a></li>
  <li><a href="https://huggingface.co/docs/transformers/model_doc/t5" target="_blank">huggingface文档</a></li>
</ul>

<h1 id="2-读论文">2. 读论文</h1>
<p>摘要: 将所有的以文本为基础的语言任务变成text to text格式的任务，论文比较了不同的预训练目标、架构、无标签数据集、迁移方式在NLU任务上的表现。论文还新建了数据集C4，T5模型在很多benchmark上能做到SOTA，包括总结、QA、文本分类等。此外，T5模型和C4数据集均开源</p>

<h2 id="21-introduction">2.1. Introduction</h2>
<p>把所有的文本处理问题看成”text-to-text”问题，也即输入一段文本，输出一段文本。</p>

<center><img src="../assets/img/posts/20220919/2.jpg" /></center>

<h2 id="22-setup">2.2. Setup</h2>
<h3 id="221-model">2.2.1. Model</h3>
<p>Transformer架构一开始用于机器翻译任务，自注意力可以看成将一段序列的每个词元替换成其他词元的加权平均。T5模型的架构和Transformer的encoder-decoder结构基本一致，区别在于T5模型去除了层归一偏差，将层归一化放在残差路径外，使用了一种不同的位置嵌入方案。</p>

<h3 id="222-the-colossai-clean-crawled-corpusc4">2.2.2. THE Colossai Clean Crawled Corpus(C4)</h3>
<p>这一部分主要介绍了C4数据集的相关内容。Common Crawl是一个公开的<a href="https://commoncrawl.org/" target="_blank">数据集网站</a>，它可以提供从网页爬取的文本，但是这些文本数据存在很多问题，论文提出了以下的几种方法来让数据集更clean:</p>
<ul>
  <li>只保留以终点符号(即句点，感叹号，问号或引号)结尾的行</li>
  <li>丢弃少于五个句子的page，只保留超过3个单词的句子</li>
  <li>删除任何包含有在<a href="https://github.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words" target="_blank">List-of-Dirty</a>网站中出现的单词的网页</li>
  <li>删除包含Javascript的行</li>
  <li>删除出现“lorem ipsum”短语的page</li>
  <li>删除所有包含大括号的页面</li>
  <li>对数据集进行重复数据删除，当连续的三句话重复出现时只保留一个</li>
  <li>使用langdetect工具过滤掉非英文的页面</li>
</ul>

<h3 id="223-downstream-tasks">2.2.3. Downstream Tasks</h3>
<p>T5模型为了测量总体的语言学习能力，在很多benchmark上测试性能，比如机器翻译、QA、摘要总结、文本分类。在GLUE和SuperGLUE上测试文本分类能力，在CNN/Daily Mail上测试摘要总结能力，在SQuAD上测试QA能力…</p>

<h3 id="224-input-and-output-format">2.2.4. Input and Output Format</h3>
<p>正如在introduction中提及的一样，论文将所有的task看成text-to-text格式。这种框架为预训练和微调提供了一致的训练目标。模型用极大似然目标训练(教师强制)。为了区分不同任务，给input前加上task-specific前缀。比如为英翻德加上前缀“translate English to German: ”，论文附录里有各种任务的前缀与相关处理方法。</p>

<h2 id="23-experiments">2.3. Experiments</h2>
<p>论文搭建模型的出发点是比较不同的预训练目标、模型架构、无标签数据集等方面，从中选择表现最好的部分组成T5模型。每次只改变baseline的一部分，其余部分保持不变。BERT不太好做生成任务，比如机器翻译和摘要总结</p>

<h3 id="231-baseline">2.3.1. Baseline</h3>
<p>也即基准</p>
<h4 id="2311-model">2.3.1.1. Model</h4>
<p>模型选用Transformer的Encoder-Decoder架构，相比于只使用Encoder来说，该架构在分类和生成任务上取得更好的效果</p>

<h4 id="2312-training">2.3.1.2. Training</h4>
<p>所有的任务都是text-to-text类型，这让作者能用极大似然法和交叉熵损失来训练模型，优化器选择AdaFactor。在测试阶段，选用概率最高的词元作为输出。在预训练阶段，采用逆平方根学习率策略，即学习率会随着迭代周期下降。预训练阶段，模型迭代524288步。在微调阶段，模型迭代262144步，同时使用固定的学习率。</p>

<h4 id="2313-vocabulary">2.3.1.3. Vocabulary</h4>
<p>由于模型任务包含了翻译任务，所以词表不仅包含了英语词汇，还包括德语、法语和罗马尼亚语词汇。词表是预定义的，所以模型输出不会出现超出词表的词汇</p>

<h4 id="2314-unsupervised-objective">2.3.1.4. Unsupervised Objective</h4>
<p>模型预训练过程需要无标签的数据。过往的预训练模型训练过程都采用masked language modeling(denosing objectives)作为预训练目标，大家发现这种处理方式能取得很好的结果。对于去噪目标，模型需要预测被遮掩的词元。借鉴于BERT的经验，模型随机采样并选择丢弃了15%的词元(作为masked)，并且连续的掩蔽词元只被一个sentinel词元替代。下面展示了一个掩蔽的例子</p>

<center><img src="../assets/img/posts/20220919/3.jpg" /></center>

<h4 id="2315-baseline-performance">2.3.1.5. Baseline Performance</h4>
<p>展示了baseline模型在不同benchmark上的表现，不同的benchmark使用不同的指标</p>

<center><img src="../assets/img/posts/20220919/4.jpg" /></center>

<h3 id="232-architectures">2.3.2. Architectures</h3>
<p>比较不同框架在benchmark上的表现</p>

<h4 id="2321-model-structures">2.3.2.1. Model Structures</h4>
<p>作者选择了三种不同的架构进行对比，第一种架构是传统的Transformer的encoder-decoder架构，第二种是language modeling(encoder)架构，BERT用的就是这个架构，下一步的输出依赖于前一步的预测，第三种是Prefix Language Model，为text-to-text任务提供任务的前缀，比如翻译任务就是加上前缀translate English to German:</p>

<center><img src="../assets/img/posts/20220919/5.jpg" /></center>

<h4 id="2322-comparing-different-model-structures">2.3.2.2. Comparing Different Model Structures</h4>
<p>比较了不同模型的层数，参数和FLOPS</p>

<h4 id="2323-objectives">2.3.2.3. Objectives</h4>
<p>除了架构的区别外，还比较了不同预训练目标带来的区别，比如使用Denosing Objectives时，LM架构需要把输入和输出连接起来进行连续的预测，使用LM目标时，LM架构需要从头预测到尾</p>

<h4 id="2324-results">2.3.2.4. Results</h4>
<p>直接看表格，可以发现第一种encoder-decoder架构的表现最好</p>

<center><img src="../assets/img/posts/20220919/6.jpg" /></center>

<h3 id="233-unsupervised-objectives">2.3.3. Unsupervised Objectives</h3>
<p>本章从以下几个角度比较Unsupervised Objectives，实验得出结论，选取BERT-style，Corruption Strategies选择Replace spans，Corruption rate选择15%，Corrupted span length选择对每个词元都决定是否corrupted(独立)，也即i.i.d.，这样得出的效果最好</p>

<center><img src="../assets/img/posts/20220919/7.jpg" /></center>

<h3 id="234-pre-training-data-set">2.3.4. Pre-training Data Set</h3>
<p>最终选择了全size的C4数据集作为预训练数据集</p>

<h3 id="235-training-strategy">2.3.5. Training Strategy</h3>
<p>比较了微调的不同方案、比较了多任务同时训练和单任务训练的效果，最终发现baseline的效果最好，即预训练加下游任务微调</p>

<h3 id="236-scaling">2.3.6. Scaling</h3>
<p>尝试了扩大模型规模的几种方式，最后发现baseline选择的预训练规模是最合适的，使用较大的模型可能会使下游的微调和推断变得更加昂贵</p>

<h3 id="237-putting-it-all-together">2.3.7. Putting It All Together</h3>
<p>这一部分介绍了模型最终的一些调整内容</p>
<ul>
  <li>预训练目标: 掩蔽片段平均长度为3，同时掩蔽比率为15%</li>
  <li>更长的训练过程: C4数据集够大，让训练过程可以不用重复数据，因此增加批量大小、增加训练步数会更好</li>
  <li>模型大小: 有好几个版本的T5模型，Base、Small、Large、3B and 11B</li>
  <li>多任务预训练: 使用多任务预训练会为下游任务带来好处
展示一下最终的效果</li>
</ul>

<center><img src="../assets/img/posts/20220919/8.jpg" /></center>

<h2 id="24-reflection">2.4. Reflection</h2>
<p>这一部分总结了模型的创新部分，同时提出了模型的缺点以及展望</p>

<h1 id="3-个人总结">3. 个人总结</h1>
<p>T5模型是google继bert之后推出的一个大型预训练模型，先说说T5模型的特点，T5模型的架构是transformer的encoder-decoder架构，预训练数据集选用google自制的C4数据集，数据集也相当大，作者希望做出一个大统一的预训练模型，所以采用text-to-text任务类型也是它的一大特点，具体来说就是把所有的NLP任务变成输入一段文本，模型输出一段文本的形式，模型的预训练目标也很有特色，采用了类似bert的掩蔽预训练目标。论文做了很多很多很贵的实验，对比了很多方面，最后得到了这个模型，论文里的实验都说明的很详细，同时它也刷了很多榜，比如GLUE等，效果是比之前的预训练模型都好，是google财大气粗的表现。</p>

<p>模型在github上开源，在tensorflow上可以直接实现</p>]]></content><author><name>Quehry</name></author><category term="paper" /><summary type="html"><![CDATA[arrange notes]]></summary></entry><entry><title type="html">技术分享会笔记(关于text2image)</title><link href="http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%E4%BC%9A%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="技术分享会笔记(关于text2image)" /><published>2022-09-19T00:00:00+08:00</published><updated>2022-09-19T00:00:00+08:00</updated><id>http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%E4%BC%9A%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%E4%BC%9A%E7%AC%94%E8%AE%B0.html"><![CDATA[]]></content><author><name>Quehry</name></author><category term="note" /><summary type="html"><![CDATA[note]]></summary></entry><entry><title type="html">动手学深度学习</title><link href="http://localhost:4000/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0.html" rel="alternate" type="text/html" title="动手学深度学习" /><published>2022-09-05T00:00:00+08:00</published><updated>2022-09-05T00:00:00+08:00</updated><id>http://localhost:4000/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0</id><content type="html" xml:base="http://localhost:4000/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0.html"><![CDATA[<!-- TOC -->

<ul>
  <li><a href="#0-简介">0. 简介</a></li>
  <li><a href="#1-预备知识">1. 预备知识</a></li>
  <li><a href="#2-线性神经网络">2. 线性神经网络</a></li>
  <li><a href="#3-多层感知机">3. 多层感知机</a></li>
  <li><a href="#5-卷积神经网络">5. 卷积神经网络</a></li>
  <li><a href="#6-现代卷积神经网络">6. 现代卷积神经网络</a></li>
  <li><a href="#7-循环神经网络">7. 循环神经网络</a></li>
  <li><a href="#8-现代循环神经网络">8. 现代循环神经网络</a></li>
  <li><a href="#9-注意力机制">9. 注意力机制</a></li>
  <li><a href="#13-自然语言处理-预训练">13. 自然语言处理: 预训练</a></li>
  <li><a href="#14-自然语言处理-应用">14. 自然语言处理: 应用</a></li>
</ul>

<!-- /TOC -->

<h1 id="0-简介">0. 简介</h1>
<ul>
  <li>《动手学深度学习》的笔记</li>
  <li>各种链接:
    <ul>
      <li><a href="https://space.bilibili.com/1567748478" target="_blank">bilibili</a></li>
      <li><a href="https://zh-v2.d2l.ai/index.html" target="_blank">book_zh</a></li>
      <li><a href="https://d2l.ai/index.html" target="_blank">book_en</a></li>
    </ul>
  </li>
  <li>这本书笼统的介绍了深度学习所需要的各种知识，从线性神经网络开始讲起，然后到CNN，最后到RNN，介绍了CV和NLP领域的较新的网络结构。同时这本书不止有理论内容，每一小节都有代码实践内容，可以边写代码边了解知识，同时bilibili上有李沐老师的网课配合学习，很适合初学者进行学习。</li>
</ul>

<h1 id="1-预备知识">1. 预备知识</h1>
<p>这一章主要介绍了深度学习的一些前置知识，这里对比较重要的点做备注</p>
<ul>
  <li>张量(Tensor)包含了一维张量(向量)和二维张量(矩阵)</li>
  <li>torch中A*B是哈达玛积，表示矩阵元素按元素相乘</li>
  <li>torch.dot()是点积</li>
  <li>torch.cat(…, dim=0)表示在行上延伸，比如(3, 4)和(3, 4)变成(6, 4)</li>
  <li>A.sum(axis=0)表示把每一列的数据都相加，比如(5, 4)变成(4)</li>
  <li>范数是norm，L1范数为每个元素的绝对值相加，L2范数为元素的平方和开根号，torch中默认L2范数，一般也是L2范数用的最多</li>
  <li>梯度: 连接多元函数的所有偏导数:</li>
</ul>

<center><img src="../assets/img/posts/20220905/2.jpg" /></center>

<ul>
  <li>梯度是一个向量</li>
  <li>常用的梯度计算公式:</li>
</ul>

<center><img src="../assets/img/posts/20220905/3.jpg" /></center>

<ul>
  <li>torch中自动求导的步骤:
    <ul>
      <li>第一步 为x分配内存空间: x.requires_grad_(True)</li>
      <li>第二步 链式反向传播，希望求哪个函数的梯度，就对那个函数反向传播，比如y.backward()</li>
      <li>第三步 求x的梯度，x.grad，如果我们需要重新求梯度，需要清零梯度，x.grad.zero_()</li>
      <li>注意torch中只能对标量输出求梯度，所以常见操作是sum</li>
    </ul>
  </li>
  <li>标量对向量的偏导是向量，向量对向量的偏导是矩阵</li>
  <li>贝叶斯公式: P(A|B)P(B)=P(B|A)P(A)</li>
</ul>

<h1 id="2-线性神经网络">2. 线性神经网络</h1>
<p>本章主要介绍了线性回归网络和softmax回归网络，接下来是一些笔记</p>
<ul>
  <li>随机梯度下降和梯度下降的区别: 梯度下降一般而言是针对所有的样本而言，而随机梯度下降是针对单个样本而言，同样地，小批量随机梯度下降是针对一个批量的样本而言</li>
  <li>可以调整但是在训练过程中不更新的参数叫做超参数</li>
  <li>极大似然法: $\theta$是需要估计的值，在写似然函数时只需要把$\theta$看成参数，最大化似然函数即$\theta$的估计值</li>
  <li>每个输入与每个输出相连的层成为全连接层</li>
  <li>with torch.no_grad()的作用是让输出结果之后不构建计算图</li>
  <li>本章的训练过程: 计算y的预测值-&gt;计算损失函数-&gt;累加loss并反向传播(记得每个批量在梯度更新前需要清零梯度并反向传播loss)-&gt;更新参数</li>
  <li>训练过程中重要的组成部分: 数据迭代器、损失函数、优化器(updater/trainer)、网络(记得初始化参数)</li>
  <li>softmax为分类服务，softmax本质上是将输出规范成概率数值，方便选取预测概率最大的类作为预测类:</li>
</ul>

<center><img src="../assets/img/posts/20220905/4.jpg" /></center>

<ul>
  <li>分类的标签可以用独热编码定义</li>
  <li>网络模型用nn.sequential()定义</li>
  <li>softmax回归的损失函数可以用极大似然法推出，普通的极大似然法是最大化似然函数，但是在这里我们加上-log就变成了最小化损失函数</li>
  <li>softmax回归的损失函数是交叉熵损失:</li>
</ul>

<center><img src="../assets/img/posts/20220905/5.jpg" /></center>

<h1 id="3-多层感知机">3. 多层感知机</h1>
<p>本小节主要介绍了多层感知机的实现以及面对各种问题的解决方法，比如解决过拟合的权重衰退(weight decay)和暂退法(dropout)，解决梯度爆炸与消失的Xavier初始化。</p>
<ul>
  <li>激活函数的作用是将线性网络变成非线性，常见的有ReLU、Sigmoid、tanh</li>
  <li>ReLU: max(x, 0)</li>
  <li>Sigmoid: $\frac{1}{1+e^{-x}}$</li>
  <li>tanh: $\frac{1-e^{-2x}}{1+e^{-2x}}$</li>
  <li>在torch中可以用@来简单表示矩阵乘法</li>
  <li>用nn.Sequential()来实例化网络时，nn.ReLU()单独算一层</li>
  <li>过拟合问题可以用正则化技术解决，比如权重衰退</li>
  <li>权重衰退就是L2正则化，它在计算损失函数时增加了权重的惩罚项，比如L($\omega$, b)+$\frac{\lambda}{2}$||$\omega$||，其中$\lambda$是超参数</li>
  <li>torch框架中把权重衰退放在优化器的实例化中(torch.optim)，只需要将weight_decay的超参数输入即可</li>
  <li>暂退法(Dropout): 在前向传播中，计算每一内部层的同时注入噪音，就好像在训练过程中丢弃了一些神经元</li>
  <li>中间层活性值:</li>
</ul>

<center><img src="../assets/img/posts/20220905/6.jpg" /></center>

<ul>
  <li>只有在训练过程中才有权重衰退和暂退法</li>
  <li>在torch中简单实现dropout的方法: 在构建net时将nn.Dropout(dropout)加入nn.Sequential()，其中dropout作为丢弃概率输入Dropout中</li>
  <li>网络架构顺序: linear-&gt;relu-&gt;dropout</li>
  <li>torch中实现tensor对tensor求梯度的方法是在backward()里面加入torch.ones_like()</li>
  <li>不正常的参数初始化可能会导致梯度爆炸和梯度消失</li>
  <li>Xavier初始化是解决梯度爆炸和消失的好手段</li>
</ul>

<h1 id="5-卷积神经网络">5. 卷积神经网络</h1>
<p>这章主要介绍了CNN的基础知识，包括卷积计算以及汇聚层和简单的卷积神经网络LeNet</p>
<ul>
  <li>卷积运算即互相关运算，卷积核函数沿着输入矩阵滑动计算，一般的卷积层除了核运算外，还需要加上偏置</li>
</ul>

<center><img src="../assets/img/posts/20220905/7.jpg" /></center>

<ul>
  <li>二维卷积层的输入格式: (批量大小, 通道数, 高, 宽)，卷积层又被称为特征映射(feature map)</li>
  <li>感受野(Receptive Field)的定义是卷积神经网络每一层输出的特征图上的像素点在输入图片上映射的区域大小，也就是一个像素点对应的上一层图像的区域大小</li>
  <li>填充(padding)与步幅(stride):
    <ul>
      <li>填充的作用是在输入图像的边界填充元素(通常为0)，添加$p_h$行与$p_w$列，基本是一半在左一半在右</li>
      <li>一般在定义卷积层nn.Convd()时可以加上填充与步幅</li>
      <li>步幅包括垂直步幅$S_h$与水平步幅$S_w$</li>
      <li>在经过卷积层后，二维图像变成了$[(n_h - k_h + p_h + 1)/S_h, (n_w - k_w + p_w + 1)/S_w]$</li>
    </ul>
  </li>
  <li>多通道输入，只需把各通道输出结果加起来即可</li>
  <li>多通道输出，为每个输出通道创建一个卷积核函数$(c_i, k_h, k_w)$，假设输入通道个数$c_i$，输出通道个数为$c_o$，那么卷积核形状为$(c_o, c_i, k_h, k_w)$</li>
  <li>torch.stack(): 沿一个新维度对输入张量进行连接</li>
  <li>汇聚层(pooling)包括最大汇聚层和平均汇聚层，汇聚层是直接返回输入图像的一个小窗口的最大值或者平均值</li>
  <li>汇聚层没有可学习的参数</li>
  <li>汇聚层同样有填充与步幅，默认情况下步幅与窗口大小相同，nn.MaxPool2d()</li>
  <li>每个卷积块的基本单元是: 卷积层-&gt;激活函数-&gt;汇聚层</li>
  <li>nn.Conv2d(1, 6, kernel_size=5)其中1表示输入通道数，6表示输出通道数</li>
  <li>在CNN的最后都需要连接全连接层来变成预测类别</li>
  <li>在训练过程中如果想好好利用GPU，那么需要将网络的参数与数据集数据传入GPU，具体方法是net.to(device)、X,y.to(device)</li>
  <li>多输入多输出通道的图片示例:</li>
</ul>

<center><img src="../assets/img/posts/20220905/40.jpg" /></center>

<h1 id="6-现代卷积神经网络">6. 现代卷积神经网络</h1>
<p>这一节主要介绍了CNN的各种网络的发展历程，LeNet之后，于2012年出现深度CNN网络AlexNet，之后出现了NiN与VGG，然后是GoogleNet，之后有很大进步的网络是ResNet，直到现在，ResNet用的也很多，残差思想也持续影响后续模型的搭建</p>
<ul>
  <li>促进CV有更深的网络的两大关键因素: 数据与硬件(主要是GPU)</li>
  <li>AlexNet(深度卷积网络)于2012年ImageNet挑战赛上夺冠，第一次学习到的特征超越了手工设计的特征</li>
  <li>相比于LeNet而言，AlexNet更深、激活函数用ReLU、对训练数据进行了增广</li>
  <li>VGG(使用块的网络): VGG块由一系列卷积层(包含ReLU)+汇聚层组成，VGG网络由VGG块组成</li>
  <li>NiN(网络中的网络): NiN块结构是卷积层(含ReLU)+两个1x1卷积层(相当于全连接层)，NiN网络结构是: NiN块+汇聚层+NiN块+汇聚层+…+平均汇聚层</li>
  <li>GoogleNet(含并行连结的网络)是google花费了很多money实验出的网络，特点是参数值特殊，参数以及网络结构都是经过了很多实验得出的结果</li>
  <li>GoogleNet中基本的卷积块被称为Inception块，Inception块的架构如下图所示:</li>
</ul>
<center><img src="../assets/img/posts/20220905/41.jpg" /></center>
<ul>
  <li>GoogleNet架构: 卷积块+Inception块+最大汇聚层+Inception块+最大汇聚层+Inception块+平均汇聚层+全连接层</li>
  <li>批量规范化(Batch Normalization)是一种trick，可加速深层网络的收敛速度</li>
  <li>正则化在深度学习中非常重要</li>
  <li>对于一个批量来说，首先规范化输入(减去其均值并除以标准差)，再应用比例系数与比例偏移，就是对当前批量进行了批量规范化</li>
</ul>
<center><img src="../assets/img/posts/20220905/42.jpg" /></center>
<p>上述式子中x是输入，$\hat{\mu}_B$是这个批量的均值，$\hat{\sigma}_B$是批量的标准差，$\gamma$是比例系数，$\beta$是比例偏移，$\gamma$与$\beta$与x的形状相同，是需要学习的参数</p>
<ul>
  <li>应用于全连接层的BN: $h=\Phi(BN(Wx+b))$</li>
  <li>应用于卷积层的BN: 在每个输出通道的m*p*q个元素上同时执行BN</li>
  <li>可以发现，BN的作用位置为权重层后，激活函数前</li>
  <li>BN在训练和预测时有所不同，在预测时，直接使用模型传入的移动平均所得的均值与方差</li>
  <li>用pytorch架构简单实现BN: nn.BatchNorm2d(通道数)</li>
  <li>直观地说，BN可以使优化更加平滑</li>
  <li>残差网络ResNet于2015年在ImageNet上夺冠</li>
  <li>残差思想: 每个附加层都应该更容易地包含原始函数作为其元素之一，残差块不是为了学习输出f(x)，而是学习输出与输入的差别f(x)-x</li>
  <li>残差块的架构:</li>
</ul>
<center><img src="../assets/img/posts/20220905/43.jpg" /></center>
<ul>
  <li>ResNet的架构: 和GoogleNet很像，就是Inception变成了残差块，同时多了BN</li>
  <li>稠密链接网络DenseNet: 是ResNet的继承，DenseNet的输出是连结，而不是如ResNet那样的简单相加</li>
</ul>
<center><img src="../assets/img/posts/20220905/44.jpg" /></center>

<h1 id="7-循环神经网络">7. 循环神经网络</h1>
<p>这小节主要介绍了文本数据集如何制作，RNN的网络结构与实现</p>
<ul>
  <li>序列数据就是与时间相关的数据</li>
  <li>马尔可夫模型: 用定时间跨度的观测序列预测$x_t$</li>
  <li>$P(x_1,…,x_T)=\prod_{t=1}^TP(x_t|x_{t-1},…,x_{t-\tau})$</li>
  <li>一些名词: 文本序列、词元(token)、词表(vocabulary)、语料(corpus)</li>
  <li>文本预处理过程: 读取数据集成列表-&gt;将列表词元化，变成包含多行的词元列表-&gt;构建词表(词表将词元与数字对应)</li>
  <li>文本预处理中的词元可以是单词，也可以是字符，这里采用字符</li>
  <li>语言模型(language model)的目标是估计联合概率$P(x_1,…,x_T)$</li>
  <li>涉及一个、两个、三个变量的概率公式分别被称为一元语法、二元语法、三元语法</li>
  <li>zip()的作用是将可迭代对象打包成一个个元组，然后返回元组组成的列表</li>
  <li>构建文本序列数据集的两种方法:
    <ul>
      <li>随机采样: 随机选取，特征是原始序列，标签是原始序列右移一位</li>
      <li>顺序分区: 保证每个批量中子序列再原语料中相邻</li>
    </ul>
  </li>
  <li>相比与马尔可夫模型，隐变量模型更能体现过往序列的影响:
  $P(x_t|x_{t-1},…,x_1)=P(x_t|h_{t-1})$</li>
  <li>RNN的示意图以及推导公式:</li>
</ul>

<center><img src="../assets/img/posts/20220905/8.jpg" /></center>
<p><br /></p>
<center><img src="../assets/img/posts/20220905/9.jpg" /></center>
<p><br /></p>
<center><img src="../assets/img/posts/20220905/10.jpg" /></center>

<ul>
  <li>循环神经网络中循环的是H(Hidden state)</li>
  <li>度量语言模型的质量的性能度量是困惑度(perplexity): 一个序列中n个词元的交叉熵损失来衡量语言模型的质量</li>
</ul>

<center><img src="../assets/img/posts/20220905/11.jpg" /></center>

<ul>
  <li>最好的情况下，困惑度为1，最差的情况下，困惑度为无穷大</li>
  <li>独热编码将(批量大小, 时间步数)转变成(批量大小, 时间步数, 词表大小)，但为了方便计算，最终转变成(时间步数, 批量大小, 词表大小)</li>
  <li>梯度裁剪的作用是保证梯度不会爆炸</li>
</ul>

<center><img src="../assets/img/posts/20220905/12.jpg" /></center>

<ul>
  <li>RNN的网络结构与之前差别不大，只是在更新梯度前需要进行梯度裁剪</li>
  <li>隐藏状态形状: (隐藏层个数, 批量大小, 隐层参数个数)</li>
  <li>nn.RNN()返回的Y为隐层参数个数，需要再加上全连接层</li>
</ul>

<h1 id="8-现代循环神经网络">8. 现代循环神经网络</h1>
<p>这一章介绍了拥有记忆单元的LSTM模型，以及后续新的NLP任务机器翻译，介绍了数据集处理过程和编码器解码器结构的网络seq2seq，用来处理序列转换任务</p>
<ul>
  <li>长短期记忆网络LSTM(long short term memory)</li>
  <li>LSTM相较于普通的RNN多了很多元素，最主要的设计是记忆单元，它可以影响下一步的隐藏状态:</li>
</ul>

<center><img src="../assets/img/posts/20220905/13.jpg" /></center>
<p><br /></p>
<center><img src="../assets/img/posts/20220905/14.jpg" /></center>
<p><br /></p>
<center><img src="../assets/img/posts/20220905/15.jpg" /></center>
<p><br /></p>
<center><img src="../assets/img/posts/20220905/16.jpg" /></center>
<p><br /></p>
<center><img src="../assets/img/posts/20220905/17.jpg" /></center>
<p><br /></p>

<ul>
  <li>输入、输出、遗忘门均与$H_{t-1}$和$X_t$有关</li>
  <li>记忆单元C类似于隐状态，时时更新</li>
  <li>总的来说，LSTM中$H_t$与$H_{t-1}$、$X_t$、$C_t$都有关</li>
  <li>RNN的延伸: 多层与双向RNN，其中多层很好理解，就是把单向隐藏层的神经网络变成多层，双向的作用是让序列用到上下文信息，在预测下一个词元的任务中
双向RNN表现不佳，但是在NER中表现很好</li>
  <li>nn.LSTM(num_inputs, num_hiddens, num_layers)</li>
  <li>接下来的内容变成了机器翻译任务(序列转换)</li>
  <li>机器翻译中使用单词级词元化</li>
  <li>机器翻译数据集处理过程: 读取数据集-&gt;词元化列表-&gt;将数据集分割成source(源语言)与target(目标语言)-&gt;序列末端加上&lt;eos&gt;，同时针对长短不一的序列填充&lt;pad&gt;与截断</li>
  <li>处理序列转换任务可以用编码器-解码器结构</li>
  <li>编码器的作用是将长短可变序列变成固定形状的状态，解码器的作用是将固定形状的状态变成长度可变序列</li>
  <li>编码器为解码器输入一个状态，在seq2seq中是编码器编码过程中的隐状态，这个隐状态既作为解码器的初始state，在每个时间步中也作为上下文变量和输入concatenate之后一起输入解码器</li>
  <li>采用嵌入层将词元进行向量化，嵌入层是一个矩阵，(词表大小，特征向量维度)</li>
  <li>编码器与解码器是两个GRU</li>
  <li>permute()可以改变张量维度的位置</li>
  <li>rnn()的输入形状一般为(num_steps, batch_size, embed_size)</li>
  <li>解码器的最后同样需要一个全连接层输出</li>
  <li>解码器的第一个输入为&lt;bos&gt;</li>
  <li>由于序列存在很多&lt;pad&gt;，计算损失时不能计算pad那一部分，可以mask这一部分，所以损失函数需要重新改一下</li>
  <li>在seq2seq训练时，解码器net的输入为cat(&lt;bos&gt;，真实序列少一时间步)，这种训练机制叫做强制教学</li>
  <li>预测的时候解码器net的输入仅为&lt;bos&gt;，用每一步的预测作为下一步的输入</li>
  <li>机器翻译的性能度量为BLEU(bilingual evaluation understudy)，可用来预测输出序列的质量，当预测序列与标签序列完全相同时，BLEU为1，公式如下:</li>
</ul>

<center><img src="../assets/img/posts/20220905/18.jpg" /></center>

<ul>
  <li>编码器的功能主要是为解码器提供上下文变量c和解码器的初始隐状态</li>
</ul>

<h1 id="9-注意力机制">9. 注意力机制</h1>
<p>这章主要介绍了注意力机制，介绍了注意力机制的组成部分，比如查询、键、值、评分函数，后面又介绍了与RNN结合的Bahdanau注意力以及自注意力和多头注意力，最后介绍了transformer</p>
<ul>
  <li>注意力机制的主要成分是查询(query)、键(key)、值(value)，q和k交互形成注意力权重，然后与v相乘得到注意力汇聚结果</li>
</ul>

<center><img src="../assets/img/posts/20220905/19.jpg" /></center>

<ul>
  <li>注意力汇聚结果计算公式:</li>
</ul>

<center><img src="../assets/img/posts/20220905/20.jpg" /></center>

<p>其中x是查询，$x_i$是key，$y_i$是value，$\alpha$的作用是将x与$x_i$之间的关系建模，且权重总和为1，有点像softmax</p>

<ul>
  <li>unsqueeze()的作用是在指定位置添加一个维度，squeeze()的作用是在指定位置删除一个维度，torch.bmm()是批量矩阵乘法</li>
  <li>评分函数a同样是对q和k的关系进行建模，q、k、v都可以是向量，而且长度可以不同</li>
</ul>

<center><img src="../assets/img/posts/20220905/21.jpg" /></center>
<p><br /></p>
<center><img src="../assets/img/posts/20220905/22.jpg" /></center>
<p><br /></p>

<ul>
  <li>这里介绍了两种评分函数: 加性注意力和缩放点积注意力
    <ul>
      <li>加性注意力: 可以处理长度不同的q与k</li>
    </ul>

    <center><img src="../assets/img/posts/20220905/23.jpg" /></center>

    <ul>
      <li>缩放点积注意力(计算效率高): 要求q与k长度相同</li>
    </ul>

    <center><img src="../assets/img/posts/20220905/24.jpg" /></center>
  </li>
  <li>Bahdanau注意力模型也是编码器解码器结构，与之前的seq2seq不同，这里的上下文变量在解码器的每一步都不相同，上下文变量$c_{t’}$与解码器的上一步隐状态有关，同时在解码器和编码器的输入位置都有嵌入层</li>
</ul>

<center><img src="../assets/img/posts/20220905/25.jpg" /></center>

<ul>
  <li>多头注意力: 对q、k、v使用线性变换得到h组不同的q-k-v来输入h个注意力汇聚层，得到h个输出，这h个输出再线性变换得到最终输出</li>
</ul>

<center><img src="../assets/img/posts/20220905/26.jpg" /></center>

<ul>
  <li>自注意力就是q-k-v都是相同的一组元素</li>
  <li>自注意力无法使用序列的位置信息，可以给输入concatenate一个位置编码，比如X∈$R^{nxd}$表示n个词元的d维嵌入，P∈$R^{nxd}$表示位置嵌入矩阵，那么X+P即输入，位置编码可以基于正弦函数和余弦函数的固定位置编码</li>
</ul>

<center><img src="../assets/img/posts/20220905/27.jpg" /></center>

<ul>
  <li>transformer模型与Bahdanau模型不同，它完全基于注意力机制来构建模型</li>
  <li>transformer每块都由多头注意力和基于位置的前馈神经网络组成，其中还有残差连接，即x+sublayer(x)，再层规范化。在解码器的注意力层中，q是上个解码器层的输出，k和v是编码器输出(每个源序列的位置的编码代表一个键值对)。基于位置的前馈神经网络，简称ffn，即两层MLP</li>
</ul>

<center><img src="../assets/img/posts/20220905/28.jpg" /></center>

<h1 id="13-自然语言处理-预训练">13. 自然语言处理: 预训练</h1>
<p>这一章主要介绍了NLP领域的预训练模型，NLP领域的预训练模型都是encoder，即用文本特征来表示词元(一般都是单词)，首先介绍了word2vec，然后介绍了全局向量的词嵌入，之后介绍了子词嵌入模型fastText与字节对编码(BPE)，之后介绍了BERT(双向Transformer编码器)</p>
<ul>
  <li>在介绍RNN模型时，介绍了用独热向量来表示词元，但是这有个很严重的缺点: 不同词的独热向量的余弦相似度为0。所以接下来会介绍很多词嵌入模型，即用一个词向量来表示单词</li>
  <li>word2vec: 将词映射到固定长度的向量，这里介绍了两种模型: 跳元模型(skip-gram)与连续词袋CBOW
    <ul>
      <li>跳元模型: 假设一个词可以用来在文本序列中生成其周围的词，对于每个索引为i的单词，可以用$u_i$与$v_i$分别表示其作为上下文词和中心词的向量，可以用softmax对生成概率进行建模，对于给定中心词$w_c$，生成上下文词$w_o$的概率为:</li>
    </ul>

    <center><img src="../assets/img/posts/20220905/29.jpg" /></center>

    <p>那么跳元模型的似然函数为(上下文窗口大小为m):</p>

    <center><img src="../assets/img/posts/20220905/30.jpg" /></center>

    <p>然后通过极大似然估计法来训练</p>
    <ul>
      <li>连续词袋: 与跳元模型相反，CBOW是基于上下文词生成中心词，连续词袋模型用$v_i$和$u_i$分别表示一个词的上下文词向量与中心词向量(与跳元模型相反)，同样用softmax建模(上下文词向量相加):</li>
    </ul>

    <center><img src="../assets/img/posts/20220905/31.jpg" /></center>

    <p>连续词袋模型的似然函数:</p>

    <center><img src="../assets/img/posts/20220905/32.jpg" /></center>
  </li>
  <li>由于词表过大，使用softmax来建模的话计算成本过大，可采用两种近似训练办法来优化: 负采样与分层softmax
    <ul>
      <li>负采样建模: 直接用内积加上激活函数来表示概率，负采样即在似然函数中加上负例(从预定义分布中采样噪声词)</li>
    </ul>

    <center><img src="../assets/img/posts/20220905/33.jpg" /></center>

    <ul>
      <li>层序softmax: 用二叉树来表示概率模型，同样使用了激活函数sigmoid，时间复杂度变低</li>
    </ul>
  </li>
  <li>接下来用负采样跳元模型训练(自监督训练)来展示word2vec的效果，数据集用PTB，语料库取自华尔街时报。数据集处理时用到了下采样方法: 高频词有概率被丢弃:</li>
</ul>

<center><img src="../assets/img/posts/20220905/34.jpg" /></center>

<p>上述式子中f($w_i$)是词在整个语料库中出现的比率，t是超参数。这样高频词就不会太影响模型效果，毕竟不太关注类似a和the与其他词共同出现的概率</p>
<ul>
  <li>在下采样与负采样完毕后，一个小批量中第i个样本包括中心词及其$n_i$个上下文词和$m_i$个噪声词，数据集还需要返回mask与label，分别用来遮掩&lt;pad&gt;与标记正例</li>
  <li>word2vec本质上其实是训练一个权重矩阵(词表大小, 嵌入维度)，就是一个nn.Embedding()。跳元模型的前向传播就是计算内积矩阵torch.bmm(embed_v, embed_u)
损失函数是带掩码的交叉熵损失</li>
  <li>跳元模型在预训练完毕后，可以用来找出语义相似的单词，即计算中心词与其余所有词的余弦相似度，计算结果最高的词即为语义最相似的单词</li>
  <li>无论是word2vec的哪个模型，都着眼于中心词与上下文词的关系</li>
  <li>全局向量的词嵌入GloVe: word2vec只考虑了局部的上下文词，GloVe则考虑了全局语料库统计来设计模型，训练GloVe是为了降低以下损失函数:</li>
</ul>

<center><img src="../assets/img/posts/20220905/35.jpg" /></center>

<p>上述式子中，$x_{ij}$是中心词i与上下文词j在一个上下文窗口出现的次数，h($x_{ij}$)是每个损失项的权重，当x小于c时，h(x)=$\frac{x}{c}^\alpha$，当x大于c时h(x)=1，$b_i$与$c_j$是可学习的偏置</p>
<ul>
  <li>子词嵌入模型: 对词的内部结构进行研究(比如dog和dogs的关系)
    <ul>
      <li>fastText模型: 每个中心词由其子词的向量之和表示(子词就是单词的某些连续字符)</li>
    </ul>

    <center><img src="../assets/img/posts/20220905/36.jpg" /></center>

    <p>其余部分与跳元模型相同</p>
    <ul>
      <li>字节对编码(Byte Pair Encoding, BPE): 一种算法，用来提取子词。BPE的本质就是对训练数据集进行统计分析，找出单词的公共符号，这些公共符号将作为划分子词的依据，对于每个单词，都将返回最长的子词划分结果(这样就可以获得任意长度的子词)</li>
    </ul>
  </li>
  <li>从大型语料库中训练的词向量可用于下游的自然语言处理任务，预训练的词向量可应用到词的类比性和相似性任务中，比如GloVe和fastText</li>
  <li>torch.topk(k)的作用是返回列表中的最大值(前k个)</li>
  <li>词相似: 利用余弦相似度</li>
  <li>词类比: a:b::c:d，比如man:woman::son:daughter，词类比任务就是给出a、b、c，找到d，即让d的词向量尽量靠近vec(c)+vec(b)-vec(a)</li>
  <li>word2vec于GloVe都是上下文无关的，即对于一个词元编码，只需要输入该词元即可</li>
  <li>NLP的六种任务: 情感分析、自然语言推断、语义角色标注、共指消解，NER和QA</li>
  <li>GPT的缺点: 自回归，单向</li>
  <li>BERT使用双向Transformer编码器来编码文本，BERT同样是预训练模型，可以基于双向上下文来表示任意词元</li>
  <li>针对不同的上下文任务，BERT需要对架构进行微调</li>
  <li>BERT可输入单个文本，也可以输入文本序列对，当输入单个文本时，BERT的输入序列是&lt;cls&gt;文本&lt;sep&gt;；当输入文本对时，BERT的输入序列是&lt;cls&gt;文本1&lt;sep&gt;文本2&lt;sep&gt;</li>
  <li>在BERT中，有三个嵌入层，分别是词元嵌入(普通的embedding)、段嵌入(两个片段序列的输入，用来区分不同的句子)和位置嵌入(可学习)，之后再把结果输入encoder中</li>
</ul>

<center><img src="../assets/img/posts/20220905/37.jpg" /></center>

<ul>
  <li>BERT通过两个预训练任务来优化双向Transformer编码器，分别是掩蔽语言模型(masked language modeling 即填空)和下一句预测(next sentence predicition)
    <ul>
      <li>掩遮语言模型: 随机掩蔽词元并使用来自双向上下文的词元以自监督的方式预测掩蔽词元。预测阶段使用单隐藏层的MLP来进行预测，输入BERT的编码结果和用于预测词元的位置，然后根据预测词元的位置得到预测词元的编码结果，然后输入mlp中得到预测结果</li>
      <li>下一句预测: 二分类任务，判断文本序列对是否是连续句子，预测时同样使用MLP，输入编码后的&lt;cls&gt;词元</li>
      <li>这两个任务在制作数据集的时候都需要加上一些负例或者噪声</li>
    </ul>
  </li>
  <li>BERT的预训练数据集有很多(针对不同的应用领域，使用不同的数据集进行训练)，最开始使用的是图书语料库和wiki</li>
  <li>BERT本质上就是一个双向Transformer编码器</li>
</ul>

<h1 id="14-自然语言处理-应用">14. 自然语言处理: 应用</h1>
<p>这一章主要介绍了如何将自然语言预处理模型应用到下游任务中，首先是传统的GloVe模型和子词嵌入模型，针对这种预训练模型，需要设计特定的网络结构在适配任务，但是BERT的出现，让下游任务应用更简单，有时候只需要加一个全连接层就行，参数也只需要微调，这一章主要介绍了两个下游任务，分别是情感分析和自然语言推断</p>
<ul>
  <li>情感分析任务(sentiment analysis): 本质上就是文本序列分类任务，数据集采用Imdb的电影评论集(评论+情感)</li>
  <li>处理长短不一的序列时，使用截断与填充来预处理数据集，可以将其变成长短一致的序列</li>
  <li>一般的预训练模型应用于下游任务的方式都是: 预训练模型(词元的文本表示embed)+架构(网络)+应用(各种任务)</li>
</ul>

<center><img src="../assets/img/posts/20220905/38.jpg" /></center>

<ul>
  <li>这里介绍了两种非BERT的架构，分别是用双向LSTM和CNN来处理情感分析任务:
    <ul>
      <li>双向LSTM: 双向LSTM的初始与最终步的隐状态连结起来作为文本序列的表示，然后连接一个全连接层，输出</li>
      <li>CNN: 这里使用了一种名为textCNN的网络架构，把文本序列看成一维图像进行处理，采用一维卷积来获得局部特征</li>
      <li>一维卷积是二维卷积的一个特例，同样是核函数沿着输入滑动。多通道输入的一维互相关等同于单输入通道的二维互相关</li>
    </ul>

    <center><img src="../assets/img/posts/20220905/39.jpg" /></center>
  </li>
  <li>自然语言推断(nature language inference, NLI)任务是文本对分类任务，对文本对进行判断，决定一个句子能否由另一个句子推断出，即假设(hypothesis)能否由前提(premise)推出</li>
  <li>两个句子的三种关系:
    <ul>
      <li>蕴涵(entailment): 假设可以从前提推出</li>
      <li>矛盾(contradiction): 假设的否定可以从前提推出(我感觉本质上就是假设不能由前提推出)</li>
      <li>中性(neutral): 所有其他的情况</li>
    </ul>
  </li>
  <li>NLI使用的数据集是斯坦福自然语言推断数据集(SNLI)</li>
  <li>接下来介绍两种进行NLI的方法，分别是使用注意力机制(包含MLP)和BERT微调:
    <ul>
      <li>使用注意力机制: 利用注意力机制将两个文本序列的词元对齐，然后比较、聚合这些信息，那么本质上就是三个步骤：注意、比较、聚合:
        <ul>
          <li>注意: 与attention机制类似</li>
          <li>比较: 比较软对齐的hypothesis与premise相比较</li>
          <li>聚合: 将比较结果concat之后送入mlp</li>
          <li>这中间涉及到很多mlp层</li>
        </ul>
      </li>
      <li>另一种方法就是利用BERT进行微调，后面会具体介绍</li>
    </ul>
  </li>
  <li>这种使用非BERT的应用都是将嵌入层的权重替换成预训练模型的权重</li>
  <li>BERT可处理的一些下游任务:
    <ul>
      <li>单文本分类(比如情感分析、句子在语法上是否可接受)</li>
      <li>文本对分类/回归(NLI、语义文本相似度)</li>
      <li>词元级任务: 比如文本标注(每个词元经过相同的全连接层后，返回词性标签)、问答(QA, 使用数据集SQuAD，给定段落与问题后，预测用段落的哪个片段进行回答(也即文本片段的开始与结束位置的预测))</li>
    </ul>
  </li>
  <li>加载bert模型时，可以将预训练好的参数直接放到定义好的网络架构中</li>
  <li>之前很多预训练模型在处理下游任务时，都需要为下游任务设定特定的框架，但是BERT却并不需要设置特定的框架，有时只需要添加一个额外的全连接层即可</li>
  <li>微调只更新部分参数</li>
</ul>]]></content><author><name>Quehry</name></author><category term="note" /><summary type="html"><![CDATA[d2l note]]></summary></entry><entry><title type="html">Web速成</title><link href="http://localhost:4000/Web%E9%80%9F%E6%88%90.html" rel="alternate" type="text/html" title="Web速成" /><published>2022-08-03T00:00:00+08:00</published><updated>2022-08-03T00:00:00+08:00</updated><id>http://localhost:4000/Web%E9%80%9F%E6%88%90</id><content type="html" xml:base="http://localhost:4000/Web%E9%80%9F%E6%88%90.html"><![CDATA[<h1 id="1-html学习">1. HTML学习</h1>

<center><img src="../assets/img/posts/20220803/2.jpg" /></center>
<p><br /></p>

<center><img src="../assets/img/posts/20220803/3.jpg" /></center>
<p><br /></p>

<center><img src="../assets/img/posts/20220803/4.jpg" /></center>

<h1 id="2-css学习">2. CSS学习</h1>

<center><img src="../assets/img/posts/20220803/5.jpg" /></center>
<p><br /></p>

<center><img src="../assets/img/posts/20220803/6.jpg" /></center>
<p><br /></p>

<center><img src="../assets/img/posts/20220803/7.jpg" /></center>
<p><br /></p>

<center><img src="../assets/img/posts/20220803/8.jpg" /></center>
<p><br /></p>

<center><img src="../assets/img/posts/20220803/9.jpg" /></center>
<p><br /></p>

<h1 id="3-js学习">3. JS学习</h1>
<center><img src="../assets/img/posts/20220803/10.jpg" /></center>
<p><br /></p>

<center><img src="../assets/img/posts/20220803/11.jpg" /></center>
<p><br /></p>]]></content><author><name>Quehry</name></author><category term="note" /><summary type="html"><![CDATA[速成HTML、CSS、JS]]></summary></entry><entry><title type="html">课程总结</title><link href="http://localhost:4000/%E5%A4%A7%E5%9B%9B%E4%B8%8B%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.html" rel="alternate" type="text/html" title="课程总结" /><published>2022-04-29T00:00:00+08:00</published><updated>2022-04-29T00:00:00+08:00</updated><id>http://localhost:4000/%E5%A4%A7%E5%9B%9B%E4%B8%8B%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/%E5%A4%A7%E5%9B%9B%E4%B8%8B%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.html"><![CDATA[<!-- TOC -->

<ul>
  <li><a href="#introduction-to-corporate-finance">Introduction to corporate finance</a>
    <ul>
      <li><a href="#课程简介">课程简介</a></li>
      <li><a href="#课程内容">课程内容</a></li>
    </ul>
  </li>
  <li><a href="#工业科学">工业科学</a>
    <ul>
      <li><a href="#课程简介-1">课程简介</a></li>
      <li><a href="#课程内容-1">课程内容</a></li>
    </ul>
  </li>
  <li><a href="#量子力学">量子力学</a>
    <ul>
      <li><a href="#课程简介-2">课程简介</a></li>
      <li><a href="#课程内容-2">课程内容</a></li>
    </ul>
  </li>
  <li><a href="#统计物理">统计物理</a>
    <ul>
      <li><a href="#课程简介-3">课程简介</a></li>
      <li><a href="#课程内容-3">课程内容</a></li>
    </ul>
  </li>
  <li><a href="#信号处理">信号处理</a>
    <ul>
      <li><a href="#课程简介-4">课程简介</a></li>
      <li><a href="#课程内容-4">课程内容</a></li>
    </ul>
  </li>
  <li><a href="#结构力学2">结构力学2</a>
    <ul>
      <li><a href="#课程简介-5">课程简介</a></li>
      <li><a href="#课程内容-5">课程内容</a></li>
    </ul>
  </li>
  <li><a href="#传热学heat-transfert">传热学(Heat Transfert)</a>
    <ul>
      <li><a href="#课程简介-6">课程简介</a></li>
      <li><a href="#课程内容-6">课程内容</a></li>
    </ul>
  </li>
  <li><a href="#过程工程process-engin">过程工程(Process Engin)</a>
    <ul>
      <li><a href="#课程简介-7">课程简介</a></li>
      <li><a href="#课程内容-7">课程内容</a></li>
    </ul>
  </li>
  <li><a href="#press">Press</a>
    <ul>
      <li><a href="#课程简介-8">课程简介</a></li>
      <li><a href="#课程内容-8">课程内容</a></li>
    </ul>
  </li>
  <li><a href="#audiovisuel">Audiovisuel</a>
    <ul>
      <li><a href="#课程简介-9">课程简介</a></li>
      <li><a href="#课程内容-9">课程内容</a></li>
    </ul>
  </li>
  <li><a href="#毕业设计">毕业设计</a>
    <ul>
      <li><a href="#毕设内容">毕设内容</a></li>
    </ul>
  </li>
</ul>

<!-- /TOC -->

<h1 id="introduction-to-corporate-finance">Introduction to corporate finance</h1>

<h2 id="课程简介">课程简介</h2>
<ul>
  <li>授课老师: Danielle Levi-Feunteun</li>
  <li>授课形式: 线上</li>
  <li>授课材料: 电子讲义</li>
  <li>考核形式: 每节课都有作业需要提交，算平时分，最后还有一个开卷的考试</li>
</ul>

<h2 id="课程内容">课程内容</h2>
<p>围绕着财报进行简单的介绍</p>

<h1 id="工业科学">工业科学</h1>

<h2 id="课程简介-1">课程简介</h2>
<ul>
  <li>授课老师: 付小尧</li>
  <li>授课形式: 工业科学由两部分组成，实验和正课，都在线下完成</li>
  <li>授课材料: 实验课有电子讲义，正课有讲义和TD</li>
  <li>考核形式: 实验和正课都有线下考试，各占五十</li>
</ul>

<h2 id="课程内容-1">课程内容</h2>
<p>实验一共有8节课，都在二号楼上，实验围绕PID控制原理展开，我影响比较深的有停车场栏杆控制、云台、装乒乓球、给羽毛球拍上弦</p>

<p>正课讲了一点二进制、逻辑电路</p>

<h1 id="量子力学">量子力学</h1>

<h2 id="课程简介-2">课程简介</h2>
<ul>
  <li>授课老师: 付小尧</li>
  <li>授课形式: 线下授课</li>
  <li>授课材料: 电子讲义和TD</li>
  <li>考核形式: 线上考试</li>
</ul>

<h2 id="课程内容-2">课程内容</h2>
<p>一共有8章，第一章介绍了光电效应、黑体，第二章介绍了薛定谔方程，后面的忘了</p>

<h1 id="统计物理">统计物理</h1>

<h2 id="课程简介-3">课程简介</h2>
<ul>
  <li>授课老师: Philippe Ribiere</li>
  <li>授课形式: 线下授课</li>
  <li>授课材料: 电子讲义和TD</li>
  <li>考核形式: 大作业(统计物理与人工智能的关系)</li>
</ul>

<h2 id="课程内容-3">课程内容</h2>
<p>一共四章，对量子力学里用到的统计知识进行了补充，统计物理根据对物质微观结构及微观粒子相互作用的认识，用概率统计的方法，对由大量粒子组成的宏观物体的物理性质及宏观规律作出微观解释的理论物理学分支。</p>

<h1 id="信号处理">信号处理</h1>

<h2 id="课程简介-4">课程简介</h2>
<ul>
  <li>授课老师: Antoine Roueff</li>
  <li>授课形式: 线上授课</li>
  <li>授课材料: 电子讲义、TD、TP(Matlab)</li>
  <li>考核形式: 线上考试</li>
</ul>

<h2 id="课程内容-4">课程内容</h2>
<p>没咋听</p>

<h1 id="结构力学2">结构力学2</h1>

<h2 id="课程简介-5">课程简介</h2>
<ul>
  <li>授课老师:  Olivier Bareille、黄行蓉</li>
  <li>授课形式: 线上授课</li>
  <li>授课材料: 电子讲义和TD</li>
  <li>考核形式: 大作业(做题)</li>
</ul>

<h2 id="课程内容-5">课程内容</h2>
<p>Olivier讲正课，黄老师讲TD，由于疫情原因，最终在家完成大作业</p>

<h1 id="传热学heat-transfert">传热学(Heat Transfert)</h1>

<h2 id="课程简介-6">课程简介</h2>
<ul>
  <li>授课老师: Nelson IBASETA、张堇</li>
  <li>授课形式: 线上授课</li>
  <li>授课材料: 电子讲义和TD</li>
  <li>考核形式: 线上考试</li>
</ul>

<h2 id="课程内容-6">课程内容</h2>
<p>Nelson讲正课，张老师讲TD，主要介绍了三种传热方式，分别是热传导，热对流和热辐射</p>

<h1 id="过程工程process-engin">过程工程(Process Engin)</h1>

<h2 id="课程简介-7">课程简介</h2>
<ul>
  <li>授课老师: Dominique Pareau、唐宏哲</li>
  <li>授课形式: 线上授课</li>
  <li>授课材料: 电子讲义和TD</li>
  <li>考核形式: 两个大作业，Dominique的是做题，唐老师的是设计一个蒸馏的方案</li>
</ul>

<h2 id="课程内容-7">课程内容</h2>
<p>Dominique主要讲了工业流程中各组分的物料守恒和能量守恒，唐宏哲主要讲了蒸馏</p>

<h1 id="press">Press</h1>

<h2 id="课程简介-8">课程简介</h2>
<ul>
  <li>授课老师: Vanessa</li>
  <li>授课形式: 线下和线上授课</li>
  <li>授课材料: 电子讲义</li>
  <li>考核形式: 大作业</li>
</ul>

<h2 id="课程内容-8">课程内容</h2>
<p>法语课</p>

<h1 id="audiovisuel">Audiovisuel</h1>

<h2 id="课程简介-9">课程简介</h2>
<ul>
  <li>授课老师: Fabien</li>
  <li>授课形式: 线下和线上授课</li>
  <li>授课材料: 电子讲义</li>
  <li>考核形式: 大作业</li>
</ul>

<h2 id="课程内容-9">课程内容</h2>
<p>法语课</p>

<h1 id="毕业设计">毕业设计</h1>

<h2 id="毕设内容">毕设内容</h2>
<p>大四最重要的一门课，我的毕设是设计了一个成绩预测模型，包含了风险学科预测和成绩区间预测，主要用了一些机器学习的算法和数据处理的知识，写论文花了一周时间，剩下的就是不停的答辩</p>]]></content><author><name>Quehry</name></author><category term="school" /><summary type="html"><![CDATA[记录大四下课程和课程笔记]]></summary></entry><entry><title type="html">毕设记录</title><link href="http://localhost:4000/Graduation-Project.html" rel="alternate" type="text/html" title="毕设记录" /><published>2022-04-20T00:00:00+08:00</published><updated>2022-04-20T00:00:00+08:00</updated><id>http://localhost:4000/Graduation-Project</id><content type="html" xml:base="http://localhost:4000/Graduation-Project.html"><![CDATA[<h1 id="1-数据预处理">1. 数据预处理</h1>

<h2 id="11-使用mysql对原始数据进行处理">1.1. 使用MySQL对原始数据进行处理</h2>
<ul>
  <li>目标: 生成每行为一个学生，第一列为学号，第二列到最后一列都是课程名称</li>
  <li>第一步: 创建表格
    <ol>
      <li>首先遇到的问题是创建列名时有MySQL关键字，所以对KCMC两端加上了反引号</li>
      <li>使用Group_concat时有内容长度限制，需要使用以下代码来暂时增大限制:
        <pre><code class="language-cmd">  SET GLOBAL group_concat_max_len = 4294967295;
  SET SESSION group_concat_max_len = 4294967295;
</code></pre>
      </li>
      <li>列名长度硬性要求: 不能超过64个字符，所以我采用了将英文翻译为中文的方法减少长度，有以下几门学科名称做过修改:
        <ul>
          <li>UPDATE grade_original SET KCMC = ‘网格生成方法及软件简介’ WHERE KCMC=’An Introduction to Mesh Generation Methods &amp; Software for Scientific Computing’</li>
          <li>UPDATE grade_original SET KCMC = ‘经典论文鉴赏:电磁学顶级论文精选’ WHERE KCMC=’Appreciation of Classical Papers: The Selected Top Papers in Electromagnetism’</li>
          <li>UPDATE grade_original SET KCMC = ‘动脉硬化的脆弱性评估:从体内成像到生物力学’ WHERE KCMC=’Atherosclerosis Vulnerability Assessment: From In Vivo Imaging To Biomechanics’</li>
          <li>UPDATE grade_original SET KCMC = ‘计算机建模和仿真基础:方法、技术和应用’ WHERE KCMC=’Basics of Computer-Based Modelling and Simulation: Methodologies, Technologies and Applications’</li>
          <li>UPDATE grade_original SET KCMC = ‘当代中国外交政策及其全球治理途径’ WHERE KCMC=’Contemporary Chinese Foreign Policy and Its Global Governance Approach’</li>
          <li>UPDATE grade_original SET KCMC = ‘灵活的中英文语言:成功的必要条件’ WHERE KCMC=’Elastic Language in Chinese and English: Essential for Successful’</li>
          <li>UPDATE grade_original SET KCMC = ‘自然界中的功能结构材料:从保护到传感’ WHERE KCMC=’Functional Structural Materials in Nature: From Protection to Sensing’</li>
          <li>UPDATE grade_original SET KCMC = ‘国际商法-在中国经商的法律环境’ WHERE KCMC=’International Business Law - The Legal Environment of Doing Business in China’</li>
          <li>UPDATE grade_original SET KCMC = ‘航空航天工程疲劳与损伤容限导论’ WHERE KCMC=’Introduction to Fatigue and Damage Tolerance in Aerospace Engineering’</li>
          <li>UPDATE grade_original SET KCMC = ‘模型检查定时系统导论:理论与实践’ WHERE KCMC=’Introduction to Model-Checking Timed Systems: Theory and Practice’</li>
          <li>UPDATE grade_original SET KCMC = ‘功能薄膜磁控溅射的研究现状与发展趋势’ WHERE KCMC=’Magnetron Sputtering of Functional Thin Films: Present Status and Trends’</li>
          <li>UPDATE grade_original SET KCMC = ‘材料表征热分析原理及应用’ WHERE KCMC=’Principles and Applications of Thermal Analysis for Materials Characterization’</li>
          <li>UPDATE grade_original SET KCMC = ‘从英语学习到口译翻译能力的发展:原则与策略’ WHERE KCMC=’Progression from English Study to Interpreting and Translation Competence: Principles and Strategies’</li>
          <li>一共十三门课名有做修改</li>
        </ul>
      </li>
      <li>MySQL对列数有硬性要求: 其中InnoDB引擎要求不超过1024，其余引擎不超过4096，但是我的列数一共有1425，所以我改用了MyISAM引擎</li>
      <li>MySQL命令行代码:</li>
    </ol>

    <pre><code class="language-cmd">  SELECT
  CONCAT(
      'CREATE TABLE grade_student (', GROUP_CONCAT(DISTINCT CONCAT('\`', KCMC, '\`', ' FLOAT', CHAR(10))
      SEPARATOR ','),
      ')', 'ENGINE=MyISAM DEFAULT CHARSET=gbk;')
  FROM
      grade_original

  INTO @sql;

  PREPARE stmt_name FROM @sql;
  EXECUTE stmt_name;
</code></pre>
  </li>
  <li>目前完成: 列名创建出来，XH一行填满，但是成绩没有填</li>
  <li>先放着，后面有时间再试试，先用python</li>
</ul>

<h2 id="12-利用python的pandas库对数据进行预处理">1.2 利用Python的pandas库对数据进行预处理</h2>
<ul>
  <li>首先实现了从原始的data_original转变成data_student_0: 里面数据格式如下: 每行代表一名学生，第一列为学号，第二列至最后一列列名是学科名称，数值是成绩</li>
  <li>然后实现了去除大家都有的学科，把参加课程设为1，未参加课程设为0，生成data_student_1.csv文件，用来进行聚类</li>
  <li>聚类算法: kmeans，选了4个簇，生成的结果总体上来说非常不错，但是我希望计算一下性能度量(<strong>待办</strong>)
    <ul>
      <li>更细化来说，首先我可以手动针对学生选课来确定学院，最好是通过大三或者大四的课程来确定，以免有人中途转系等等</li>
    </ul>
  </li>
  <li>聚类后生成了data_student_2.csv，里面新增了XY列，0代表国通，1代表计院，2代表航院，3代表中法</li>
  <li>然后需要针对学年进行进一步细分: 目前聚类后的结果分布如下</li>
</ul>

<center><img src="../assets/img/posts/20220420/2.jpg" /></center>]]></content><author><name>Quehry</name></author><category term="record" /><summary type="html"><![CDATA[毕设流程记录]]></summary></entry><entry><title type="html">算法基础</title><link href="http://localhost:4000/Algorithms.html" rel="alternate" type="text/html" title="算法基础" /><published>2022-04-13T00:00:00+08:00</published><updated>2022-04-13T00:00:00+08:00</updated><id>http://localhost:4000/Algorithms</id><content type="html" xml:base="http://localhost:4000/Algorithms.html"><![CDATA[<h1 id="目录">目录</h1>
<!-- TOC -->

<ul>
  <li><a href="#目录">目录</a></li>
  <li><a href="#0-简介">0. 简介</a></li>
  <li><a href="#1-第一周-枚举">1. 第一周 枚举</a>
    <ul>
      <li><a href="#11-完美立方">1.1. 完美立方</a></li>
      <li><a href="#12-生理周期">1.2. 生理周期</a></li>
      <li><a href="#13-称硬币">1.3. 称硬币</a></li>
      <li><a href="#14-熄灯问题">1.4. 熄灯问题</a></li>
    </ul>
  </li>
  <li><a href="#2-第二周-递归一">2. 第二周 递归(一)</a>
    <ul>
      <li><a href="#21-求阶乘">2.1. 求阶乘</a></li>
      <li><a href="#22-汉诺塔问题">2.2. 汉诺塔问题</a></li>
      <li><a href="#23-n皇后问题">2.3. n皇后问题</a></li>
      <li><a href="#24-逆波兰表达式求值">2.4. 逆波兰表达式求值</a></li>
    </ul>
  </li>
  <li><a href="#3-第三周-递归二">3. 第三周 递归(二)</a>
    <ul>
      <li><a href="#31-表达式求值">3.1. 表达式求值</a></li>
      <li><a href="#32-上台阶问题">3.2. 上台阶问题</a></li>
      <li><a href="#33-放苹果问题">3.3. 放苹果问题</a></li>
      <li><a href="#34-算24问题">3.4. 算24问题</a></li>
    </ul>
  </li>
  <li><a href="#4-第四周-二分算法">4. 第四周 二分算法</a>
    <ul>
      <li><a href="#41-程序或算法的时间复杂度">4.1. 程序或算法的时间复杂度</a></li>
      <li><a href="#42-二分查找的原理和实现">4.2. 二分查找的原理和实现</a></li>
      <li><a href="#43-二分法求方程的根">4.3. 二分法求方程的根</a></li>
    </ul>
  </li>
  <li><a href="#5-第五周-分治">5. 第五周 分治</a>
    <ul>
      <li><a href="#51-归并排序">5.1. 归并排序</a></li>
      <li><a href="#52-快速排序">5.2. 快速排序</a></li>
      <li><a href="#53-例题-输出前m大的数">5.3. 例题: 输出前m大的数</a></li>
      <li><a href="#54-例题-求排序的逆序数">5.4. 例题: 求排序的逆序数</a></li>
    </ul>
  </li>
  <li><a href="#6-第六周-动态规划一">6. 第六周 动态规划(一)</a>
    <ul>
      <li><a href="#61-数字三角形">6.1. 数字三角形</a></li>
      <li><a href="#62-动态规划解题的一般思路">6.2. 动态规划解题的一般思路</a></li>
      <li><a href="#63-最长上升子序列">6.3. 最长上升子序列</a></li>
      <li><a href="#64-最长公共子序列">6.4. 最长公共子序列</a></li>
      <li><a href="#65-最佳加法表达式">6.5. 最佳加法表达式</a></li>
    </ul>
  </li>
  <li><a href="#7-第七周-动态规划二">7. 第七周 动态规划(二)</a>
    <ul>
      <li><a href="#71-help-jimmy">7.1. Help Jimmy</a></li>
      <li><a href="#72-滑雪">7.2. 滑雪</a></li>
      <li><a href="#73-神奇的口袋">7.3. 神奇的口袋</a></li>
      <li><a href="#74-0-1背包问题">7.4. 0-1背包问题</a></li>
      <li><a href="#75-分蛋糕">7.5. 分蛋糕</a></li>
    </ul>
  </li>
  <li><a href="#8-第八周-深度优先搜索一">8. 第八周 深度优先搜索(一)</a>
    <ul>
      <li><a href="#81-在图上寻找路径和遍历">8.1. 在图上寻找路径和遍历</a></li>
      <li><a href="#82-图的表示方法-邻接矩阵和邻接表">8.2. 图的表示方法: 邻接矩阵和邻接表</a></li>
      <li><a href="#83-城堡问题">8.3. 城堡问题:</a></li>
      <li><a href="#84-踩方格">8.4. 踩方格</a></li>
    </ul>
  </li>
  <li><a href="#9-第九周-深度优先搜索二">9. 第九周 深度优先搜索(二)</a>
    <ul>
      <li><a href="#91-寻路问题">9.1. 寻路问题</a></li>
      <li><a href="#92-生日蛋糕">9.2. 生日蛋糕</a></li>
    </ul>
  </li>
</ul>

<!-- /TOC -->

<h1 id="0-简介">0. 简介</h1>
<ul>
  <li>课程来源于北大郭炜老师的MOOC，在中国大学MOOC平台上有网课，课程名为<a href="https://www.icourse163.org/course/PKU-1001894005?tid=1450413466" target="_blank">程序设计与算法(二)算法基础</a>，选择第九次开课</li>
</ul>

<h1 id="1-第一周-枚举">1. 第一周 枚举</h1>

<h2 id="11-完美立方">1.1. 完美立方</h2>
<ul>
  <li>枚举: 基于逐个尝试答案的一种问题求解策略</li>
  <li>例如: 求小于N的最小素数</li>
  <li>完美立方:</li>
</ul>

<center><img src="../assets/img/posts/20220413/1.jpg" /></center>

<ul>
  <li>解题思路:</li>
</ul>

<center><img src="../assets/img/posts/20220413/2.jpg" /></center>

<h2 id="12-生理周期">1.2. 生理周期</h2>
<ul>
  <li>题干:</li>
</ul>

<center><img src="../assets/img/posts/20220413/3.jpg" /></center>

<center><img src="../assets/img/posts/20220413/4.jpg" /></center>

<ul>
  <li>解题思路:</li>
</ul>

<center><img src="../assets/img/posts/20220413/5.jpg" /></center>

<h2 id="13-称硬币">1.3. 称硬币</h2>
<ul>
  <li>题干:</li>
</ul>

<center><img src="../assets/img/posts/20220413/6.jpg" /></center>

<center><img src="../assets/img/posts/20220413/7.jpg" /></center>

<ul>
  <li>解题思路</li>
</ul>

<center><img src="../assets/img/posts/20220413/8.jpg" /></center>

<h2 id="14-熄灯问题">1.4. 熄灯问题</h2>
<ul>
  <li>题干:</li>
</ul>

<center><img src="../assets/img/posts/20220413/9.jpg" /></center>

<center><img src="../assets/img/posts/20220413/10.jpg" /></center>

<center><img src="../assets/img/posts/20220413/11.jpg" /></center>

<ul>
  <li>解题思路:</li>
</ul>

<center><img src="../assets/img/posts/20220413/12.jpg" /></center>

<center><img src="../assets/img/posts/20220413/13.jpg" /></center>

<p>局部的思想，化繁为简</p>

<ul>
  <li>可以用0-31的十进制数来表示第一列的数据，因为其二进制数刚好对应开关的状态</li>
</ul>

<h1 id="2-第二周-递归一">2. 第二周 递归(一)</h1>
<h2 id="21-求阶乘">2.1. 求阶乘</h2>
<ul>
  <li>递归的基本概念: 一个函数调用其自身就是递归</li>
</ul>

<center><img src="../assets/img/posts/20220413/14.jpg" /></center>

<ul>
  <li>递归和普通函数调用一样是通过栈实现</li>
</ul>

<center><img src="../assets/img/posts/20220413/15.jpg" /></center>

<ul>
  <li>递归的作用
    <ul>
      <li>替代多重循环</li>
      <li>解决本来就是递归形式定义的问题</li>
      <li>将问题分解为规模更小的问题进行求解: 比如n！变成n * (n-1)</li>
    </ul>
  </li>
</ul>

<h2 id="22-汉诺塔问题">2.2. 汉诺塔问题</h2>
<ul>
  <li>任务描述:</li>
</ul>

<center><img src="../assets/img/posts/20220413/16.jpg" /></center>

<ul>
  <li>解决思路: 把盘子从A移动到C的过程分解为三个小问题，分别是移动n-1个盘子从A到B，然后移动1个盘子从A到C，最后移动n-1个盘子从B到C，这就是一个递归问题</li>
  <li>递归的核心思想是将大问题分解为规模更小的问题，同时还要保证是从n变成n-1</li>
  <li>代码实现:</li>
</ul>

<center><img src="../assets/img/posts/20220413/17.jpg" /></center>
<p><br /></p>
<center><img src="../assets/img/posts/20220413/18.jpg" /></center>
<p><br /></p>

<h2 id="23-n皇后问题">2.3. n皇后问题</h2>
<ul>
  <li>问题描述:</li>
</ul>

<center><img src="../assets/img/posts/20220413/19.jpg" /></center>

<p>用递归代替多重循环，皇后的攻击范围是横竖斜</p>
<ul>
  <li>解决思路: 同样是从第1行开始逐个往后摆放，但是这里的n是未知数，所以循环的层数不确定，这个时候就可以用递归代替循环，构造一个函数，表示从第k行开始摆放棋子，然后在循环内部判断每一列的位置是否能摆放，就是一个穷举问题了</li>
  <li>代码实现:</li>
</ul>

<center><img src="../assets/img/posts/20220413/20.jpg" /></center>
<p><br /></p>
<center><img src="../assets/img/posts/20220413/21.jpg" /></center>
<p><br /></p>
<center><img src="../assets/img/posts/20220413/22.jpg" /></center>
<p><br /></p>

<p>这个代码设计很巧妙的地方是，它会遍历所有的情况，只要是满足条件的就会输出，所以会返回所有可能的结果</p>

<h2 id="24-逆波兰表达式求值">2.4. 逆波兰表达式求值</h2>
<ul>
  <li>问题描述:</li>
</ul>

<center><img src="../assets/img/posts/20220413/23.jpg" /></center>

<ul>
  <li>输入输出例子:</li>
</ul>

<center><img src="../assets/img/posts/20220413/24.jpg" /></center>

<ul>
  <li>解决思路: 一个数也可以看成一个逆波兰表达式，那么就可以直接用递归求解，实现过程中需要边输入边递归</li>
  <li>代码实现:</li>
</ul>

<center><img src="../assets/img/posts/20220413/25.jpg" /></center>

<h1 id="3-第三周-递归二">3. 第三周 递归(二)</h1>
<h2 id="31-表达式求值">3.1. 表达式求值</h2>
<ul>
  <li>问题描述:</li>
</ul>

<center><img src="../assets/img/posts/20220413/26.jpg" /></center>

<ul>
  <li>解决思路: 
先看看表达式递归的定义</li>
</ul>
<center><img src="../assets/img/posts/20220413/27.jpg" /></center>
<center><img src="../assets/img/posts/20220413/28.jpg" /></center>
<p>即然把表达式的递归过程弄清楚了，那么只需要定义表达式、项、因子的函数即可</p>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/29.jpg" /></center>
<center><img src="../assets/img/posts/20220413/30.jpg" /></center>
<center><img src="../assets/img/posts/20220413/31.jpg" /></center>
<center><img src="../assets/img/posts/20220413/32.jpg" /></center>

<h2 id="32-上台阶问题">3.2. 上台阶问题</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/33.jpg" /></center>
<ul>
  <li>输入输出样例:</li>
</ul>
<center><img src="../assets/img/posts/20220413/34.jpg" /></center>
<ul>
  <li>解决思路: 将n级台阶的走法看成n-1级台阶的走法+n-2级台阶的走法，分别代表在第一步走一阶还是两阶，这里需要设置边界条件来防止无限递归</li>
</ul>
<center><img src="../assets/img/posts/20220413/35.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/36.jpg" /></center>

<h2 id="33-放苹果问题">3.3. 放苹果问题</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/37.jpg" /></center>
<ul>
  <li>解决思路: 又是计算方法的总数，那么和上台阶问题一样，用表达式来表示递归，分类讨论。假设i个苹果，k个盘子，如果k&gt;i，那么等价于把i个苹果放到i个盘子里，因为一定有k-i个盘子空着；如果k&lt;=i，那么又将问题分为有没有空盘子，如果有空盘子，那么至少有一个空盘子，表示为把i个苹果放到k-1个盘子里，如果没有空盘子，那么等价于把i-k个苹果放到k个盘子里</li>
</ul>
<center><img src="../assets/img/posts/20220413/38.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/39.jpg" /></center>

<h2 id="34-算24问题">3.4. 算24问题</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/40.jpg" /></center>
<ul>
  <li>输入输出样例:</li>
</ul>
<center><img src="../assets/img/posts/20220413/41.jpg" /></center>
<ul>
  <li>判断两个浮点数是否相等，用两个浮点数的差是否小于某个值</li>
  <li>解决思路: 不论给了多少个数计算24，都需要首先计算出两个数的计算结果，这个计算过程可以是加减乘除任意，然后得到的结果再和剩下的n-1个数算24，这样就可以变成一个递归问题，边界条件是只剩一个数的时候是否是24</li>
</ul>
<center><img src="../assets/img/posts/20220413/42.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/43.jpg" /></center>
<center><img src="../assets/img/posts/20220413/44.jpg" /></center>
<center><img src="../assets/img/posts/20220413/45.jpg" /></center>
<center><img src="../assets/img/posts/20220413/46.jpg" /></center>

<h1 id="4-第四周-二分算法">4. 第四周 二分算法</h1>
<h2 id="41-程序或算法的时间复杂度">4.1. 程序或算法的时间复杂度</h2>
<ul>
  <li>时间复杂度的定义:</li>
</ul>
<center><img src="../assets/img/posts/20220413/47.jpg" /></center>
<p>重点是明白程序中固定的操作是什么</p>
<ul>
  <li>复杂度有平均复杂度和最坏复杂度两种，两者可能一致，也可能不一致，一般来说只要平均复杂度不太高，算法的效率就还可以</li>
  <li>常见的时间复杂度:</li>
</ul>
<center><img src="../assets/img/posts/20220413/48.jpg" /></center>
<center><img src="../assets/img/posts/20220413/49.jpg" /></center>

<h2 id="42-二分查找的原理和实现">4.2. 二分查找的原理和实现</h2>
<ul>
  <li>首先可以看这么一个问题:</li>
</ul>
<center><img src="../assets/img/posts/20220413/50.jpg" /></center>
<ul>
  <li>二分查找的实现: 时间复杂度是O(log(n))</li>
</ul>
<center><img src="../assets/img/posts/20220413/51.jpg" /></center>
<ul>
  <li>查找比待查找数小的最大坐标的函数实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/52.jpg" /></center>
<ul>
  <li>二分查找的问题前提是序列必须是递增或者递减的，即有序的</li>
  <li>为了防止数据溢出，写中点的时候要这么写: int mid = L + (R - L) / 2</li>
  <li>整型在转型的时候是向下取整</li>
</ul>

<h2 id="43-二分法求方程的根">4.3. 二分法求方程的根</h2>
<ul>
  <li>二分法求方程的根需要方程满足一定的条件，不是所有的方程都可以用二分法求根</li>
  <li>问题描述及求解思路:</li>
</ul>
<center><img src="../assets/img/posts/20220413/53.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/54.jpg" /></center>
<ul>
  <li>如果一个序列不是有序的，可以用排序算法对序列先进行排序然后二分查找</li>
</ul>

<h1 id="5-第五周-分治">5. 第五周 分治</h1>
<h2 id="51-归并排序">5.1. 归并排序</h2>
<ul>
  <li>分治的基本概念:</li>
</ul>
<center><img src="../assets/img/posts/20220413/55.jpg" /></center>
<ul>
  <li>分治的典型应用: 归并排序</li>
</ul>
<center><img src="../assets/img/posts/20220413/56.jpg" /></center>
<ul>
  <li>归并排序的思路就是先分治，然后归并，代码实现如下：</li>
</ul>
<center><img src="../assets/img/posts/20220413/57.jpg" /></center>
<center><img src="../assets/img/posts/20220413/58.jpg" /></center>
<center><img src="../assets/img/posts/20220413/59.jpg" /></center>
<ul>
  <li>归并排序的时间复杂度:</li>
</ul>
<center><img src="../assets/img/posts/20220413/60.jpg" /></center>

<h2 id="52-快速排序">5.2. 快速排序</h2>
<ul>
  <li>快速排序的思想:</li>
</ul>
<center><img src="../assets/img/posts/20220413/61.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/62.jpg" /></center>
<center><img src="../assets/img/posts/20220413/63.jpg" /></center>
<center><img src="../assets/img/posts/20220413/64.jpg" /></center>
<ul>
  <li>快速排序的时间复杂度是O(nlog(n))，这是在运气不坏的情况下得出的结果(平均复杂度)，运气最坏的情况下时间复杂度为O($n^2$)(最坏复杂度)</li>
</ul>

<h2 id="53-例题-输出前m大的数">5.3. 例题: 输出前m大的数</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/65.jpg" /></center>
<ul>
  <li>解决思路:</li>
</ul>
<center><img src="../assets/img/posts/20220413/66.jpg" /></center>
<p>用分治的思想解决问题，先把前m个元素移到数组的最右边，然后在对这m个元素进行快排</p>
<ul>
  <li>具体解决方法:</li>
</ul>
<center><img src="../assets/img/posts/20220413/67.jpg" /></center>
<center><img src="../assets/img/posts/20220413/68.jpg" /></center>
<ul>
  <li>时间复杂度计算:</li>
</ul>
<center><img src="../assets/img/posts/20220413/69.jpg" /></center>

<h2 id="54-例题-求排序的逆序数">5.4. 例题: 求排序的逆序数</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/70.jpg" /></center>
<ul>
  <li>解决思路:</li>
</ul>
<center><img src="../assets/img/posts/20220413/71.jpg" /></center>
<center><img src="../assets/img/posts/20220413/72.jpg" /></center>
<p>分治一般都使用了递归</p>

<h1 id="6-第六周-动态规划一">6. 第六周 动态规划(一)</h1>
<h2 id="61-数字三角形">6.1. 数字三角形</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/73.jpg" /></center>
<ul>
  <li>输入格式:</li>
</ul>
<center><img src="../assets/img/posts/20220413/74.jpg" /></center>
<ul>
  <li>解题思路: 
看成递归问题</li>
</ul>
<center><img src="../assets/img/posts/20220413/75.jpg" /></center>
<ul>
  <li>递归程序代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/76.jpg" /></center>
<ul>
  <li>虽然说在代码逻辑这一方面，递归算法没有问题，但是这个算法的时间复杂度太高，程序很容易超时:</li>
</ul>
<center><img src="../assets/img/posts/20220413/77.jpg" /></center>
<ul>
  <li>之前的递归算法中存在过多的重复计算，如果能把每一步的计算结果保存起来，那么即可避免重复计算，算法的时间复杂度为O($n^2$)</li>
</ul>
<center><img src="../assets/img/posts/20220413/78.jpg" /></center>
<ul>
  <li>记忆递归型动规程序:</li>
</ul>
<center><img src="../assets/img/posts/20220413/79.jpg" /></center>
<p>用一个二维数组存储每一个结点的max值，那么读取到这个结点时，就可以直接获得数值，避免了重复计算</p>
<ul>
  <li>也可以用递推的思想解决问题，先把最后一行的结果计算出来，然后从下到上逐步计算，用一个双重循环解决</li>
</ul>
<center><img src="../assets/img/posts/20220413/80.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/81.jpg" /></center>
<ul>
  <li>还可以对空间进行优化，因为下一层的数值在计算上一层的数值后就没有用了，那么完全不需要用一个二维数组存储maxsum，完全可以用一个一维数组存放。再进一步来说，连maxSum数组都可以不要，直接用D的第n行替代maxSum</li>
</ul>
<center><img src="../assets/img/posts/20220413/82.jpg" /></center>
<ul>
  <li>空间优化后的代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/83.jpg" /></center>

<h2 id="62-动态规划解题的一般思路">6.2. 动态规划解题的一般思路</h2>
<ul>
  <li>递归到动规的一般转化方法:</li>
</ul>
<center><img src="../assets/img/posts/20220413/84.jpg" /></center>
<ul>
  <li>动规解题的一般思路:
    <ul>
      <li>第一步: 将原问题分解为子问题</li>
    </ul>
    <center><img src="../assets/img/posts/20220413/85.jpg" /></center>
    <ul>
      <li>第二步: 确定状态</li>
    </ul>
    <center><img src="../assets/img/posts/20220413/86.jpg" /></center>
    <ul>
      <li>第三步: 确定一些初始状态的值</li>
    </ul>
    <center><img src="../assets/img/posts/20220413/87.jpg" /></center>
    <ul>
      <li>第四步: 确定状态转移方程</li>
    </ul>
    <center><img src="../assets/img/posts/20220413/88.jpg" /></center>
  </li>
  <li>能用动规解决的问题的特点:</li>
</ul>
<center><img src="../assets/img/posts/20220413/89.jpg" /></center>

<h2 id="63-最长上升子序列">6.3. 最长上升子序列</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/90.jpg" /></center>
<ul>
  <li>输入输出格式:</li>
</ul>
<center><img src="../assets/img/posts/20220413/91.jpg" /></center>
<ul>
  <li>解题思路:
    <ul>
      <li>找子问题:</li>
    </ul>
    <center><img src="../assets/img/posts/20220413/92.jpg" /></center>
    <center><img src="../assets/img/posts/20220413/93.jpg" /></center>
    <ul>
      <li>确定状态:</li>
    </ul>
    <center><img src="../assets/img/posts/20220413/94.jpg" /></center>
    <ul>
      <li>找出状态转移方程:</li>
    </ul>
    <center><img src="../assets/img/posts/20220413/95.jpg" /></center>
  </li>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/96.jpg" /></center>
<ul>
  <li>动规的常用两种形式:</li>
</ul>
<center><img src="../assets/img/posts/20220413/97.jpg" /></center>

<h2 id="64-最长公共子序列">6.4. 最长公共子序列</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/98.jpg" /></center>
<ul>
  <li>输入输出样例:</li>
</ul>
<center><img src="../assets/img/posts/20220413/99.jpg" /></center>
<ul>
  <li>解题思路:</li>
</ul>
<center><img src="../assets/img/posts/20220413/100.jpg" /></center>
<p>重要的还是找到一个合适的子问题与状态</p>
<ul>
  <li>状态转移方程</li>
</ul>
<center><img src="../assets/img/posts/20220413/101.jpg" /></center>
<ul>
  <li>证明一下这个递推公式是正确的:</li>
</ul>
<center><img src="../assets/img/posts/20220413/102.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/103.jpg" /></center>
<center><img src="../assets/img/posts/20220413/104.jpg" /></center>

<h2 id="65-最佳加法表达式">6.5. 最佳加法表达式</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/105.jpg" /></center>
<ul>
  <li>解题思路:</li>
</ul>
<center><img src="../assets/img/posts/20220413/106.jpg" /></center>
<center><img src="../assets/img/posts/20220413/107.jpg" /></center>
<center><img src="../assets/img/posts/20220413/108.jpg" /></center>

<h1 id="7-第七周-动态规划二">7. 第七周 动态规划(二)</h1>
<h2 id="71-help-jimmy">7.1. Help Jimmy</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/109.jpg" /></center>
<center><img src="../assets/img/posts/20220413/110.jpg" /></center>
<ul>
  <li>输入输出样例:</li>
</ul>
<center><img src="../assets/img/posts/20220413/111.jpg" /></center>
<center><img src="../assets/img/posts/20220413/112.jpg" /></center>
<ul>
  <li>解题思路:</li>
</ul>
<center><img src="../assets/img/posts/20220413/113.jpg" /></center>
<p>板子的顺序其实没有关系，重要的关注点是当前板子的左侧或右侧正下方的板子是哪个板子，然后计算出从每个板子的左侧或者右侧下降需要的最短时间，也就是说这里的状态值得是不同的板子</p>
<ul>
  <li>伪代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/114.jpg" /></center>
<center><img src="../assets/img/posts/20220413/115.jpg" /></center>
<center><img src="../assets/img/posts/20220413/116.jpg" /></center>
<p>将下落点看成宽度为0的板子是一种很好的思路</p>
<ul>
  <li>时间复杂度:</li>
</ul>
<center><img src="../assets/img/posts/20220413/117.jpg" /></center>

<h2 id="72-滑雪">7.2. 滑雪</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/118.jpg" /></center>
<ul>
  <li>输入输出样例:</li>
</ul>
<center><img src="../assets/img/posts/20220413/119.jpg" /></center>
<ul>
  <li>解题思路:</li>
</ul>
<center><img src="../assets/img/posts/20220413/120.jpg" /></center>
<center><img src="../assets/img/posts/20220413/121.jpg" /></center>
<center><img src="../assets/img/posts/20220413/122.jpg" /></center>
<p>这个题目递推的顺序很奇怪，如果按照二维数组的排序顺序来递推会出现问题，这里比较好的解决思路是把点按照高度排序，因为如果高度低的点值没求出来的话，高度高的点的值一定求不出来。然后这里排完序后有两种解决思路，一种是按顺序把每个点的值根据周围四个低的点求出，另一种思路是按照顺序每次更新周围四个点的值</p>

<h2 id="73-神奇的口袋">7.3. 神奇的口袋</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/123.jpg" /></center>
<ul>
  <li>输入输出样例:</li>
</ul>
<center><img src="../assets/img/posts/20220413/124.jpg" /></center>
<ul>
  <li>当然可以用枚举的方法暴力求解</li>
  <li>也可以用递推的方法求解:</li>
</ul>
<center><img src="../assets/img/posts/20220413/125.jpg" /></center>
<p>设计一个递推的函数，代表前k个物品凑w体积的方法个数，那么在新出现这个物品时有两个选择，即选或不选</p>
<ul>
  <li>动规解法:</li>
</ul>
<center><img src="../assets/img/posts/20220413/126.jpg" /></center>
<p>用二维数组来表示状态</p>

<h2 id="74-0-1背包问题">7.4. 0-1背包问题</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/127.jpg" /></center>
<ul>
  <li>解题思路: 和上一小节的思路类似，状态同样用二维数组表示，然后找出状态转移方程求解即可</li>
</ul>
<center><img src="../assets/img/posts/20220413/128.jpg" /></center>
<center><img src="../assets/img/posts/20220413/129.jpg" /></center>
<center><img src="../assets/img/posts/20220413/130.jpg" /></center>
<p>可以用滚动数组的思想来优化空间，递推的过程是从右往左替换滚动数组的过程</p>

<h2 id="75-分蛋糕">7.5. 分蛋糕</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/131.jpg" /></center>
<ul>
  <li>输入输出样例:</li>
</ul>
<center><img src="../assets/img/posts/20220413/132.jpg" /></center>
<ul>
  <li>解题思路:</li>
</ul>
<center><img src="../assets/img/posts/20220413/133.jpg" /></center>
<p>由于这里存在高宽，所以状态需要用三维数组表示</p>
<ul>
  <li>递推公式:</li>
</ul>
<center><img src="../assets/img/posts/20220413/134.jpg" /></center>

<h1 id="8-第八周-深度优先搜索一">8. 第八周 深度优先搜索(一)</h1>
<h2 id="81-在图上寻找路径和遍历">8.1. 在图上寻找路径和遍历</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/135.jpg" /></center>
<ul>
  <li>利用这种策略，可能出现的情况:</li>
</ul>
<center><img src="../assets/img/posts/20220413/136.jpg" /></center>
<ul>
  <li>深度优先搜索(Depth-First-Search)的定义:</li>
</ul>
<center><img src="../assets/img/posts/20220413/137.jpg" /></center>
<ul>
  <li>刚才那个问题的伪代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/138.jpg" /></center>
<center><img src="../assets/img/posts/20220413/139.jpg" /></center>
<ul>
  <li>如果要记录路径，代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/140.jpg" /></center>
<center><img src="../assets/img/posts/20220413/141.jpg" /></center>

<h2 id="82-图的表示方法-邻接矩阵和邻接表">8.2. 图的表示方法: 邻接矩阵和邻接表</h2>
<ul>
  <li>邻接矩阵表示图:</li>
</ul>
<center><img src="../assets/img/posts/20220413/142.jpg" /></center>
<ul>
  <li>邻接表表示图:</li>
</ul>
<center><img src="../assets/img/posts/20220413/143.jpg" /></center>

<h2 id="83-城堡问题">8.3. 城堡问题:</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/144.jpg" /></center>
<ul>
  <li>输入输出样例:</li>
</ul>
<center><img src="../assets/img/posts/20220413/145.jpg" /></center>
<center><img src="../assets/img/posts/20220413/146.jpg" /></center>
<ul>
  <li>解题思路: 这种比较抽象的问题可以通过建模转换成相对简单的题目，把城堡的方块看成节点，然后如果两个方块连接，则连接这两个节点</li>
</ul>
<center><img src="../assets/img/posts/20220413/147.jpg" /></center>
<p>求房间个数等价于求极大连通子图个数</p>
<center><img src="../assets/img/posts/20220413/148.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/149.jpg" /></center>
<center><img src="../assets/img/posts/20220413/150.jpg" /></center>

<h2 id="84-踩方格">8.4. 踩方格</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/151.jpg" /></center>
<ul>
  <li>解决思路: 用递归的思路解决问题，第一步的选择有三种，那么走n步的方案数等于这三种走法的方案和</li>
</ul>
<center><img src="../assets/img/posts/20220413/152.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/153.jpg" /></center>
<center><img src="../assets/img/posts/20220413/154.jpg" /></center>

<h1 id="9-第九周-深度优先搜索二">9. 第九周 深度优先搜索(二)</h1>
<h2 id="91-寻路问题">9.1. 寻路问题</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/155.jpg" /></center>
<ul>
  <li>解题思路: 从城市1开始深度优先遍历整个图，找到能到达城市N的最优路线(在不超过开销情况下的最短路径)</li>
</ul>
<center><img src="../assets/img/posts/20220413/156.jpg" /></center>
<p>但是这种方法会超时，所以我们需要对算法进行改进(剪枝)，最容易想到的方法是最优性剪枝，但是发现这种剪枝方法还是超时了</p>
<center><img src="../assets/img/posts/20220413/157.jpg" /></center>
<p>这种剪枝方法能保存中间计算结果，效果比之前的最优性剪枝要好</p>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/158.jpg" /></center>
<center><img src="../assets/img/posts/20220413/159.jpg" /></center>
<center><img src="../assets/img/posts/20220413/160.jpg" /></center>
<center><img src="../assets/img/posts/20220413/161.jpg" /></center>
<center><img src="../assets/img/posts/20220413/162.jpg" /></center>

<h2 id="92-生日蛋糕">9.2. 生日蛋糕</h2>
<ul>
  <li>下棋也是一个深度搜索的过程</li>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/163.jpg" /></center>
<p>蛋糕的高和半径是递减的</p>
<ul>
  <li>解题思路:</li>
</ul>
<center><img src="../assets/img/posts/20220413/164.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/165.jpg" /></center>
<center><img src="../assets/img/posts/20220413/166.jpg" /></center>
<ul>
  <li>剪枝(剪枝在深度优先搜索中很重要)</li>
</ul>
<center><img src="../assets/img/posts/20220413/167.jpg" /></center>]]></content><author><name>Quehry</name></author><category term="note" /><summary type="html"><![CDATA[郭炜老师算法网课记录]]></summary></entry><entry><title type="html">C语言程序设计</title><link href="http://localhost:4000/C-Language.html" rel="alternate" type="text/html" title="C语言程序设计" /><published>2022-02-25T00:00:00+08:00</published><updated>2022-02-25T00:00:00+08:00</updated><id>http://localhost:4000/C-Language</id><content type="html" xml:base="http://localhost:4000/C-Language.html"><![CDATA[<h1 id="目录">目录</h1>

<!-- TOC -->

<ul>
  <li><a href="#目录">目录</a></li>
  <li><a href="#1-第一章-c语言快速入门">1. 第一章 C语言快速入门</a>
    <ul>
      <li><a href="#11-信息在计算机中的表示">1.1. 信息在计算机中的表示</a>
        <ul>
          <li><a href="#111-用0和1表示各种信息">1.1.1. 用0和1表示各种信息</a></li>
          <li><a href="#112-十进制到二进制的互相转换">1.1.2. 十进制到二进制的互相转换</a></li>
          <li><a href="#113-k进制小数">1.1.3. K进制小数</a></li>
          <li><a href="#114-十六进制数到二进制数的相互转换">1.1.4. 十六进制数到二进制数的相互转换</a></li>
        </ul>
      </li>
      <li><a href="#12-c语言快速入门">1.2. C语言快速入门</a></li>
      <li><a href="#13-变量和数据类型初探">1.3. 变量和数据类型初探</a>
        <ul>
          <li><a href="#131-什么是变量">1.3.1. 什么是变量</a></li>
          <li><a href="#132-变量的命名规则">1.3.2. 变量的命名规则</a></li>
          <li><a href="#133-c的基本数据类型">1.3.3. C++的基本数据类型</a></li>
        </ul>
      </li>
      <li><a href="#14-变量和数据类型进阶">1.4. 变量和数据类型进阶</a>
        <ul>
          <li><a href="#141-数据类型的自动转换">1.4.1. 数据类型的自动转换</a></li>
        </ul>
      </li>
      <li><a href="#15-常量">1.5. 常量</a>
        <ul>
          <li><a href="#151-整型常量">1.5.1. 整型常量</a></li>
          <li><a href="#152-字符型常量">1.5.2. 字符型常量</a></li>
          <li><a href="#153-符号常量">1.5.3. 符号常量</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#2-第二章-输入输出和基本运算">2. 第二章 输入输出和基本运算</a>
    <ul>
      <li><a href="#21-输入输出进阶">2.1. 输入输出进阶</a>
        <ul>
          <li><a href="#211-输入输出控制符">2.1.1. 输入输出控制符</a></li>
          <li><a href="#212-用scanf读入不同类型的变量">2.1.2. 用scanf读入不同类型的变量</a></li>
          <li><a href="#213-控制printf输出整数的宽度">2.1.3. 控制printf输出整数的宽度</a></li>
          <li><a href="#214-用c的cout进行输出">2.1.4. 用C++的cout进行输出</a></li>
          <li><a href="#215-用c的cin进行输入">2.1.5. 用C++的cin进行输入</a></li>
        </ul>
      </li>
      <li><a href="#22-算术运算符和算术表达式">2.2. 算术运算符和算术表达式</a>
        <ul>
          <li><a href="#221-赋值运算符">2.2.1. 赋值运算符</a></li>
          <li><a href="#222-算术运算符">2.2.2. 算术运算符</a></li>
          <li><a href="#223-模运算">2.2.3. 模运算</a></li>
          <li><a href="#224-自增运算符-">2.2.4. 自增运算符 ++</a></li>
        </ul>
      </li>
      <li><a href="#23-关系运算符和逻辑表达式">2.3. 关系运算符和逻辑表达式</a>
        <ul>
          <li><a href="#231-关系运算符">2.3.1. 关系运算符</a></li>
          <li><a href="#232-逻辑运算符和逻辑表达式">2.3.2. 逻辑运算符和逻辑表达式</a></li>
        </ul>
      </li>
      <li><a href="#24-其他运算符及运算符优先级">2.4. 其他运算符及运算符优先级</a>
        <ul>
          <li><a href="#241-强制类型转换运算符">2.4.1. 强制类型转换运算符</a></li>
          <li><a href="#242-部分运算符的优先级">2.4.2. 部分运算符的优先级</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#3-分支语句和循环语句">3. 分支语句和循环语句</a>
    <ul>
      <li><a href="#31-if语句">3.1. if语句</a>
        <ul>
          <li><a href="#311-条件分支结构">3.1.1. 条件分支结构</a></li>
          <li><a href="#312-if语句">3.1.2. if语句</a></li>
        </ul>
      </li>
      <li><a href="#32-switch语句">3.2. switch语句</a></li>
      <li><a href="#33-for循环">3.3. for循环</a>
        <ul>
          <li><a href="#331-for循环语句">3.3.1. for循环语句</a></li>
        </ul>
      </li>
      <li><a href="#34-while循环和do-while循环">3.4. while循环和do while循环</a>
        <ul>
          <li><a href="#341-while循环">3.4.1. while循环</a></li>
          <li><a href="#342-do-while循环">3.4.2. do while循环</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#4-第四章-循环综合应用">4. 第四章 循环综合应用</a>
    <ul>
      <li><a href="#41-break语句和continue语句">4.1. break语句和continue语句</a>
        <ul>
          <li><a href="#411-break语句">4.1.1. break语句</a></li>
          <li><a href="#412-continue语句">4.1.2. continue语句</a></li>
        </ul>
      </li>
      <li><a href="#42-oj输入数据的处理">4.2. OJ输入数据的处理</a>
        <ul>
          <li><a href="#421-scanf表达式的值">4.2.1. scanf表达式的值</a></li>
          <li><a href="#422-用freopen重定向输入">4.2.2. 用freopen重定向输入</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#5-第五章-数组">5. 第五章 数组</a>
    <ul>
      <li><a href="#51-数组">5.1. 数组</a></li>
      <li><a href="#52-筛法求素数">5.2. 筛法求素数</a></li>
      <li><a href="#53-数组初始化">5.3. 数组初始化</a></li>
      <li><a href="#54-数组越界">5.4. 数组越界</a></li>
      <li><a href="#55-二维数组">5.5. 二维数组</a></li>
    </ul>
  </li>
  <li><a href="#6-第六章-函数和位运算">6. 第六章 函数和位运算</a>
    <ul>
      <li><a href="#61-函数">6.1. 函数</a></li>
      <li><a href="#62-递归初步">6.2. 递归初步</a></li>
      <li><a href="#63-库函数和头文件">6.3. 库函数和头文件</a></li>
      <li><a href="#64-位运算">6.4. 位运算</a>
        <ul>
          <li><a href="#641-按位与">6.4.1. 按位与&amp;</a></li>
          <li><a href="#642-按位或\">6.4.2. 按位或|</a></li>
          <li><a href="#643-按位异或^">6.4.3. 按位异或^</a></li>
          <li><a href="#644-按位非">6.4.4. 按位非~</a></li>
          <li><a href="#645-左移运算符">6.4.5. 左移运算符«</a></li>
          <li><a href="#646-右移运算符">6.4.6. 右移运算符»</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#7-第七章-字符串">7. 第七章 字符串</a>
    <ul>
      <li><a href="#71-字符串的形式和存储">7.1. 字符串的形式和存储</a></li>
      <li><a href="#72-输入字符串">7.2. 输入字符串</a></li>
      <li><a href="#73-字符串库函数">7.3. 字符串库函数</a></li>
    </ul>
  </li>
  <li><a href="#8-第八章-指针一">8. 第八章 指针(一)</a>
    <ul>
      <li><a href="#81-指针的基本概念和用法">8.1. 指针的基本概念和用法</a></li>
      <li><a href="#82-指针的意义和相互赋值">8.2. 指针的意义和相互赋值</a></li>
      <li><a href="#83-指针的运算">8.3. 指针的运算</a></li>
      <li><a href="#84-指针作为函数参数">8.4. 指针作为函数参数</a></li>
      <li><a href="#85-指针和数组">8.5. 指针和数组</a></li>
    </ul>
  </li>
  <li><a href="#9-第九章-指针二">9. 第九章 指针(二)</a>
    <ul>
      <li><a href="#91-指针和二维数组指向指针的指针">9.1. 指针和二维数组、指向指针的指针</a></li>
      <li><a href="#92-指针和字符串">9.2. 指针和字符串</a></li>
      <li><a href="#93-字符串库函数">9.3. 字符串库函数</a></li>
      <li><a href="#94-void指针和内存操作函数">9.4. void指针和内存操作函数</a></li>
      <li><a href="#95-函数指针">9.5. 函数指针</a></li>
    </ul>
  </li>
  <li><a href="#10-第十章-程序结构和简单算法">10. 第十章 程序结构和简单算法</a>
    <ul>
      <li><a href="#101-结构">10.1. 结构</a></li>
      <li><a href="#102-全局变量局部变量静态变量">10.2. 全局变量、局部变量、静态变量</a></li>
      <li><a href="#103-变量的作用域和生存周期">10.3. 变量的作用域和生存周期</a></li>
      <li><a href="#104-选择排序和插入排序">10.4. 选择排序和插入排序</a>
        <ul>
          <li><a href="#1041-选择排序">10.4.1. 选择排序</a></li>
          <li><a href="#1042-插入排序">10.4.2. 插入排序</a></li>
        </ul>
      </li>
      <li><a href="#105-冒泡排序">10.5. 冒泡排序</a></li>
      <li><a href="#106-程序或算法的时间复杂度">10.6. 程序或算法的时间复杂度</a></li>
    </ul>
  </li>
  <li><a href="#11-第十一章-文件读写">11. 第十一章 文件读写</a>
    <ul>
      <li><a href="#111-文件读写概述">11.1. 文件读写概述</a>
        <ul>
          <li><a href="#1111-打开文件的函数">11.1.1. 打开文件的函数</a></li>
        </ul>
      </li>
      <li><a href="#112-文本文件读写">11.2. 文本文件读写</a>
        <ul>
          <li><a href="#1121-文本文件读写">11.2.1. 文本文件读写</a></li>
          <li><a href="#1121-文本文件读写另一种函数">11.2.1. 文本文件读写(另一种函数)</a></li>
        </ul>
      </li>
      <li><a href="#113-二进制文件读写概述">11.3. 二进制文件读写概述</a>
        <ul>
          <li><a href="#1131-文件的读写指针">11.3.1. 文件的读写指针</a></li>
          <li><a href="#1132-二进制文件读写">11.3.2. 二进制文件读写</a></li>
        </ul>
      </li>
      <li><a href="#114-创建和读取二进制文件">11.4. 创建和读取二进制文件</a></li>
      <li><a href="#115-修改二进制文件">11.5. 修改二进制文件</a></li>
      <li><a href="#116-文件拷贝程序">11.6. 文件拷贝程序</a></li>
    </ul>
  </li>
  <li><a href="#12-c的stl">12. C++的STL</a>
    <ul>
      <li><a href="#121-stl排序算法sort">12.1. STL排序算法sort</a></li>
      <li><a href="#122-stl二分查找算法">12.2. STL二分查找算法</a>
        <ul>
          <li><a href="#1221-用binary_search进行二分查找">12.2.1. 用binary_search进行二分查找</a></li>
          <li><a href="#1222-用lower_bound二分查找下界">12.2.2. 用lower_bound二分查找下界</a></li>
          <li><a href="#1223-用upper_bound二分查找上界">12.2.3. 用upper_bound二分查找上界</a></li>
        </ul>
      </li>
      <li><a href="#123-multiset">12.3. multiset</a></li>
      <li><a href="#124-set">12.4. set</a></li>
      <li><a href="#125-multimap">12.5. multimap</a></li>
      <li><a href="#126-map">12.6. map</a></li>
    </ul>
  </li>
</ul>

<!-- /TOC -->

<h1 id="1-第一章-c语言快速入门">1. 第一章 C语言快速入门</h1>

<h2 id="11-信息在计算机中的表示">1.1. 信息在计算机中的表示</h2>

<h3 id="111-用0和1表示各种信息">1.1.1. 用0和1表示各种信息</h3>
<ul>
  <li>计算机中的所有信息都是用0、1表示</li>
  <li>二进制数的一位，称为一个比特(bit), 简写b</li>
  <li>八个二进制位称为一个字节(byte), 简写B</li>
  <li>1KB, 1MB, 1GB, 1TB</li>
  <li>ASCII编码方案：用8个连续的0或1来表示一个字母数字和标点符号，一共有256种不同的组合</li>
</ul>

<h3 id="112-十进制到二进制的互相转换">1.1.2. 十进制到二进制的互相转换</h3>
<ul>
  <li>十进制数是数的十进制表示形式的简称</li>
  <li>短除法，每次除以进制，余数就是这个进制的最小位数</li>
</ul>

<h3 id="113-k进制小数">1.1.3. K进制小数</h3>
<ul>
  <li>K进制小数和整数的定义类似，只不过变成了K的负次方，比如小数后的第一位是$K^{-1}$</li>
</ul>

<h3 id="114-十六进制数到二进制数的相互转换">1.1.4. 十六进制数到二进制数的相互转换</h3>

<center><img src="assets/img/posts/20220225/2.jpg" /></center>

<h2 id="12-c语言快速入门">1.2. C语言快速入门</h2>

<ul>
  <li>空格也是一个字符</li>
  <li>C语言中输入输出: scanf、printf</li>
  <li>程序的注释:
    <ul>
      <li>多行注释: /* …  */</li>
      <li>单行注释: //</li>
    </ul>
  </li>
</ul>

<h2 id="13-变量和数据类型初探">1.3. 变量和数据类型初探</h2>

<h3 id="131-什么是变量">1.3.1. 什么是变量</h3>
<ul>
  <li>变量就是一个代号, 程序运行时系统会自动为变量分配内存空间，于是变量就代表了系统分配的那片内存空间</li>
  <li>变量有名字和类型两种属性，变量的类型决定了一个变量占用多少个字节</li>
  <li>变量的定义要在使用之前</li>
  <li>一个变量不能定义两次</li>
</ul>

<h3 id="132-变量的命名规则">1.3.2. 变量的命名规则</h3>
<ul>
  <li>变量不能以数字开头</li>
  <li>变量只能由大小写字母、数字和下划线组成</li>
  <li>变量名不能和C++系统预留的一些保留字重复</li>
</ul>

<h3 id="133-c的基本数据类型">1.3.3. C++的基本数据类型</h3>

<center><img src="assets/img/posts/20220225/3.jpg" /></center>

<ul>
  <li>float的取值范围是绝对值的范围</li>
  <li>整型、实数型、布尔型、字符型</li>
  <li>用sizeof()可以返回数据类型所占的字节数</li>
  <li>变量在定义的时候可以给它指定一个初始值</li>
</ul>

<h2 id="14-变量和数据类型进阶">1.4. 变量和数据类型进阶</h2>

<ul>
  <li>整型可以分为有符号整型和无符号整型</li>
  <li>有符号整数的表示方式
    <ul>
      <li>将最左边的位看作符号位，符号位为0表示非负数，其绝对值就是除去符号位以外的部分</li>
      <li>符号位为1，则表示是负数，其绝对值是除符号位以外的部分<strong>取反</strong>后加1</li>
      <li>将一个负整数转化为有符号整数是: 符号位取1，其余部分取该负整数的绝对值的二进制表示取反加1</li>
    </ul>
  </li>
</ul>

<h3 id="141-数据类型的自动转换">1.4.1. 数据类型的自动转换</h3>
<ul>
  <li>有些不同的数据类型之间是相容的，可以相互赋值</li>
  <li>int a = 11.34, 其实就是a=11</li>
  <li>整型数据也可以转换为字符型数据, 但只会留下最右边的一个字节</li>
  <li>看一个例子</li>
</ul>

<center><img src="assets/img/posts/20220225/4.jpg" /></center>

<h2 id="15-常量">1.5. 常量</h2>

<h3 id="151-整型常量">1.5.1. 整型常量</h3>
<ul>
  <li>十六进制整型常量以0x开头</li>
  <li>一个十六进制位正好对应四个二进制位</li>
  <li>0开头的是八进制数</li>
</ul>

<h3 id="152-字符型常量">1.5.2. 字符型常量</h3>
<ul>
  <li>字符型常量表示一个字符，用单引号括起来</li>
  <li>字符型常量和变量都占一个字节，内部存放的是ASCII编码</li>
  <li>小写字母的ASCII编码比大写字母大</li>
  <li>字符型常量中有一部分以‘\’开头, 被称为转义字符</li>
</ul>

<center><img src="assets/img/posts/20220225/5.jpg" /></center>

<ul>
  <li>字符串常量用双引号括起来，字符常量用单引号括起来</li>
</ul>

<h3 id="153-符号常量">1.5.3. 符号常量</h3>
<ul>
  <li>为了阅读和修改方便, 常用一个由字母和数字组成的符号来代表某个常量</li>
  <li>#define 常量名 常量值</li>
  <li>尽量多用符号常量，少用数值常量</li>
</ul>

<h1 id="2-第二章-输入输出和基本运算">2. 第二章 输入输出和基本运算</h1>

<h2 id="21-输入输出进阶">2.1. 输入输出进阶</h2>

<h3 id="211-输入输出控制符">2.1.1. 输入输出控制符</h3>
<ul>
  <li>在printf和scanf中可以使用以%开头的控制符，指明要输入和输出的数据类型</li>
  <li>常用的格式控制符</li>
</ul>

<center><img src="assets/img/posts/20220225/6.jpg" /></center>

<h3 id="212-用scanf读入不同类型的变量">2.1.2. 用scanf读入不同类型的变量</h3>
<ul>
  <li>输入字符时，不会跳过空格</li>
  <li>如果在输入中有scanf中出现的非控制字符，则这些字符会被跳过</li>
</ul>

<h3 id="213-控制printf输出整数的宽度">2.1.3. 控制printf输出整数的宽度</h3>
<ul>
  <li>比如用%nd和%0nd控制输出整型的长度</li>
  <li>用%.nf控制输出浮点数的精度</li>
</ul>

<h3 id="214-用c的cout进行输出">2.1.4. 用C++的cout进行输出</h3>
<ul>
  <li>cout « …</li>
  <li>endl可以进行换行</li>
</ul>

<h3 id="215-用c的cin进行输入">2.1.5. 用C++的cin进行输入</h3>
<ul>
  <li>cin » …</li>
  <li>cin、cout的速度比printf、scanf慢，输入输出数据量大的时候用后者</li>
  <li>一个程序不要同时使用cout和printf</li>
</ul>

<h2 id="22-算术运算符和算术表达式">2.2. 算术运算符和算术表达式</h2>

<h3 id="221-赋值运算符">2.2.1. 赋值运算符</h3>
<ul>
  <li>a += b 等同于 a = a + b</li>
</ul>

<h3 id="222-算术运算符">2.2.2. 算术运算符</h3>
<ul>
  <li>加减乘除</li>
  <li>%表示取余数</li>
  <li>两个整数进行加减乘都可能导致计算结果超出了结果类型所能表示的范围，这种情况就是溢出</li>
  <li>如果溢出，则直接丢弃溢出的部分</li>
  <li>有时计算的最终结果似乎不会溢出，但中间结果可能溢出，这也会导致程序出错</li>
  <li>解决溢出的办法是尽量使用高精度的数据类型</li>
  <li>除法的结果、类型和操作数中精度高的类型相同</li>
</ul>

<h3 id="223-模运算">2.2.3. 模运算</h3>
<ul>
  <li>求余数的运算符%也称为模运算符，两个操作数都是整数类型</li>
</ul>

<h3 id="224-自增运算符-">2.2.4. 自增运算符 ++</h3>
<ul>
  <li>自增运算符有前置用法和后置用法</li>
  <li>前置用法: ++ a 表示将a的值加1，表达式返回a+1后的值</li>
  <li>后置用法: a ++ 表示将a的值加1，表达式返回值为a加1前的值</li>
</ul>

<h2 id="23-关系运算符和逻辑表达式">2.3. 关系运算符和逻辑表达式</h2>

<h3 id="231-关系运算符">2.3.1. 关系运算符</h3>
<ul>
  <li>一共有六种关系运算符用于数值的比较</li>
  <li>比较的结果是bool类型</li>
</ul>

<center><img src="assets/img/posts/20220225/7.jpg" /></center>

<h3 id="232-逻辑运算符和逻辑表达式">2.3.2. 逻辑运算符和逻辑表达式</h3>
<ul>
  <li>逻辑运算符用于表达式的逻辑操作，有&amp;&amp;、||、!这三种，操作结果为true或false</li>
  <li>逻辑表达式是短路运算，即对逻辑表达式的计算在整个表达式的值已经能够断定的时候停止</li>
</ul>

<h2 id="24-其他运算符及运算符优先级">2.4. 其他运算符及运算符优先级</h2>

<h3 id="241-强制类型转换运算符">2.4.1. 强制类型转换运算符</h3>
<ul>
  <li>(int)、(char)这样的运算符就是强制将操作数转换为指定类型</li>
</ul>

<h3 id="242-部分运算符的优先级">2.4.2. 部分运算符的优先级</h3>

<center><img src="assets/img/posts/20220225/8.jpg" /></center>

<h1 id="3-分支语句和循环语句">3. 分支语句和循环语句</h1>

<h2 id="31-if语句">3.1. if语句</h2>

<h3 id="311-条件分支结构">3.1.1. 条件分支结构</h3>
<ul>
  <li>有时候我们希望满足一个条件执行一种语句，另一个条件执行另一种语句</li>
</ul>

<h3 id="312-if语句">3.1.2. if语句</h3>
<ul>
  <li>if语句可以没有else if，也可以没有else</li>
  <li>如果语句组只有一条语句，则不需要{}</li>
  <li>if语句可以嵌套</li>
  <li>else总是和离它最近的if配对，加一个花括号可以解决这个问题</li>
</ul>

<h2 id="32-switch语句">3.2. switch语句</h2>

<center><img src="assets/img/posts/20220225/9.jpg" /></center>

<ul>
  <li>可以没有default语句</li>
  <li>注意常量表达式不能带变量</li>
</ul>

<h2 id="33-for循环">3.3. for循环</h2>

<h3 id="331-for循环语句">3.3.1. for循环语句</h3>

<center><img src="assets/img/posts/20220225/10.jpg" /></center>

<ul>
  <li>注意是先执行语句组然后执行表达式3</li>
  <li>表达式1和表达式3都可以是用逗号连接的若干个表达式</li>
  <li>for循环可以嵌套，形成多重for循环</li>
  <li>for语句括号里面的表达式1、表达式2、表达式3可以任何一个都不写，但是分号必须保留</li>
</ul>

<h2 id="34-while循环和do-while循环">3.4. while循环和do while循环</h2>

<h3 id="341-while循环">3.4.1. while循环</h3>

<center><img src="assets/img/posts/20220225/11.jpg" /></center>

<h3 id="342-do-while循环">3.4.2. do while循环</h3>
<ul>
  <li>如果希望循环至少要执行一次，那么可以用do while循环</li>
</ul>

<center><img src="assets/img/posts/20220225/12.jpg" /></center>

<h1 id="4-第四章-循环综合应用">4. 第四章 循环综合应用</h1>

<h2 id="41-break语句和continue语句">4.1. break语句和continue语句</h2>

<h3 id="411-break语句">4.1.1. break语句</h3>
<ul>
  <li>break语句出现在循环体中，其作用是跳出循环</li>
  <li>在多重循环中，break语句只能跳出直接包含它的那一重循环</li>
</ul>

<h3 id="412-continue语句">4.1.2. continue语句</h3>
<ul>
  <li>continue可以出现在循环体中，其作用是立即结束本次循环，并回到循环开头判断是否要进行下一次循环</li>
</ul>

<h2 id="42-oj输入数据的处理">4.2. OJ输入数据的处理</h2>

<h3 id="421-scanf表达式的值">4.2.1. scanf表达式的值</h3>
<ul>
  <li>scanf()表达式其实是有返回值的，返回值为int类型，表示成功读入的变量个数</li>
  <li>scamf()值为EOF则说明输入数据已经结束</li>
  <li>ctrl+z表示输入结束</li>
  <li>这样就可以处理无结束标记的OJ题目输入</li>
</ul>

<h3 id="422-用freopen重定向输入">4.2.2. 用freopen重定向输入</h3>
<ul>
  <li>调试程序时，每次运行程序都要输入测试数据，太麻烦</li>
  <li>可以将测试数据存入文件，然后用freopen将输入由键盘重定向为文件，则运行程序时不再需要输入数据</li>
</ul>

<h1 id="5-第五章-数组">5. 第五章 数组</h1>

<h2 id="51-数组">5.1. 数组</h2>
<ul>
  <li>数组可以用来表达类型相同的元素的集合，集合的名字就是数组名</li>
  <li>一维数组的定义方法如下：</li>
</ul>

<center><img src="assets/img/posts/20220225/13.jpg" /></center>

<ul>
  <li>元素个数必须是常量或常量表达式</li>
  <li>sizeof()可以访问数组所占字节</li>
  <li>数组名代表数组的地址</li>
  <li>数组一般不要定义在main里面，尤其是大数组</li>
</ul>

<h2 id="52-筛法求素数">5.2. 筛法求素数</h2>
<ul>
  <li>之前我们判断一个数n是不是素数，使用2到根号n之间的所有整数去除n，也就是穷举</li>
  <li>筛法：把2到n中所有的数都列出来，然后从2开始，先划掉n内所有2的倍数，然后每次从下一个剩下的数开始，划掉其n内的所有倍数，最后剩下的数就是素数</li>
  <li>筛法会稍微快一点，用空间换时间</li>
  <li>代码如下：</li>
</ul>

<center><img src="assets/img/posts/20220225/14.jpg" /></center>

<h2 id="53-数组初始化">5.3. 数组初始化</h2>
<ul>
  <li>在定义一个一维数组的同时，可以给数组中的元素赋初值</li>
</ul>

<center><img src="assets/img/posts/20220225/15.jpg" /></center>

<ul>
  <li>如果在定义数组的时候，如给全部元素赋值，则可以不给出数组元素的个数</li>
  <li>可以用数组取代复杂分支结构</li>
  <li>使用string须包含头文件<string></string></li>
</ul>

<h2 id="54-数组越界">5.4. 数组越界</h2>
<ul>
  <li>数组元素的下标，可以是任何整数，可以是负数，也可以大于数组的元素个数，不会导致编译错误</li>
  <li>但如果将越界写入了别的变量的内存空间，就很有可能出错</li>
</ul>

<h2 id="55-二维数组">5.5. 二维数组</h2>
<ul>
  <li>二维数组的定义：</li>
</ul>

<center><img src="assets/img/posts/20220225/16.jpg" /></center>

<ul>
  <li>二维数组的访问可以直接用下标访问</li>
  <li>二维数组的初始化也是用{}</li>
  <li>二维数组初始化时，如果对每行都进行初始化，则不用写行数或列数</li>
</ul>

<h1 id="6-第六章-函数和位运算">6. 第六章 函数和位运算</h1>

<h2 id="61-函数">6.1. 函数</h2>
<ul>
  <li>函数可以实现某一功能，当程序中需要使用该项功能时，只需要写一条语句，调用实现该功能的函数即可</li>
  <li>函数的定义:</li>
</ul>

<center><img src="assets/img/posts/20220225/17.jpg" /></center>

<ul>
  <li>函数的调用: 函数名(参数1, 参数2…)</li>
  <li>函数中至少含有一个return, 如果函数的类型为void, 则用return;</li>
  <li>定义函数的参数叫做形参, 调用函数时的参数叫做实参</li>
  <li>函数的定义一般在调用之前</li>
  <li>但是函数的调用语句前面有函数的声明即可，不一定要有定义</li>
</ul>

<center><img src="assets/img/posts/20220225/18.jpg" /></center>

<ul>
  <li>C/C++程序从main函数开始</li>
  <li>函数的形参是实参的一个拷贝，形参的改变一般不会影响到实参</li>
  <li>一维数组作为形参时不用写出元素的个数，这时候形参的改变会影响实参</li>
  <li>二维数组作为形参时，必须写明数组有多少列，不用写明有多少行</li>
</ul>

<h2 id="62-递归初步">6.2. 递归初步</h2>
<ul>
  <li>一个函数，自己调用自己，就是递归</li>
  <li>递归函数得有终止条件</li>
</ul>

<h2 id="63-库函数和头文件">6.3. 库函数和头文件</h2>
<ul>
  <li>头文件&lt;cmath&gt;中包含很多数学库函数的声明</li>
  <li>库函数的定义一般在.lib文件中</li>
  <li>库函数: C/C++标准规定, 编译器自带的函数</li>
  <li>头文件: C++编译器提供许多头文件, 比如: iostream、cmath、string</li>
  <li>头文件内部包含很多库函数的声明以及其他信息, 比如cin、cout的定义</li>
</ul>

<center><img src="assets/img/posts/20220225/19.jpg" /></center>

<center><img src="assets/img/posts/20220225/20.jpg" /></center>

<h2 id="64-位运算">6.4. 位运算</h2>
<ul>
  <li>位运算: 用于对整数类型变量中的某一位(bit)或者若干位进行操作</li>
  <li>C++提供了六种位运算符来进行位运算操作</li>
</ul>

<center><img src="assets/img/posts/20220225/21.jpg" /></center>

<h3 id="641-按位与">6.4.1. 按位与&amp;</h3>
<ul>
  <li>比如表达式(21 &amp; 18)的结果是16</li>
  <li>通常用来将某变量中的某些位清0且同时保留其他位不变</li>
</ul>

<h3 id="642-按位或">6.4.2. 按位或|</h3>
<ul>
  <li>比如“21|18”的结果是23</li>
  <li>按位或运算通常用来将某些变量中的某些位置1且保留其他位不变</li>
</ul>

<h3 id="643-按位异或">6.4.3. 按位异或^</h3>
<ul>
  <li>异或是逻辑运算, 如果两个值相同返回0, 如果两个值不同返回1</li>
  <li>异或运算通常用来将某变量中的某些位取反</li>
  <li>异或运算的特点:</li>
</ul>

<center><img src="assets/img/posts/20220225/22.jpg" /></center>

<h3 id="644-按位非">6.4.4. 按位非~</h3>
<ul>
  <li>按位非运算符~是单目运算符，其功能是将操作数中的二进制位0变成1，1变成0</li>
</ul>

<h3 id="645-左移运算符">6.4.5. 左移运算符«</h3>
<ul>
  <li>9 « 4 表示将9的二进制表示左移4位</li>
</ul>

<h3 id="646-右移运算符">6.4.6. 右移运算符»</h3>
<ul>
  <li>右移时，移出最右边的位就被丢弃</li>
  <li>对于有符号数，在右移时，符号位将一起移动，并且大多数C++编译器规定，如果圆符号位为1，则右移时高位就补充1，原符号位为0，则右移时高位就补充0</li>
</ul>

<h1 id="7-第七章-字符串">7. 第七章 字符串</h1>

<h2 id="71-字符串的形式和存储">7.1. 字符串的形式和存储</h2>
<ul>
  <li>字符串常量占据内存的字节数等于字符串中字符数目加1，多出来的是结尾字符’\0’</li>
  <li>空串”“也是合法的字符串常量</li>
  <li>包含’\0’字符的一维char数组，就是一个字符串，其中存放的字符串即为’\0’前面的字符组成</li>
  <li>可以给一维数组这么赋值: char title[] = “Prison Break”</li>
  <li>‘\0’可以视为字符数组结束标志</li>
</ul>

<h2 id="72-输入字符串">7.2. 输入字符串</h2>
<ul>
  <li>用scanf也可以将字符串读入字符数组</li>
  <li>scanf会自动添加结尾’\0’</li>
  <li>scanf读入到空格为止</li>
  <li>scanf(“%s”, line) 不用取地址符</li>
  <li>读入一行到字符串组: cin.getline(char buf[], int bufsize), 读入一行，自动添加’\0’, 回车换行符不会写入buf, 但是会从输入流中去掉</li>
  <li>也可以用gets(char buf[])来读入一行到字符数组，回车换行符不会写入buf，但是会从输入流中去掉，可能导致数组越界</li>
</ul>

<h2 id="73-字符串库函数">7.3. 字符串库函数</h2>
<ul>
  <li>使用字符串库函数需要 #include &lt;cstring&gt;</li>
  <li>形参为char []类型，则实参可以是char数组或字符串常量</li>
  <li>字符串拷贝 strcpy(char[] dest, char[] src) 拷贝src到dest</li>
  <li>字符串比较大小 int strcmp(char[] s1, char[] s2) 是根据字符的ASCII码值进行比较，大写字母比小写字母小</li>
  <li>求字符串长度 int strlen(char[] s)</li>
  <li>字符串拼接 strcat(char[] s1, char[] s2) 将s2拼接到s1后面</li>
  <li>字符串转成大写 strupr(char [])</li>
  <li>字符串转成小写 strlwr(char [])</li>
</ul>

<center><img src="assets/img/posts/20220225/23.jpg" /></center>

<h1 id="8-第八章-指针一">8. 第八章 指针(一)</h1>

<h2 id="81-指针的基本概念和用法">8.1. 指针的基本概念和用法</h2>
<ul>
  <li>指针也称作指针变量，大小为4个字节(或8个字节)的变量，其内容代表一个内存地址</li>
  <li>通过指针，能够对该指针指向的内存区域进行读写</li>
  <li>指针的定义: 类型名 * 指针变量名</li>
  <li>比如: int * p = (int *) 40000</li>
  <li>p指向地址40000，地址p就是地址40000</li>
  <li>* p就代表地址40000开始处的若干个字节的内容</li>
  <li>我们可以通过指针访问其指向的内存空间</li>
</ul>

<center><img src="assets/img/posts/20220225/24.jpg" /></center>

<ul>
  <li>指针定义总结</li>
</ul>

<center><img src="assets/img/posts/20220225/25.jpg" /></center>

<ul>
  <li>指针用法，一般是让指针指向一个变量的地址</li>
</ul>

<center><img src="assets/img/posts/20220225/26.jpg" /></center>

<h2 id="82-指针的意义和相互赋值">8.2. 指针的意义和相互赋值</h2>
<ul>
  <li>有了指针，就有了<strong>自由访问内存空间</strong>的手段</li>
  <li>不同类型的指针，如果不经过强制类型转换，不能直接互相赋值</li>
</ul>

<h2 id="83-指针的运算">8.3. 指针的运算</h2>
<ul>
  <li>两个同类型的指针变量，可以比较大小</li>
  <li>两个同类型的指针变量，可以相减</li>
</ul>

<center><img src="assets/img/posts/20220225/27.jpg" /></center>

<ul>
  <li>指针变量加减一个整数的结果是指针</li>
</ul>

<center><img src="assets/img/posts/20220225/28.jpg" /></center>

<ul>
  <li>指针变量可以自增自减</li>
  <li>指针可以用下标运算符[]进行运算</li>
</ul>

<center><img src="assets/img/posts/20220225/29.jpg" /></center>

<h2 id="84-指针作为函数参数">8.4. 指针作为函数参数</h2>
<ul>
  <li>地址0不能访问，指向地址0的指针就是空指针</li>
  <li>可以用NULL关键字对任何类型的指针进行赋值，NULL实际上就是整数0.值为NULL的指针就是空指针</li>
  <li>指针可以作为条件表达式使用，如果指针的值为NULL，则相当于为假，值不为NULL，就相当于为真</li>
</ul>

<h2 id="85-指针和数组">8.5. 指针和数组</h2>
<ul>
  <li>数组的名字是一个指针常量，指向数组的起始地址</li>
</ul>

<center><img src="assets/img/posts/20220225/30.jpg" /></center>

<ul>
  <li>作为函数形参时， T *p与 T p[] 等价</li>
</ul>

<h1 id="9-第九章-指针二">9. 第九章 指针(二)</h1>

<h2 id="91-指针和二维数组指向指针的指针">9.1. 指针和二维数组、指向指针的指针</h2>

<center><img src="assets/img/posts/20220225/31.jpg" /></center>

<ul>
  <li>二维数组的每一行都是一维数组，也就是指针</li>
  <li>指向指针的指针:</li>
</ul>

<center><img src="assets/img/posts/20220225/32.jpg" /></center>

<h2 id="92-指针和字符串">9.2. 指针和字符串</h2>
<ul>
  <li>字符串常量的类型就是char *</li>
  <li>字符数组名的类型也是char *</li>
</ul>

<h2 id="93-字符串库函数">9.3. 字符串库函数</h2>

<ul>
  <li>字符串操作库函数</li>
</ul>

<center><img src="assets/img/posts/20220225/33.jpg" /></center>

<center><img src="assets/img/posts/20220225/34.jpg" /></center>

<ul>
  <li>这些字符串操作库函数都需要include&lt;cstring&gt;</li>
</ul>

<h2 id="94-void指针和内存操作函数">9.4. void指针和内存操作函数</h2>
<ul>
  <li>void指针: void * p</li>
  <li>可以用任何类型的指针对void指针进行赋值或初始化</li>
  <li>对于void指针，*p没有定义，++p、–p，p += n、p+n、p-n均无定义</li>
  <li>内存操作库函数memset</li>
</ul>

<center><img src="assets/img/posts/20220225/35.jpg" /></center>

<ul>
  <li>内存操作库函数memcpy</li>
</ul>

<center><img src="assets/img/posts/20220225/36.jpg" /></center>

<h2 id="95-函数指针">9.5. 函数指针</h2>
<ul>
  <li>程序运行期间，每个函数都会占用一段连续的内存空间。而函数名就是该函数所占内存区域的起始地址(也称入口地址)</li>
  <li>我们可以将函数的入口地址赋给一个指针变量，使该指针变量指向该函数，然后通过指针变量就可以调用这个函数，这种指向函数的指针变量称为函数指针</li>
  <li>定义形式:</li>
</ul>

<center><img src="assets/img/posts/20220225/37.jpg" /></center>

<ul>
  <li>使用方法:</li>
</ul>

<center><img src="assets/img/posts/20220225/38.jpg" /></center>

<ul>
  <li>函数指针和qsort库函数</li>
</ul>

<center><img src="assets/img/posts/20220225/39.jpg" /></center>

<center><img src="assets/img/posts/20220225/40.jpg" /></center>

<ul>
  <li>pfcompare是比较函数</li>
</ul>

<h1 id="10-第十章-程序结构和简单算法">10. 第十章 程序结构和简单算法</h1>

<h2 id="101-结构">10.1. 结构</h2>
<ul>
  <li>在现实问题中，常常需要用一组不同类型的数据来描述一个事物</li>
  <li>C++允许程序员自己定义新的数据类型。因此针对“学生”这种事物，可以定义一种新名为Student的数据类型，一个student类型的变量就能描述一个学生的全部信息，同理，还可以定义数据类型worker来表示工人</li>
  <li>结构(struct): 用struct关键字来定义一个结构，也就定义了一个新的数据类型</li>
</ul>

<center><img src="assets/img/posts/20220225/41.jpg" /></center>

<ul>
  <li>student即成为自定义的类型的名字，可以用来定义变量</li>
  <li>两个同类型的结构变量，可以相互赋值，结构变量之间不能用比较运算符进行计算</li>
  <li>一般来说，一个结构变量所占的内存空间的大小就是结构中所有成员变量大小之和</li>
  <li>一个结构的成员变量可以是任何类型的，包括可以是另一个结构类型</li>
  <li>结构的成员变量可以是指向本结构类型的变量的指针</li>
</ul>

<center><img src="assets/img/posts/20220225/42.jpg" /></center>

<ul>
  <li>访问结构变量的成员变量: 一个结构变量的成员变量完全可以和一个普通变量一样来使用，也可以取得其地址</li>
  <li>结构变量名.成员变量名</li>
  <li>结构变量可以在定义时进行初始化:(使用花括号和逗号)</li>
</ul>

<center><img src="assets/img/posts/20220225/43.jpg" /></center>

<ul>
  <li>结构数组也可以定义，就是把结构体名字看作变量类型使用</li>
  <li>指向结构变量的指针，通过指针访问其指向的结构变量的成员变量</li>
</ul>

<center><img src="assets/img/posts/20220225/44.jpg" /></center>

<h2 id="102-全局变量局部变量静态变量">10.2. 全局变量、局部变量、静态变量</h2>
<ul>
  <li>定义在函数内部的变量叫<strong>局部变量</strong>(函数的形参也是局部变量)</li>
  <li>定义在所有函数的外面的变量叫做<strong>全局变量</strong></li>
  <li>全局变量在所有函数中均可以使用，局部变量只能在定义它的内部函数中使用</li>
  <li><strong>静态变量</strong>: 全局变量都是静态变量，局部变量定义时如果前面加了static关键字，则该变量也成为静态变量</li>
  <li>静态变量在整个程序运行期间都是固定不变的</li>
  <li>局部变量在函数每次调用时地址都可能不同</li>
  <li>如果未明确初始化，则静态变量会被自动初始化为全0，局部非静态变量的值则随机</li>
  <li>静态变量只初始化一次，也就是下次调用函数的时候不进行初始化</li>
</ul>

<h2 id="103-变量的作用域和生存周期">10.3. 变量的作用域和生存周期</h2>
<ul>
  <li>变量名、函数名、类型名统称为标识符</li>
  <li>一个标识符能够起作用的范围，叫做该标识符的作用域</li>
  <li>使用标识符的语句，必须出现在它们的声明或者定义之后</li>
  <li>在单文件的程序中，结构、函数和全局变量的作用域是其定义所在的整个文件</li>
  <li>函数的形参的作用域是整个函数</li>
  <li>局部变量的作用域，是从定义它的语句开始，到包含它的最内层的那一对大括号{}的右大括号为止</li>
  <li>for循环里定义的循环控制变量，其作用域是整个for循环</li>
  <li>同名标识符的作用域，可能一个被另一个包含，则在小的作用域里，作用域大的那个标识符被屏蔽，不起作用</li>
  <li>所谓变量的生存期，值的是在此期间，变量占有内存空间，其占有的内存空间只能归它使用，不会用来存放别的东西</li>
  <li>而变量的生存期终止，就意味着该变量不再占有内存空间，它原来占有的内存空间，随时可能被派作他用</li>
  <li>全局变量的生存期，从程序被装入内存开始，到整个程序结束</li>
  <li>静态局部变量的生存期，从定义它的语句第一次被执行开始，直到程序结束</li>
  <li>函数形参的生存期从函数执行开始，到函数返回时结束，非静态局部变量的生存期，从执行到定义它的语句开始，一旦程序执行了它的作用域之外，其生存期即告终止</li>
</ul>

<h2 id="104-选择排序和插入排序">10.4. 选择排序和插入排序</h2>

<h3 id="1041-选择排序">10.4.1. 选择排序</h3>
<ul>
  <li>排序问题: 编程接收键盘输入的若干个整数，排序后从小到大输出，先输入一个整数n，表明有n个整数需要排序，接下来再输入待排序的n个整数</li>
  <li>选择排序:</li>
</ul>

<center><img src="assets/img/posts/20220225/45.jpg" /></center>

<center><img src="assets/img/posts/20220225/46.jpg" /></center>

<ul>
  <li>选择最小的整数，与第i位的整数更换位置</li>
</ul>

<h3 id="1042-插入排序">10.4.2. 插入排序</h3>

<center><img src="assets/img/posts/20220225/47.jpg" /></center>

<center><img src="assets/img/posts/20220225/48.jpg" /></center>

<ul>
  <li>插入排序就是将数组分为有序和无序，每次让无序最左边的元素与有序分别比较，插入到合适的位置</li>
</ul>

<h2 id="105-冒泡排序">10.5. 冒泡排序</h2>

<center><img src="assets/img/posts/20220225/49.jpg" /></center>

<center><img src="assets/img/posts/20220225/50.jpg" /></center>

<ul>
  <li>冒泡排序同样是将数组分为有序和无序两组，无序在左边，有序在右边，每次将无序部分两两比较，较大的在右边</li>
  <li>上面三种简单排序算法，都要做$n^2$量级次数的比较，其中n是元素个数</li>
  <li>而比较好的排序算法，如快速排序，归并排序等，只需要做$n*log_2n$量级次数的比较</li>
</ul>

<h2 id="106-程序或算法的时间复杂度">10.6. 程序或算法的时间复杂度</h2>
<ul>
  <li>一个程序或算法的时间效率，也称为时间复杂度，有时简称复杂度</li>
  <li>复杂度常用大的字母O和小写字母n来表示，比如O(n), n代表问题的规模</li>
  <li>复杂度也有平均复杂度和最坏复杂度两种，两种可能一致，也可能不一致</li>
  <li>如果复杂度是多个n的函数之和，则只关心随n的增长增长得最快的那个函数</li>
</ul>

<center><img src="assets/img/posts/20220225/51.jpg" /></center>

<ul>
  <li>一些例子</li>
</ul>

<center><img src="assets/img/posts/20220225/52.jpg" /></center>

<h1 id="11-第十一章-文件读写">11. 第十一章 文件读写</h1>

<h2 id="111-文件读写概述">11.1. 文件读写概述</h2>
<ul>
  <li>二进制文件: 本质上所有文件都是0、1串，因此都是二进制文件。但是一般将内容不是文字，记事本打开看是乱码的文件，称为二进制文件</li>
  <li>文本文件: 内容是文字，用记事本打开能看到文字的文件</li>
  <li>文件读写相关函数在头文件cstdio中声明: #include &lt;cstdio&gt;</li>
  <li>fopen函数打开文件，返回FILE * 指针，指向和文件相关的一个FILE变量，FILE是一个struct</li>
  <li>文件读写结束后，一定要fclose关闭文件，否则可能导致数据没被保存，或者无法打开其他文件</li>
  <li>一些读写函数都需要FILE *指针进行</li>
</ul>

<center><img src="assets/img/posts/20220225/53.jpg" /></center>

<h3 id="1111-打开文件的函数">11.1.1. 打开文件的函数</h3>

<center><img src="assets/img/posts/20220225/54.jpg" /></center>

<ul>
  <li>打开文件的模式</li>
</ul>

<center><img src="assets/img/posts/20220225/55.jpg" /></center>

<ul>
  <li>二进制打开和文本打开的区别:</li>
</ul>

<center><img src="assets/img/posts/20220225/56.jpg" /></center>

<ul>
  <li>主要是二进制打开的话会有换行符的区别，最好还是用二进制打开</li>
</ul>

<center><img src="assets/img/posts/20220225/57.jpg" /></center>

<ul>
  <li>文件名的绝对路径和相对路径:</li>
</ul>

<center><img src="assets/img/posts/20220225/58.jpg" /></center>

<h2 id="112-文本文件读写">11.2. 文本文件读写</h2>

<h3 id="1121-文本文件读写">11.2.1. 文本文件读写</h3>

<center><img src="assets/img/posts/20220225/59.jpg" /></center>

<ul>
  <li>我们希望写一个文件读写程序:</li>
</ul>

<center><img src="assets/img/posts/20220225/60.jpg" /></center>

<h3 id="1121-文本文件读写另一种函数">11.2.1. 文本文件读写(另一种函数)</h3>
<ul>
  <li>fgets是读取一行</li>
</ul>

<center><img src="assets/img/posts/20220225/61.jpg" /></center>

<ul>
  <li>读取整个文本文件并输出</li>
</ul>

<center><img src="assets/img/posts/20220225/62.jpg" /></center>

<ul>
  <li>fputs是输出一行</li>
</ul>

<center><img src="assets/img/posts/20220225/63.jpg" /></center>

<h2 id="113-二进制文件读写概述">11.3. 二进制文件读写概述</h2>

<h3 id="1131-文件的读写指针">11.3.1. 文件的读写指针</h3>

<center><img src="assets/img/posts/20220225/64.jpg" /></center>

<ul>
  <li>这都是C语言读写的规则</li>
</ul>

<center><img src="assets/img/posts/20220225/65.jpg" /></center>

<ul>
  <li>fseek的作用是将读写指针定位到距离origin位置offset字节处</li>
</ul>

<h3 id="1132-二进制文件读写">11.3.2. 二进制文件读写</h3>
<ul>
  <li>用fread进行二进制读文件</li>
</ul>

<center><img src="assets/img/posts/20220225/66.jpg" /></center>

<ul>
  <li>用fgetc进行二进制读文件</li>
</ul>

<center><img src="assets/img/posts/20220225/67.jpg" /></center>

<ul>
  <li>
    <p>fgetc是用来读取一个字节</p>
  </li>
  <li>
    <p>用fwrite二进制写文件</p>
  </li>
</ul>

<center><img src="assets/img/posts/20220225/68.jpg" /></center>

<ul>
  <li>用fputc二进制写文件</li>
</ul>

<center><img src="assets/img/posts/20220225/69.jpg" /></center>

<h2 id="114-创建和读取二进制文件">11.4. 创建和读取二进制文件</h2>
<ul>
  <li>用二进制文件存学生信息比用文本方式存的好处: 可能节约空间、便于快速读取、改单个学生信息</li>
</ul>

<h2 id="115-修改二进制文件">11.5. 修改二进制文件</h2>
<ul>
  <li>用r+b打开文件既读又写时，如果做了读操作，则做写操作之前一定要用fssek重新定位文件读写指针</li>
</ul>

<h2 id="116-文件拷贝程序">11.6. 文件拷贝程序</h2>
<ul>
  <li>文件拷贝程序mycopy示例</li>
</ul>

<center><img src="assets/img/posts/20220225/70.jpg" /></center>

<center><img src="assets/img/posts/20220225/71.jpg" /></center>

<center><img src="assets/img/posts/20220225/72.jpg" /></center>

<h1 id="12-c的stl">12. C++的STL</h1>

<h2 id="121-stl排序算法sort">12.1. STL排序算法sort</h2>
<ul>
  <li>STL: standard template library 标准模板库</li>
  <li>包含一些常用的算法如排序查找，还有常用的数据结构如可变长数组、链表、字典等</li>
  <li>要使用其中的算法，需要#include &lt;algorithm&gt;</li>
  <li>用sort进行排序(用法一)</li>
</ul>

<center><img src="assets/img/posts/20220225/73.jpg" /></center>

<ul>
  <li>用sort进行排序(用法二)</li>
</ul>

<center><img src="assets/img/posts/20220225/74.jpg" /></center>

<ul>
  <li>用sort进行排序(用法三)，用自定义的排序规则对任何类型T的数组进行排序</li>
</ul>

<center><img src="assets/img/posts/20220225/75.jpg" /></center>

<ul>
  <li>几个自定义排序规则例子</li>
</ul>

<center><img src="assets/img/posts/20220225/76.jpg" /></center>

<center><img src="assets/img/posts/20220225/77.jpg" /></center>

<h2 id="122-stl二分查找算法">12.2. STL二分查找算法</h2>

<h3 id="1221-用binary_search进行二分查找">12.2.1. 用binary_search进行二分查找</h3>
<ul>
  <li>用法一:</li>
</ul>

<center><img src="assets/img/posts/20220225/78.jpg" /></center>

<ul>
  <li>用法二:</li>
</ul>

<center><img src="assets/img/posts/20220225/79.jpg" /></center>

<h3 id="1222-用lower_bound二分查找下界">12.2.2. 用lower_bound二分查找下界</h3>
<ul>
  <li>用法一:</li>
</ul>

<center><img src="assets/img/posts/20220225/80.jpg" /></center>

<ul>
  <li>用法二:</li>
</ul>

<center><img src="assets/img/posts/20220225/81.jpg" /></center>

<h3 id="1223-用upper_bound二分查找上界">12.2.3. 用upper_bound二分查找上界</h3>
<ul>
  <li>用法一:</li>
</ul>

<center><img src="assets/img/posts/20220225/82.jpg" /></center>

<ul>
  <li>用法二:</li>
</ul>

<center><img src="assets/img/posts/20220225/83.jpg" /></center>

<h2 id="123-multiset">12.3. multiset</h2>
<ul>
  <li>STL中的平衡二叉树数据结构</li>
  <li>有时需要在大量增加、删除数据的同时，还要进行大量数据的查找</li>
  <li>可以使用平衡二叉树数据结构存放数据，体现在STL中，就是以下四种排序容器: multiset、set、multimap、map</li>
  <li>multiset的用法:</li>
</ul>

<center><img src="assets/img/posts/20220225/84.jpg" /></center>

<ul>
  <li>multiset上的迭代器</li>
</ul>

<center><img src="assets/img/posts/20220225/85.jpg" /></center>

<center><img src="assets/img/posts/20220225/86.jpg" /></center>

<ul>
  <li>自定义排序规则的multiset用法:</li>
</ul>

<center><img src="assets/img/posts/20220225/87.jpg" /></center>

<center><img src="assets/img/posts/20220225/88.jpg" /></center>

<h2 id="124-set">12.4. set</h2>
<ul>
  <li>set和multiset的区别在于容器里面不能有重复元素</li>
  <li>set插入元素可能不成功</li>
  <li>pair模板的用法</li>
</ul>

<center><img src="assets/img/posts/20220225/89.jpg" /></center>

<ul>
  <li>set的例子</li>
</ul>

<center><img src="assets/img/posts/20220225/90.jpg" /></center>

<center><img src="assets/img/posts/20220225/91.jpg" /></center>

<h2 id="125-multimap">12.5. multimap</h2>
<ul>
  <li>multimap容器里面的元素，都是pair形式的</li>
</ul>

<center><img src="assets/img/posts/20220225/92.jpg" /></center>

<ul>
  <li>multimap的应用</li>
</ul>

<center><img src="assets/img/posts/20220225/93.jpg" /></center>

<ul>
  <li>代码实现细节</li>
</ul>

<center><img src="assets/img/posts/20220225/94.jpg" /></center>

<center><img src="assets/img/posts/20220225/95.jpg" /></center>

<center><img src="assets/img/posts/20220225/96.jpg" /></center>

<center><img src="assets/img/posts/20220225/97.jpg" /></center>

<h2 id="126-map">12.6. map</h2>
<ul>
  <li>map和multimap的区别: 不能有关键字重复的元素, 可以使用[], 下标为关键字, 返回值为first和关键字相同的元素的second</li>
  <li>插入元素可能失败</li>
</ul>]]></content><author><name>Quehry</name></author><category term="note" /><summary type="html"><![CDATA[网课记录]]></summary></entry></feed>