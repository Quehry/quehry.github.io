<!DOCTYPE html>
<html lang="en">
  




<head>
	<meta charset="utf-8">
	<title>机器学习 - Quehry</title>
	<link rel="canonical" href="http://localhost:4000/Machine-Learning.html">
	<meta name="description" content="《机器学习》周志华读书笔记">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:4000"},
  "headline": "机器学习",
  "abstract": "《机器学习》周志华读书笔记",
    "keywords": "note",
    "wordcount": "943",
    "image": ["http://localhost:4000/assets/imgposts/20211222/1.jpg"],
  "datePublished": "2021-12-22 00:00:00 +0800",
  "dateModified": "2021-12-22 00:00:00 +0800",
  "author": {
    "@type": "Person",
    "name": "Quehry"},
  "publisher": {
    "@type":  "Organization",
    "logo": {
        "@type": "ImageObject",
        "encodingFormat": "image/png",
        "contentUrl": "http://localhost:4000/assets/img/branding/MVM-symbol-black.png",
        "url": "http://localhost:4000/assets/img/branding/MVM-symbol-black.png"},
    "name" : "Quehry"}
}
</script>
<!-- Open Graph data -->
<meta property="og:url" content="http://localhost:4000/Machine-Learning.html"/>
<meta property="og:type" content="article"/>
<meta property="og:title" content="机器学习"/>
<meta property="og:description" content="《机器学习》周志华读书笔记"/>
<meta property="og:image" content="http://localhost:4000/assets/imgposts/20211222/1.jpg"/>
<meta property="og:image:alt" content="机器学习"/>
<meta property="og:site_name" content="Quehry" />
<meta property="article:published_time" content="2021-12-22 00:00:00 +0800" />
<meta property="article:modified_time" content="2021-12-22 00:00:00 +0800" />
<meta property="article:tag" content="note" />
<meta property="fb:admins" content="ar.maybach" />
<!-- Schema.org markup for Google -->
<meta itemprop="name" content="机器学习">
<meta itemprop="description" content="《机器学习》周志华读书笔记">
<meta itemprop="image" content="http://localhost:4000/assets/imgposts/20211222/1.jpg">
<!-- Twitter Card data -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@QuehryS">
<meta name="twitter:title" content="机器学习">
<meta name="twitter:description" content="《机器学习》周志华读书笔记">
<meta name="twitter:creator" content="">
<meta data-rh="true" name="twitter:label1" content="Word count"/>
<meta data-rh="true" name="twitter:data1" content="943"/>
<meta name="twitter:image:src" content="http://localhost:4000/assets/img/posts/20211222/1.jpg">
	<!-- Windows Phone -->
	<meta name="msapplication-navbutton-color" content="#311e3e">
	<!-- iOS Safari -->
	<meta name="apple-mobile-web-app-status-bar-style" content="#311e3e">
	<!-- Google Fonts -->
	<link rel="preconnect" href="https://fonts.gstatic.com" />
	<style>
/* latin */
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  src: url(https://fonts.gstatic.com/s/lora/v17/0QIvMX1D_JOuMwr7I_FMl_E.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 600;
  src: url(https://fonts.gstatic.com/s/lora/v17/0QIvMX1D_JOuMwr7I_FMl_E.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 200;
  src: url(https://fonts.gstatic.com/s/sourcesanspro/v14/6xKydSBYKcSV-LCoeQqfX1RYOo3i94_wlxdu3cOWxw.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 400;
  src: url(https://fonts.gstatic.com/s/sourcesanspro/v14/6xK3dSBYKcSV-LCoeQqfX1RYOo3qOK7lujVj9w.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 700;
  src: url(https://fonts.gstatic.com/s/sourcesanspro/v14/6xKydSBYKcSV-LCoeQqfX1RYOo3ig4vwlxdu3cOWxw.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
	</style>
	<!-- <link href="https://fonts.googleapis.com/css?family=Lora:400,600|Source+Sans+Pro:200,400,700" rel="stylesheet"> -->
	<!-- Font Awesome -->
	<link rel="stylesheet" href="./assets/fonts/font-awesome/css/font-awesome.min.css">
	<!-- Styles -->
	<link rel="stylesheet" href="./assets/css/main.css">
	




<link rel="icon" href="./assets/img/favicon/favicon.ico" type="image/x-icon">
<link rel="apple-touch-icon" href="./assets/img/favicon/favicon.ico">
<link rel="apple-touch-icon" sizes="72x72" href="./assets/img/favicon/favicon.ico">
<link rel="apple-touch-icon" sizes="114x114" href="./assets/img/favicon/favicon.ico">
	
<head>
  <body>
    




<section class="hidden">
  <div class="post">
      <a  class="post-list-title" href="./Machine-Learning.html">机器学习</a>
      

  <span class = "post-card-meta">
  
  
    <span class="meta-pre"></span>
  
  
    
      
      <span class="page_meta-date">
        <time datetime="2021-12-22T00:00:00+08:00">December 22, 2021</time>
      </span>
    
    
      <span class="meta-sep"></span>
    
  
  
    
    
    <span class="page_meta-readtime">
      
        4 minute read
      
    </span>
  
  
  </span>

        <div class="post-excerpt">
            <h1 id="目录">目录</h1><!-- TOC --><ul> <li><a href="#目录">目录</a></li> <li><a href="#1-第1章-绪论">1. 第1章 绪论</a></li> <li><a href="#2-第2章-模型评估与选择">2. 第2章 模型评估与选择</a> <ul> <li><a href="#21-思维导图">2.1. 思维导图</a></li> <li><a href="#22-经验误差与过拟合">2.2. 经验误差与过拟合</a></li> <li><a href="#23-评估方法">2.3. 评估方法</a> <ul> <li><a href="#231-留出法">2.3.1. 留出法</a></li> <li><a href="#232-交叉验证法">2.3.2. 交叉验证法</a></li> <li><a href="#233-自助法">2.3.3. 自助法</a></li> </ul> </li> <li><a href="#24-性能度量">2.4. 性能度量</a> <ul> <li><a href="#241-错误率与精度">2.4.1. 错误率与精度</a></li> <li><a href="#242-查准率查全率与f1">2.4.2. 查准率、查全率与F1</a></li> <li><a href="#243-roc与auc">2.4.3. ROC与AUC</a></li> <li><a href="#244-代价敏感错误率与代价曲线">2.4.4. 代价敏感错误率与代价曲线</a></li> </ul> </li> <li><a href="#25-比较检验">2.5. 比较检验</a> <ul> <li><a href="#251-假设检验">2.5.1. 假设检验</a></li> <li><a href="#252-交叉验证t检验">2.5.2. 交叉验证t检验</a></li> <li><a href="#253-mcnemar检验">2.5.3. McNemar检验</a></li> <li><a href="#254-friedman检验与nemenyi后续检验">2.5.4. Friedman检验与Nemenyi后续检验</a></li> </ul> </li> <li><a href="#26-偏差与方差">2.6. 偏差与方差</a></li> </ul> </li> <li><a href="#3-第3章-线性模型">3. 第3章 线性模型</a> <ul> <li><a href="#31-思维导图">3.1. 思维导图</a></li> <li><a href="#32-基本形式">3.2. 基本形式</a></li> <li><a href="#33-线性回归">3.3. 线性回归</a></li> <li><a href="#34-对数几率回归">3.4. 对数几率回归</a></li> <li><a href="#35-线性判别分析">3.5. 线性判别分析</a></li> <li><a href="#36-多分类学习">3.6. 多分类学习</a></li>...<a class="read-more" href="./Machine-Learning.html"> read more</a>
        </div>
  </div>
</section>
<div class="flex-container transparent">
  




<header class="main-header">
  <div class="wrapper">
    <div class="header-flex">
      <div class="menu-icon-container">
        <span class="menu-icon"><i class="fa fa-bars" aria-hidden="true"></i></span>
      </div>
      <nav class="main-nav">
        <span class="menu-icon-close"><i class="fa fa-times" aria-hidden="true"></i></span>
        <ul>
          <li>
            <div class="theme-toggle night">
    <input class="night" type="checkbox" id="theme-switch">
    <label class="night" for="theme-switch">
        <div class="toggle night"></div>
        <div class="names night">             
        <p class="light night"><svg class="night" width="20" viewBox="0 0 25 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path class="night" d="M12.5 2.49871C11.3401 2.50016 10.2282 2.96156 9.40801 3.78171C8.58785 4.60187 8.12645 5.71383 8.125 6.87371C8.125 7.03947 8.19085 7.19844 8.30806 7.31565C8.42527 7.43286 8.58424 7.49871 8.75 7.49871C8.91576 7.49871 9.07473 7.43286 9.19194 7.31565C9.30915 7.19844 9.375 7.03947 9.375 6.87371C9.37593 6.04519 9.70547 5.25088 10.2913 4.66503C10.8772 4.07918 11.6715 3.74964 12.5 3.74871C12.6658 3.74871 12.8247 3.68286 12.9419 3.56565C13.0592 3.44844 13.125 3.28947 13.125 3.12371C13.125 2.95795 13.0592 2.79898 12.9419 2.68177C12.8247 2.56456 12.6658 2.49871 12.5 2.49871V2.49871ZM12.5 -0.00129131C8.47891 -0.00129131 5.62031 3.26238 5.625 6.88269C5.62487 8.54403 6.22974 10.1486 7.32656 11.3964C8.32891 12.5378 9.29062 14.4007 9.375 14.9987L9.37734 17.9358C9.37744 18.0587 9.41402 18.1787 9.48242 18.2807L10.4395 19.7198C10.4964 19.8055 10.5737 19.8758 10.6644 19.9245C10.7551 19.9731 10.8564 19.9986 10.9594 19.9987H14.0395C14.1426 19.9988 14.2441 19.9734 14.3351 19.9247C14.426 19.8761 14.5034 19.8057 14.5605 19.7198L15.5176 18.28C15.5854 18.1776 15.6219 18.0578 15.6227 17.935L15.625 14.9987C15.7129 14.3846 16.6797 12.5303 17.6734 11.3964C18.5434 10.4028 19.1087 9.17963 19.3015 7.87318C19.4944 6.56673 19.3066 5.23238 18.7608 4.02985C18.215 2.82732 17.3342 1.80757 16.2238 1.09264C15.1135 0.377721 13.8206 -0.00207746 12.5 -0.00129131V-0.00129131ZM14.3727 17.7452L13.7047 18.7487H11.2937L10.6273 17.7452V17.4987H14.3738L14.3727 17.7452ZM14.375 16.2487H10.625L10.6227 14.9987H14.375V16.2487ZM16.7348 10.5725C16.1879 11.1956 15.316 12.4511 14.7594 13.7479H10.243C9.68516 12.4507 8.81328 11.1956 8.26641 10.5725C7.36971 9.5491 6.87599 8.2344 6.87734 6.87371C6.87031 3.8659 9.23594 1.24871 12.5 1.24871C15.602 1.24871 18.125 3.77176 18.125 6.87371C18.1249 8.23456 17.6305 9.54904 16.7336 10.5725H16.7348ZM3.75 6.87371C3.75 6.70795 3.68415 6.54898 3.56694 6.43177C3.44973 6.31456 3.29076 6.24871 3.125 6.24871H0.625C0.45924 6.24871 0.300269 6.31456 0.183058 6.43177C0.065848 6.54898 0 6.70795 0 6.87371C0 7.03947 0.065848 7.19844 0.183058 7.31565C0.300269 7.43286 0.45924 7.49871 0.625 7.49871H3.125C3.29076 7.49871 3.44973 7.43286 3.56694 7.31565C3.68415 7.19844 3.75 7.03947 3.75 6.87371ZM20.625 2.49871C20.7221 2.49849 20.8178 2.4759 20.9047 2.43269L23.4047 1.18269C23.5529 1.10852 23.6657 0.978483 23.718 0.821201C23.7704 0.66392 23.7582 0.492273 23.684 0.344021C23.6473 0.270614 23.5964 0.205161 23.5344 0.151397C23.4724 0.0976336 23.4004 0.0566132 23.3225 0.0306781C23.1652 -0.0217002 22.9936 -0.00945342 22.8453 0.0647243L20.3453 1.31472C20.2194 1.37771 20.1184 1.48136 20.0588 1.60889C19.9991 1.73643 19.9843 1.88037 20.0166 2.0174C20.049 2.15442 20.1267 2.2765 20.2371 2.36386C20.3475 2.45122 20.4842 2.49873 20.625 2.49871ZM24.375 6.24871H21.875C21.7092 6.24871 21.5503 6.31456 21.4331 6.43177C21.3158 6.54898 21.25 6.70795 21.25 6.87371C21.25 7.03947 21.3158 7.19844 21.4331 7.31565C21.5503 7.43286 21.7092 7.49871 21.875 7.49871H24.375C24.5408 7.49871 24.6997 7.43286 24.8169 7.31565C24.9342 7.19844 25 7.03947 25 6.87371C25 6.70795 24.9342 6.54898 24.8169 6.43177C24.6997 6.31456 24.5408 6.24871 24.375 6.24871ZM4.65469 1.31472L2.15469 0.0647243C2.08128 0.0279952 2.00136 0.00608435 1.91948 0.00024269C1.83761 -0.00559897 1.75539 0.004743 1.67751 0.0306781C1.52023 0.0830564 1.39019 0.195769 1.31602 0.344021C1.24184 0.492273 1.22959 0.66392 1.28197 0.821201C1.33435 0.978483 1.44706 1.10852 1.59531 1.18269L4.09531 2.43269C4.18223 2.4759 4.27794 2.49849 4.375 2.49871C4.5158 2.49873 4.65248 2.45122 4.7629 2.36386C4.87332 2.2765 4.951 2.15442 4.98337 2.0174C5.01574 1.88037 5.0009 1.73643 4.94124 1.60889C4.88158 1.48136 4.78061 1.37771 4.65469 1.31472ZM23.4047 12.5647L20.9047 11.3147C20.7564 11.2405 20.5847 11.2283 20.4274 11.2807C20.2701 11.3332 20.14 11.4459 20.0658 11.5942C19.9916 11.7425 19.9794 11.9142 20.0318 12.0715C20.0842 12.2289 20.197 12.3589 20.3453 12.4331L22.8453 13.6831C22.9936 13.7573 23.1653 13.7695 23.3226 13.7171C23.4799 13.6647 23.61 13.5519 23.6842 13.4036C23.7584 13.2553 23.7706 13.0836 23.7182 12.9263C23.6658 12.769 23.553 12.6389 23.4047 12.5647V12.5647ZM4.375 11.2487C4.27794 11.2489 4.18223 11.2715 4.09531 11.3147L1.59531 12.5647C1.44701 12.6389 1.33425 12.769 1.28183 12.9263C1.25588 13.0042 1.24552 13.0864 1.25135 13.1683C1.25719 13.2502 1.27909 13.3302 1.31582 13.4036C1.35255 13.477 1.40338 13.5425 1.46542 13.5963C1.52745 13.6501 1.59947 13.6911 1.67737 13.7171C1.83469 13.7695 2.00638 13.7573 2.15469 13.6831L4.65469 12.4331C4.78083 12.3702 4.88202 12.2666 4.94183 12.1389C5.00164 12.0113 5.01656 11.8672 4.98417 11.7301C4.95178 11.5929 4.87397 11.4707 4.76339 11.3833C4.65281 11.2959 4.51594 11.2485 4.375 11.2487V11.2487Z" /></svg></p>
        <p class="dark night"><svg class="night" width="20" viewBox="0 0 25 21" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path class="night" d="M6.39614 3.72646C7.50591 1.56178 9.72622 0.00900831 12.4782 0.00114817C13.8006 -0.00388798 15.0965 0.375153 16.2101 1.09278C17.3237 1.8104 18.2079 2.83612 18.7564 4.04682C19.3049 5.25751 19.4945 6.60175 19.3024 7.91818C19.1103 9.23461 18.5447 10.4673 17.6735 11.4683C17.5227 11.6416 17.3516 11.859 17.1739 12.1069L9.47856 6.12184C9.65443 5.45016 10.046 4.85578 10.5924 4.43118C11.1387 4.00657 11.8093 3.77554 12.4997 3.77401C12.6654 3.77401 12.8244 3.70776 12.9416 3.58984C13.0588 3.47191 13.1247 3.31197 13.1247 3.1452C13.1247 2.97843 13.0588 2.81849 12.9416 2.70057C12.8244 2.58264 12.6654 2.51639 12.4997 2.51639C11.6212 2.5173 10.7634 2.78383 10.0374 3.28141C9.31146 3.77899 8.75092 4.48463 8.42856 5.30674L6.39614 3.72646ZM6.39614 10.0841C6.64968 10.5817 6.96225 11.0465 7.327 11.4683C7.97231 12.2091 8.98169 13.7568 9.36645 15.0624C9.36645 15.0726 9.36919 15.0828 9.37075 15.093H12.8372L6.39614 10.0841ZM9.37466 16.3502V17.8574C9.37584 18.1045 9.44934 18.3458 9.58599 18.5511L10.2536 19.5607C10.3675 19.7335 10.5221 19.8753 10.7037 19.9734C10.8852 20.0715 11.0881 20.1229 11.2942 20.1231H13.7047C13.9107 20.1231 14.1135 20.0718 14.2951 19.9739C14.4766 19.876 14.6313 19.7345 14.7454 19.5619L15.4129 18.5511C15.5492 18.3451 15.622 18.1033 15.6223 17.8558V17.2581L14.4528 16.3502H9.37466Z"/>
            <path class="night" d="M0.131556 1.2363L0.898352 0.243172C0.948738 0.177883 1.01142 0.123229 1.08282 0.0823368C1.15423 0.0414448 1.23294 0.0151171 1.31446 0.00486006C1.39598 -0.00539702 1.47872 0.000617709 1.55793 0.0225602C1.63714 0.0445026 1.71127 0.0819422 1.77609 0.132737L24.7585 18.0039C24.8894 18.1062 24.9745 18.2567 24.9952 18.4221C25.0158 18.5876 24.9703 18.7545 24.8687 18.8862L24.1015 19.8794C24.0511 19.9446 23.9884 19.9992 23.917 20.0401C23.8457 20.0809 23.767 20.1072 23.6855 20.1175C23.6041 20.1277 23.5214 20.1217 23.4422 20.0998C23.363 20.0779 23.2889 20.0405 23.2241 19.9898L0.241322 2.1186C0.110489 2.01624 0.0254259 1.86578 0.00484145 1.70032C-0.015743 1.53486 0.0298368 1.36795 0.131556 1.2363V1.2363Z"/>
            </svg></p>
        </div>
    </label>
</div>
          </li>
          <li>
            <a href="./">
              <div class="left">
                Home
              </div>  
              <div class="right">
                <svg width="24px" aria-hidden="true" focusable="false" role="img" fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><g><rect x="83.534" y="40.929" width="3.997" height="20.071"/></g><path d="M16.466,41.931l33.548-25.123L92.81,48.877l2.396-3.198L50.015,11.814L4.794,45.679l2.396,3.199l5.279-3.954v42.763h75.062  V61h-3.997v22.69H64.598V54.068H35.402V83.69H16.466V41.931z M39.399,58.065h21.202V83.69H39.399V58.065z"/></svg>
              </div>
            </a>
          </li>
          <li>
            <a href="./archive.html">
              <div class="left">
                All Posts
              </div>
              <div class="right">
                <svg width="24px" aria-hidden="true" focusable="false" role="img" fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="-3 3 64 64"><g><path d="M60.992,31.985c0-15.979-13-28.978-28.979-28.978c-15.994,0-29.006,12.999-29.006,28.978   c0,15.994,13.012,29.007,29.006,29.007v-2c-14.891,0-27.006-12.115-27.006-27.007c0-14.875,12.115-26.978,27.006-26.978   c14.876,0,26.979,12.103,26.979,26.978c0,8.945-4.479,17.329-11.804,22.338l0.874-10.062l-1.992-0.174l-1.135,13.071l13.042,1.136   l0.174-1.992l-9.183-0.799C56.443,50.079,60.992,41.321,60.992,31.985z"/><polygon points="33.014,12.682 31.014,12.682 31.014,32.398 39.811,41.224 41.227,39.812 33.014,31.572  "/></g></svg>
              </div>
            </a>
          </li>
          <li>
            <a href="./tags.html">
              <div class="left">
                Tags
              </div>
              <div class="right">
                <svg width="24px" aria-hidden="true" focusable="false" role="img" fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><g><path d="M75.244,15.066c-2.59,0-5.027,1.012-6.857,2.843c-3.781,3.785-3.778,9.94,0.002,13.724    c1.831,1.833,4.266,2.843,6.857,2.843s5.026-1.01,6.861-2.843c3.781-3.785,3.781-9.943-0.002-13.724    C80.275,16.076,77.838,15.066,75.244,15.066z M78.766,28.252c-1.871,1.869-5.129,1.869-6.996,0c-1.929-1.931-1.931-5.069-0.002-7    c0.934-0.934,2.175-1.448,3.498-1.448c1.322,0,2.564,0.515,3.5,1.448C80.691,23.183,80.691,26.321,78.766,28.252z M94.632,41.027    l0.005-28.872c0-3.745-3.05-6.792-6.792-6.792L58.973,5.368l-1.237-0.004c-1.893,0-4.75,0-6.617,1.869L7.008,51.342    c-1.06,1.059-1.645,2.467-1.645,3.966s0.583,2.908,1.644,3.968l33.717,33.717c1.058,1.06,2.467,1.645,3.966,1.645    s2.908-0.585,3.968-1.645l44.106-44.111c1.893-1.886,1.88-4.604,1.869-7.227L94.632,41.027z M90.022,46.139L45.913,90.25    c-0.654,0.65-1.792,0.652-2.443,0L9.752,56.532c-0.328-0.327-0.507-0.762-0.507-1.225c0-0.462,0.18-0.894,0.507-1.221    L53.861,9.976c0.676-0.674,2.284-0.731,3.874-0.731l1.237,0.004l28.872-0.004c1.604,0,2.909,1.306,2.909,2.911l-0.005,28.872    l0.005,0.642C90.76,43.585,90.769,45.392,90.022,46.139z"/></g></svg>
              </div>
            </a>
          </li>
          <li>
            <a href="./about.html">
              <div class="left">
                About
              </div>
              <div class="right">
                <svg width='24px' aria-hidden="true" focusable="false" role="img" fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 846.66 846.66"><g><path d="M351.26 453.22c-276.42,134.06 -224.86,336.22 -224.73,336.8 6.03,25.41 -32.58,34.56 -38.6,9.15 -0.15,-0.65 -55.78,-219.32 218.87,-367.66 -60.98,-39 -100.02,-106.82 -100.02,-182.56 0,-119.6 96.95,-216.55 216.55,-216.55 119.6,0 216.55,96.95 216.55,216.55 0,75.74 -39.04,143.56 -100.02,182.56 274.65,148.34 219.02,367.01 218.87,367.66 -6.02,25.41 -44.63,16.26 -38.6,-9.15 0.13,-0.58 51.69,-202.74 -224.73,-336.8 -22.55,7.96 -46.8,12.29 -72.07,12.29 -25.27,0 -49.52,-4.33 -72.07,-12.29zm72.07 -381.14c-97.68,0 -176.87,79.19 -176.87,176.87 0,97.69 79.19,176.87 176.87,176.87 97.68,0 176.87,-79.18 176.87,-176.87 0,-97.68 -79.19,-176.87 -176.87,-176.87z"/></g></svg>
              </div>
            </a>
          </li>
          <li>
            <a href="./feed.xml">
              <div class="left">
                Atom feed
              </div>
              <div class="right">
                <svg width='24px' aria-hidden="true" focusable="false" role="img" fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M80 352c26.467 0 48 21.533 48 48s-21.533 48-48 48-48-21.533-48-48 21.533-48 48-48m0-32c-44.183 0-80 35.817-80 80s35.817 80 80 80 80-35.817 80-80-35.817-80-80-80zm367.996 147.615c-6.448-237.848-198.06-429.164-435.61-435.61C5.609 31.821 0 37.229 0 44.007v8.006c0 6.482 5.146 11.816 11.626 11.994 220.81 6.05 398.319 183.913 404.367 404.367.178 6.48 5.512 11.626 11.994 11.626h8.007c6.778 0 12.185-5.609 12.002-12.385zm-144.245-.05c-6.347-158.132-133.207-284.97-291.316-291.316C5.643 175.976 0 181.45 0 188.247v8.005c0 6.459 5.114 11.72 11.567 11.989 141.134 5.891 254.301 119.079 260.192 260.192.269 6.453 5.531 11.567 11.989 11.567h8.005c6.798 0 12.271-5.643 11.998-12.435z"></path></svg>
              </div>
            </a>
          </li>
        </ul>
      </nav>
      
      
      <div class="logo"><a href="./"><img class="logo" id="logo" src="./assets/img/branding/MVM-logo-full.svg" alt="Quehry"></a></div>
      <div class="search-icon-container">
        <span class="search-icon"><a><i class="fa fa-search" aria-hidden="true"></i></a></span>
      </div>
    </div>
  </div>
</header> <!-- End Header -->

  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="机器学习">
<meta itemprop="description" content="《机器学习》周志华读书笔记">
<meta itemprop="datePublished" content="2021-12-22T00:00:00+08:00">

    <div class="page-image">
      <div class="cover-image" style="background: url('./assets/img/posts/20211222/1.jpg') center no-repeat; background-size: cover;"></div>
    </div>
    <div class="wrapper">
      <div class="page-content">
        <div class="header-page">
          <h1 class="page-title">机器学习</h1>
          

  <span class = "post-page-meta">
  
    <p class="page_meta">
  
  
  
    
      
      <span class="page_meta-date">
        <time datetime="2021-12-22T00:00:00+08:00">December 22, 2021</time>
      </span>
    
    
      <span class="meta-sep"></span>
    
  
  
    
    
    <span class="page_meta-readtime">
      
        4 minute read
      
    </span>
  
  
    </p>
  
  </span>

        </div>
        <aside class="sidebar side" id="sidebar">
    



<div class="tag-cloud">
    
        <ul class="tags side">
            
                <li><a href="./tag.html?tag=note" class="tag side">note</a></li>
            
    
        </ul>
</div>
    <div class="share-options side">
    <div class="share-hover side">
        <span class="share-button side"><svg fill="currentColor" width="25" height="25" class="side"><g fill-rule="evenodd"><path d="M15.6 5a.42.42 0 0 0 .17-.3.42.42 0 0 0-.12-.33l-2.8-2.79a.5.5 0 0 0-.7 0l-2.8 2.8a.4.4 0 0 0-.1.32c0 .12.07.23.16.3h.02a.45.45 0 0 0 .57-.04l2-2V10c0 .28.23.5.5.5s.5-.22.5-.5V2.93l2.02 2.02c.08.07.18.12.3.13.11.01.21-.02.3-.08v.01"></path><path d="M18 7h-1.5a.5.5 0 0 0 0 1h1.6c.5 0 .9.4.9.9v10.2c0 .5-.4.9-.9.9H6.9a.9.9 0 0 1-.9-.9V8.9c0-.5.4-.9.9-.9h1.6a.5.5 0 0 0 .35-.15A.5.5 0 0 0 9 7.5a.5.5 0 0 0-.15-.35A.5.5 0 0 0 8.5 7H7a2 2 0 0 0-2 2v10c0 1.1.9 2 2 2h11a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2"></path></g></svg></span>
        <div class="share-icons side" id="sidebar-icons">
            <a class="twitter" href="https://twitter.com/intent/tweet?text=机器学习&url=http://localhost:4000/Machine-Learning.html" title="Share on Twitter" rel="nofollow" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a>
            <a class="facebook" href="https://facebook.com/sharer.php?u=http://localhost:4000/Machine-Learning.html" title="Share on Facebook" rel="nofollow" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i></a>
            <a class="reddit" href="http://www.reddit.com/submit?url=http://localhost:4000/Machine-Learning.html&title=机器学习" title="Submit to Reddit" rel="nofollow" target="_blank"><i class="fa fa-reddit" aria-hidden="true"></i></a>
            <a class="linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/Machine-Learning.html&title=机器学习&summary=《机器学习》周志华读书笔记&source=http://localhost:4000/Machine-Learning.html" title="Share on LinkedIn" rel="nofollow" target="_blank"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
            <a class="email" href="mailto:?subject=机器学习&body=《机器学习》周志华读书笔记%0A%0ARead more here: http://localhost:4000/Machine-Learning.html" title="Share via e-mail" rel="nofollow" target="_blank"><i class="fa fa-envelope" aria-hidden="true"></i></a>
            <a class="copy-link" onclick="copyToClipboard()" title="Copy to clipboard" rel="nofollow" target="_blank"><svg width="20px" fill="currentColor" class="side" viewBox="0 0 18 18"><path d="M16.94 1.1A3.7 3.7 0 0 0 14.3 0c-1 0-1.94.39-2.64 1.1L7.43 5.3c-.91.92-2.09 3.2 0 5.27a.75.75 0 0 0 .82.16c.09-.03.17-.09.24-.15a.74.74 0 0 0 0-1.06c-1.16-1.15-.77-2.39-.02-3.16l4.24-4.22a2.2 2.2 0 0 1 1.58-.65c.6 0 1.16.23 1.58.65.86.87.86 2.29 0 3.16L12.7 8.47a.74.74 0 0 0 1.04 1.05l3.17-3.16a3.73 3.73 0 0 0 0-5.27h.03zM9.54 7.4a.74.74 0 0 0 0 1.06c1.16 1.15.76 2.39 0 3.16l-4.22 4.22c-.42.42-.99.65-1.59.65a2.23 2.23 0 0 1-1.58-3.82l3.17-3.16A.73.73 0 0 0 5.54 9a.78.78 0 0 0-.22-.52.77.77 0 0 0-1.05 0L1.1 11.64A3.72 3.72 0 0 0 3.74 18c1 0 1.94-.39 2.65-1.1l4.23-4.2c.21-.22.94-1.02 1.13-2.2.18-1.12-.2-2.15-1.12-3.07-.27-.27-.78-.27-1.06 0l-.02-.02z" clip-rule="evenodd" fill-rule="evenodd"></path></svg></a>
        </div>
    </div>
    <div class='alert' style='font-size:.6em;color:var(--accent);text-align:center;'></div>
</div>
</aside>

        
        
        <h1 id="目录">目录</h1>

<!-- TOC -->

<ul>
  <li><a href="#目录">目录</a></li>
  <li><a href="#1-第1章-绪论">1. 第1章 绪论</a></li>
  <li><a href="#2-第2章-模型评估与选择">2. 第2章 模型评估与选择</a>
    <ul>
      <li><a href="#21-思维导图">2.1. 思维导图</a></li>
      <li><a href="#22-经验误差与过拟合">2.2. 经验误差与过拟合</a></li>
      <li><a href="#23-评估方法">2.3. 评估方法</a>
        <ul>
          <li><a href="#231-留出法">2.3.1. 留出法</a></li>
          <li><a href="#232-交叉验证法">2.3.2. 交叉验证法</a></li>
          <li><a href="#233-自助法">2.3.3. 自助法</a></li>
        </ul>
      </li>
      <li><a href="#24-性能度量">2.4. 性能度量</a>
        <ul>
          <li><a href="#241-错误率与精度">2.4.1. 错误率与精度</a></li>
          <li><a href="#242-查准率查全率与f1">2.4.2. 查准率、查全率与F1</a></li>
          <li><a href="#243-roc与auc">2.4.3. ROC与AUC</a></li>
          <li><a href="#244-代价敏感错误率与代价曲线">2.4.4. 代价敏感错误率与代价曲线</a></li>
        </ul>
      </li>
      <li><a href="#25-比较检验">2.5. 比较检验</a>
        <ul>
          <li><a href="#251-假设检验">2.5.1. 假设检验</a></li>
          <li><a href="#252-交叉验证t检验">2.5.2. 交叉验证t检验</a></li>
          <li><a href="#253-mcnemar检验">2.5.3. McNemar检验</a></li>
          <li><a href="#254-friedman检验与nemenyi后续检验">2.5.4. Friedman检验与Nemenyi后续检验</a></li>
        </ul>
      </li>
      <li><a href="#26-偏差与方差">2.6. 偏差与方差</a></li>
    </ul>
  </li>
  <li><a href="#3-第3章-线性模型">3. 第3章 线性模型</a>
    <ul>
      <li><a href="#31-思维导图">3.1. 思维导图</a></li>
      <li><a href="#32-基本形式">3.2. 基本形式</a></li>
      <li><a href="#33-线性回归">3.3. 线性回归</a></li>
      <li><a href="#34-对数几率回归">3.4. 对数几率回归</a></li>
      <li><a href="#35-线性判别分析">3.5. 线性判别分析</a></li>
      <li><a href="#36-多分类学习">3.6. 多分类学习</a></li>
      <li><a href="#37-类别不平衡问题">3.7. 类别不平衡问题</a></li>
    </ul>
  </li>
  <li><a href="#4-第4章-决策树">4. 第4章 决策树</a>
    <ul>
      <li><a href="#41-思维导图">4.1. 思维导图</a>
        <ul>
          <li><a href="#411-章节导图">4.1.1. 章节导图</a></li>
          <li><a href="#412-如何生成一棵决策树">4.1.2. 如何生成一棵决策树</a></li>
        </ul>
      </li>
      <li><a href="#42-基本流程">4.2. 基本流程</a></li>
      <li><a href="#43-划分选择">4.3. 划分选择</a>
        <ul>
          <li><a href="#431-信息增益">4.3.1. 信息增益</a></li>
          <li><a href="#432-增益率">4.3.2. 增益率</a></li>
          <li><a href="#433-基尼指数">4.3.3. 基尼指数</a></li>
        </ul>
      </li>
      <li><a href="#44-剪枝处理">4.4. 剪枝处理</a>
        <ul>
          <li><a href="#441-预剪枝">4.4.1. 预剪枝</a></li>
          <li><a href="#442-后剪枝">4.4.2. 后剪枝</a></li>
        </ul>
      </li>
      <li><a href="#45-连续与缺失值">4.5. 连续与缺失值</a>
        <ul>
          <li><a href="#451-连续值处理">4.5.1. 连续值处理</a></li>
          <li><a href="#452-缺失值处理">4.5.2. 缺失值处理</a></li>
        </ul>
      </li>
      <li><a href="#46-多变量决策树">4.6. 多变量决策树</a></li>
      <li><a href="#47-阅读材料">4.7. 阅读材料</a></li>
    </ul>
  </li>
  <li><a href="#5-第5章-神经网络">5. 第5章 神经网络</a>
    <ul>
      <li><a href="#50-思维导图">5.0. 思维导图</a></li>
      <li><a href="#51-神经元模型">5.1. 神经元模型</a></li>
      <li><a href="#52-感知机与多层网络">5.2. 感知机与多层网络</a></li>
      <li><a href="#53-误差逆传播算法">5.3. 误差逆传播算法</a></li>
      <li><a href="#54-全局最小与局部极小">5.4. 全局最小与局部极小</a></li>
      <li><a href="#55-其他常见神经网络">5.5. 其他常见神经网络</a>
        <ul>
          <li><a href="#551-rbf网络">5.5.1. RBF网络</a></li>
          <li><a href="#552-art网络">5.5.2. ART网络</a></li>
          <li><a href="#553-som网络">5.5.3. SOM网络</a></li>
          <li><a href="#554-级联相关网络">5.5.4. 级联相关网络</a></li>
          <li><a href="#555-elman网络">5.5.5. Elman网络</a></li>
          <li><a href="#556-boltzmann机">5.5.6. Boltzmann机</a></li>
        </ul>
      </li>
      <li><a href="#56-深度学习">5.6. 深度学习</a></li>
    </ul>
  </li>
  <li><a href="#6-第6章-支持向量机">6. 第6章 支持向量机</a>
    <ul>
      <li><a href="#60-思维导图">6.0. 思维导图</a></li>
      <li><a href="#61-间隔与支持向量">6.1. 间隔与支持向量</a></li>
      <li><a href="#62-对偶问题">6.2. 对偶问题</a></li>
      <li><a href="#63-核函数">6.3. 核函数</a></li>
      <li><a href="#64-软间隔与正则化">6.4. 软间隔与正则化</a></li>
      <li><a href="#65-支持向量回归">6.5. 支持向量回归</a></li>
      <li><a href="#66-核方法">6.6. 核方法</a></li>
    </ul>
  </li>
  <li><a href="#7-第7章-贝叶斯分类器">7. 第7章 贝叶斯分类器</a>
    <ul>
      <li><a href="#70-思维导图">7.0. 思维导图</a></li>
      <li><a href="#71-贝叶斯决策论">7.1. 贝叶斯决策论</a></li>
      <li><a href="#72-极大似然估计">7.2. 极大似然估计</a></li>
      <li><a href="#73-朴素贝叶斯分类器">7.3. 朴素贝叶斯分类器</a></li>
      <li><a href="#74-半朴素贝叶斯分类器">7.4. 半朴素贝叶斯分类器</a></li>
      <li><a href="#75-贝叶斯网">7.5. 贝叶斯网</a>
        <ul>
          <li><a href="#751-结构">7.5.1. 结构</a></li>
          <li><a href="#752-学习">7.5.2. 学习</a></li>
          <li><a href="#753-推断">7.5.3. 推断</a></li>
        </ul>
      </li>
      <li><a href="#76-em算法">7.6. EM算法</a></li>
    </ul>
  </li>
</ul>

<!-- /TOC -->

<h1 id="1-第1章-绪论">1. 第1章 绪论</h1>

<h1 id="2-第2章-模型评估与选择">2. 第2章 模型评估与选择</h1>

<h2 id="21-思维导图">2.1. 思维导图</h2>

<center><img src="../assets/img/posts/20211222/16.jpg" /></center>

<h2 id="22-经验误差与过拟合">2.2. 经验误差与过拟合</h2>
<p><strong>定义：</strong></p>
<ul>
  <li><strong>错误率(error rate)</strong>: 如果m个样本中有a个样本分类错误，则错误率E=a/m。</li>
  <li><strong>精度(accuracy)</strong>：精度=1-错误率。</li>
  <li><strong>训练误差</strong>：学习器在训练集上的误差称为训练误差或者经验误差。</li>
  <li><strong>泛化误差(generalization error)</strong>：学习器在新样本上的误差称为泛化误差。</li>
  <li><strong>过拟合(overfitting)</strong>：当学习器把训练样本学得太好了的时候，很可能把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，这就会导致泛化性能下降。</li>
  <li><strong>欠拟合(underfitting)</strong>：对训练样本的一般性质尚未学好。</li>
</ul>

<h2 id="23-评估方法">2.3. 评估方法</h2>
<p>通常我们可通过实验测试来对学习器的泛化误差进行评估而做出选择，于是我们需要一个<strong>测试集(testing set)</strong>，然后以测试集上的测试误差作为泛化误差的近似。下面介绍一些常见的处理数据集D的方法(数据集D-&gt;训练集S+测试集T)<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<h3 id="231-留出法">2.3.1. 留出法</h3>
<ul>
  <li>留出发(hold-out)直接将数据集D划分为两个互斥的集合，其中一个集合作为训练集S，另一个作为测试集T。在S上训练出模型后，用T来评估其测试误差。</li>
  <li>以采样的角度来看待数据集划分的过程，则保留类别比例的采样方式通常称为<strong>分层采样</strong>。比如1000个样本，50%的正例，50%负例，以7：3划分数据集，那么训练集包含350个正例和350个负例就是分层采样。</li>
  <li>在使用留出法评估结果时，一般要采用若干次随即划分、重复进行实验评估后取平均值作为留出法的评估结果。</li>
  <li>常用做法时将大约2/3~4/5的样本用于训练。</li>
</ul>

<h3 id="232-交叉验证法">2.3.2. 交叉验证法</h3>
<ul>
  <li><strong>交叉验证法(cross validation)</strong>先将数据集D划分为k个大小相似的互斥子集，每个子集D<sub>i</sub>都尽可能保持数据分布的一致性。然后每次用k-1个自己的并集作为训练集，余下的那个子集作为测试集，这样就可以获得k组训练/测试集，从而可进行k次训练和测试，最终返回的是这k个测试结果的均值。</li>
  <li>交叉验证也称为k折交叉验证。k的常见取值有10、5、20。</li>
  <li><strong>留一法</strong>就是k=m，其中数据集D有m个样本。</li>
</ul>

<h3 id="233-自助法">2.3.3. 自助法</h3>
<ul>
  <li><strong>自助法(bootstrapping)</strong>：给定包含m个样本的数据集D，每次随机从D中挑选一个样本，将其拷贝放入D’, 然后再将该样本放回最初的数据集D中，这个过程重复执行m次后，我们获得了包含m个样本的数据集D’。我们将D’作为训练集，D\D’作为测试集。</li>
  <li>不难发现大概有36.8%(m趋于无限大时)的样本在m次采样中始终不被采到。</li>
</ul>

<center>$\lim\limits_{m\rightarrow\infty}(1-\frac{1}{m})^m = \frac{1}{e} ≈ 0.368$</center>

<ul>
  <li>缺点：自助法产生的数据集改变了初始数据集的分布，这样会引入估计偏差。因此，在初始数据量足够时，留出法和交叉验证法更常用一些。</li>
</ul>

<h2 id="24-性能度量">2.4. 性能度量</h2>
<ul>
  <li>对学习器的泛化性能进行评估，不仅需要有效可行的实验估计方法，还需要有衡量模型泛化能力的评价标准，这就是<strong>性能度量(performance measure)</strong>。</li>
  <li>在预测任务中，给定D = {(x<sub>1</sub>,y<sub>1</sub>), (x<sub>2</sub>,y<sub>2</sub>)…(x<sub>m</sub>,y<sub>m</sub>)}, 其中y<sub>i</sub>是x<sub>i</sub>的真实标记。学习器f。</li>
  <li><strong>均方误差(mean squared error)</strong>：回归任务最常用的性能度量是均方误差：</li>
</ul>

<center>$E(f;D)=\frac{1}{m}\sum_1^m(f(x_i)-y_i)^2$</center>

<p>接下来我将介绍<strong>分类任务</strong>中常用的性能度量</p>

<h3 id="241-错误率与精度">2.4.1. 错误率与精度</h3>
<p>本章开头提到了错误率和精度，这是分类任务中最常用的两种性能度量，既适用于二分类任务，也适用于多分类任务。</p>

<h3 id="242-查准率查全率与f1">2.4.2. 查准率、查全率与F1</h3>

<ul>
  <li>针对二分类问题，可将样例根据其真实类别与学习器预测类别的组合划分为真正例(true positive)、假正例(false positive)、真反例(true negative)、假反例(false negative)，分别记为TP、FP、TN、FN。</li>
  <li>混淆矩阵(confusion matrix)</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>真\预</td>
      <td>正例</td>
      <td>反例</td>
    </tr>
    <tr>
      <td>正例</td>
      <td>TP</td>
      <td>FN</td>
    </tr>
    <tr>
      <td>反例</td>
      <td>FP</td>
      <td>TN</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>查准率(precision)，记为P，它表示选择的好瓜中有多少是真正的好瓜</li>
</ul>

<center>$P=\frac{TP}{TP+FP}$</center>

<ul>
  <li>查全率(recall)，记为R，它表示好瓜中有多少被选出来了</li>
</ul>

<center>$R=\frac{TP}{TP+FN}$</center>

<ul>
  <li>
    <p>一般来说，查准率高时，查全率往往偏低；而查全率高时，查准率往往偏低。</p>
  </li>
  <li>
    <p>P-R曲线：在很多情形下，我们可根据学习器的预测结果对样例进行排序，排在前面的是学习器认为最可能是正例的样本，排在最后的则是学习器认为最不可能是正例的样本，按此顺序逐个把样本作为正例进行预测，则每次可以计算出当前的查全率、查准率，也得到了P-R图。</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/2.jpg" /></center>

<ul>
  <li>
    <p>如果一个学习器的P-R曲线被另一个学习器的曲线完全包住，则可断言后者的性能优于前者。如果两者曲线相交，则可以通过比较平衡点(break-even-point)来比较，越大越好。</p>
  </li>
  <li>
    <p>F1度量：F1综合考虑了查准率和查全率，是他们的调和平均</p>
  </li>
</ul>

<center>$F1=\frac{2*P*R}{P+R}$</center>

<ul>
  <li>F1的一般形式：有时候我们希望赋予查准率和查重率不同的权重：</li>
</ul>

<center>$F_\beta=\frac{(1+\beta^2)*P*R}{\beta^2*P+R}$</center>

<p>其中β大于1表示查全率有更大影响</p>

<ul>
  <li>
    <p>有时候我们有多个二分类混淆矩阵，我们希望在这n个混淆矩阵上综合考虑查准率和查全率，那么我们有以下的度量</p>
  </li>
  <li>
    <p>宏查准率macro-P，宏查全率macro-R，宏F1：</p>
  </li>
</ul>

<center>$macro-P=\frac{1}{n}\sum_1^nP_i$</center>

<center>$macro-R=\frac{1}{n}\sum_1^nR_i$</center>

<ul>
  <li>微查准率micro-P，微查全率micro-P，微F1：</li>
</ul>

<p>对TP、FP、TN、FN进行平均</p>

<center>$micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FP}}$</center>

<center>$micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FN}}$</center>

<h3 id="243-roc与auc">2.4.3. ROC与AUC</h3>
<ul>
  <li>
    <p>很多学习器是为测试样本产生一个实值或概率预测，然后将这个预测值与一个分类阈值进行比较，若大于阈值则分为正类，否则为反类。</p>
  </li>
  <li>
    <p>ROC曲线是从排序角度来出发研究学习器的泛化性能的工具。ROC的全称是Receiver Operating Characteristic。</p>
  </li>
  <li>
    <p>与P-R曲线类似，我们根据学习器的预测结果进行排序，按此顺序逐个把样本作为正例进行预测，计算出真正例率TPR(true positive rate)与假正例率FPR(false positive rate)并以它们分别为横纵坐标画出ROC曲线</p>
  </li>
</ul>

<center>$TPR=\frac{TP}{TP+FN}$</center>

<center>$FPR=\frac{FP}{FP+TN}$</center>

<center><img src="../assets/img/posts/20211222/3.jpg" /></center>

<ul>
  <li>
    <p>同样的，如果一个学习器的ROC曲线被另一个学习器完全包住，则认为后者的性能优于前者。若两个曲线相交，则比较曲线下的面积AUC(area under curve)</p>
  </li>
  <li>
    <p>形式化的看，AUC考虑的是样本预测的排序质量，那么我们可以定义一个排序损失l<sub>rank</sub></p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/4.jpg" /></center>

<center>AUC=1-l<sub>rank</sub></center>

<h3 id="244-代价敏感错误率与代价曲线">2.4.4. 代价敏感错误率与代价曲线</h3>
<ul>
  <li>有时候将正例误判断为负例与将负例误判断为正例所带来的后果不一样，我们赋予它们非均等代价</li>
  <li>代价矩阵(cost matrix)</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>真\预</td>
      <td>第0类</td>
      <td>第1类</td>
    </tr>
    <tr>
      <td>第0类</td>
      <td>0</td>
      <td>cost<sub>01</sub></td>
    </tr>
    <tr>
      <td>第1类</td>
      <td>cost<sub>10</sub></td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>其中cost<sub>ij</sub>表示将第i类样本预测为第j类样本的代价</p>

<ul>
  <li>代价敏感错误率</li>
</ul>

<center><img src="../assets/img/posts/20211222/5.jpg" /></center>

<ul>
  <li>在非均等代价下，ROC曲线不能直接反映出学习器的期望总代价，而代价曲线则可达到此目的，横轴是正例概率代价，纵轴是归一化代价</li>
</ul>

<center><img src="../assets/img/posts/20211222/6.jpg" /></center>

<p> </p>

<center><img src="../assets/img/posts/20211222/7.jpg" /></center>

<p> </p>

<center><img src="../assets/img/posts/20211222/8.jpg" /></center>

<h2 id="25-比较检验">2.5. 比较检验</h2>
<p>我们有了实验评估方法与性能度量，是否就可以对学习器的性能进行评估比较了呢？实际上，机器学习中性能比较这件事比大家想象的要复杂很多，我们需要考虑多种因素的影响，下面介绍一些对学习器性能进行比较的方法，本小节默认以错误率作为性能度量。(但我觉得似乎同一个数据集下就可以比较)</p>

<h3 id="251-假设检验">2.5.1. 假设检验</h3>
<ul>
  <li>假设检验中的假设是对学习器泛化错误率分布的某种猜想或者判断，例如“ε=ε<sub>0</sub>”这样的假设</li>
  <li>现实任务中我们并不知道学习器的泛化错误率，我们只能获知其测试错误率$\hat{\epsilon}$，但直观上，两者接近的可能性比较大，因此可根据测试错误率估推出泛化错误率的分布。</li>
  <li>泛化错误率为$\epsilon$的学习器被测得测试错误率为$\hat{\epsilon}$的概率：</li>
</ul>

<center><img src="../assets/img/posts/20211222/9.jpg" /></center>

<ul>
  <li>我们发现$\epsilon$符合二项分布</li>
</ul>

<center><img src="../assets/img/posts/20211222/10.jpg" /></center>

<ul>
  <li>
    <p>二项检验：我们可以使用<strong>二项检验(binomial test)</strong>来对“$\epsilon$&lt;0.3”这样的假设进行检验，即在$\alpha$显著度下，$1-\alpha$置信度下判断假设是否成立。</p>
  </li>
  <li>
    <p>t检验：我们也可以用t检验(t-test)来检验。</p>
  </li>
  <li>
    <p>上面介绍的都是针对单个学习器泛化性能的假设进行检验</p>
  </li>
</ul>

<h3 id="252-交叉验证t检验">2.5.2. 交叉验证t检验</h3>

<ul>
  <li>
    <p>对于两个学习器A和B，若我们使用k折交叉验证法得到的测试错误率分别是$\epsilon_1^A$, $\epsilon_2^A$…$\epsilon_k^A$和$\epsilon_1^B$, $\epsilon_2^B$…$\epsilon_k^B$。其中$\epsilon_i^A$和$\epsilon_i^B$是在相同第i折训练集上得到的结果。则可以用k折交叉验证“成对t检验”来进行比较检验。</p>
  </li>
  <li>
    <p>我们这里的基本思想是若两个学习器的性能相同，则它们使用相同的训练测试集得到的错误率应该相同，即$\epsilon_i^A=\epsilon_1^B$</p>
  </li>
  <li>
    <p>$\Delta_i$ = $\epsilon_i^A$ - $\epsilon_i^B$，然后对$\Delta$进行分析</p>
  </li>
</ul>

<h3 id="253-mcnemar检验">2.5.3. McNemar检验</h3>
<ul>
  <li>对于二分类问题，使用留出法不仅可以估计出学习器A和B的测试错误率，还可获得两学习器分类结果的差别，即两者都正确、都错误…的样本数</li>
</ul>

<center><img src="../assets/img/posts/20211222/11.jpg" /></center>

<ul>
  <li>若我们假设两学习器性能相同，则应有e<sub>01</sub>=e<sub>10</sub>，那么变量|e<sub>01</sub>-e<sub>10</sub>|应该服从正态分布/卡方分布，然后用McNemar检验</li>
</ul>

<h3 id="254-friedman检验与nemenyi后续检验">2.5.4. Friedman检验与Nemenyi后续检验</h3>

<ul>
  <li>
    <p>交叉验证t检验与McNemar检验都是在一个数据集上比较两个算法的性能，但是很多时候，我们会在一组数据集上比较多个算法。</p>
  </li>
  <li>
    <p>当有多个算法参与比较时，一种做法是在每个数据集上本别列出两两比较的结果。另一种方法则是基于算法排列的<strong>Friedman检验</strong></p>
  </li>
  <li>
    <p>假定我们用D<sub>1</sub>, D<sub>2</sub>, D<sub>3</sub>, D<sub>4</sub>四个数据集对算法A、B、C进行比较。首先，使用留出法或交叉验证法得到每个算法在每个数据集上的测试结果。然后在每个数据集上根据测试性能由好到坏排序，并赋予序值1,2,…若算法的测试性能相同，则平分序值。</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/12.jpg" /></center>

<ul>
  <li>
    <p>然后使用Fredman检验来判断这些算法是否性能都相同，若相同，那么它们的平均序值应当相同。r<sub>i</sub>表示第i个算法的平均序值，那么它的均值和方差应该满足…</p>
  </li>
  <li>
    <p>若“所有算法的性能相同”这个假设被拒绝，则说明算法的性能显著不同，这时需要后续检验(post-hoc test)来进一步区分各算法，常用的有Nemenyi后续检验</p>
  </li>
  <li>
    <p>Nemenyi检验计算出平均序值差别的临界值域</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/13.jpg" /></center>

<ul>
  <li>在表中找到k=3时q<sub>0.05</sub>=2.344，根据公式计算出临界值域CD=1.657，由表中的平均序值可知A与B算法的差距，以及算法B与C的差距均未超过临界值域，而算法A与C的差距超过临界值域，因此检验结果认为算法A与C的性能显著不同，而算法A与B以及算法B与C的性能没有显著差别。</li>
</ul>

<center><img src="../assets/img/posts/20211222/14.jpg" /></center>

<h2 id="26-偏差与方差">2.6. 偏差与方差</h2>

<ul>
  <li>
    <p>对学习算法除了通过实验估计其泛化性能，人们往往还希望了解它“为什么”具有这样的性能。偏差-方差分解是解释学习算法泛化性能的一种重要工具</p>
  </li>
  <li><strong>偏差</strong>度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力</li>
  <li><strong>方差</strong>度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响</li>
  <li>
    <p><strong>噪声</strong>则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度</p>
  </li>
  <li>一般来说，偏差与方差是有冲突的，也就是偏差大的方差小，偏差小的方差大</li>
</ul>

<center><img src="../assets/img/posts/20211222/15.jpg" /></center>

<h1 id="3-第3章-线性模型">3. 第3章 线性模型</h1>
<h2 id="31-思维导图">3.1. 思维导图</h2>

<center><img src="../assets/img/posts/20211222/42.jpg" /></center>

<h2 id="32-基本形式">3.2. 基本形式</h2>

<ul>
  <li>
    <p>给定由d个属性描述的示例$x=(x_1;x_2;…x_d)$，这是一个列向量，其中$x_i$是$x$在第i个属性上的取值。</p>
  </li>
  <li>
    <p><strong>线性模型(linear model)</strong>试图学得一个通过属性线性组合来进行预测的函数：</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/17.jpg" /></center>

<ul>
  <li>向量形式：</li>
</ul>

<center>$f(x)=\omega^Tx+b$</center>

<p>其中$\omega=(\omega_1;\omega_2…\omega_d)$</p>

<ul>
  <li>
    <p>当$\omega$和b学得后，模型就得以确定</p>
  </li>
  <li>
    <p>线性模型的优点：形式简单，易于建模，良好的可解释性(comprehensibility)</p>
  </li>
</ul>

<h2 id="33-线性回归">3.3. 线性回归</h2>
<ul>
  <li>
    <p>对离散属性的处理，若属性值存在“序”的关系，可通过连续化将其转化为连续值，比如高、矮变成1、0；2.若不存在序的关系，可转化为k维向量。</p>
  </li>
  <li>
    <p>均方误差是回归任务中最常用的性能度量，试图让均方误差最小化：</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/18.jpg" /></center>

<ul>
  <li>
    <p>均方误差有非常好的几何意义，它对应了欧氏距离。基于均方误差最小化来进行模型求解的方法称为<strong>最小二乘法(least square method)</strong>。在线性回归中，最小二乘法就是试图找到一条直线，使得样本到直线上的欧氏距离之和最小</p>
  </li>
  <li>
    <p>首先观察一个属性值的情况。求解$\omega$和$b$使得均方误差最小化的过程，称为线性回归的最小二乘“参数估计”，我们令均方误差分别对$\omega$和$b$求导令其为零，可以得到最优解的<strong>闭式解(closed-form)</strong>,即解析解</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/19.jpg" /></center>

<p> </p>

<center><img src="../assets/img/posts/20211222/20.jpg" /></center>

<ul>
  <li>更一般的情况是d个属性，称其为“多元线性回归”，同样的步骤，只是$\omega$变成向量形式，自变量写成m*(d+1)的矩阵形式，m对应了m个样本，d+1对应了d个属性和偏置。同样的求导为0然后得出$\hat{\omega}$最优解的闭式解，其中$\hat{\omega}=(\omega;b)$。当$X^TX$为满秩矩阵<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>或正定矩阵时，有唯一的解：</li>
</ul>

<center><img src="../assets/img/posts/20211222/21.jpg" /></center>

<p> </p>

<center><img src="../assets/img/posts/20211222/22.jpg" /></center>

<p> </p>

<center><img src="../assets/img/posts/20211222/23.jpg" /></center>

<p> </p>

<center><img src="../assets/img/posts/20211222/24.jpg" /></center>

<p> </p>

<center><img src="../assets/img/posts/20211222/25.jpg" /></center>

<ul>
  <li>
    <p>然而现实任务中往往不是满秩矩阵，例如在许多任务中我们会遇到大量的变量其数目甚至超过样例数。那么我们会求出$\hat{\omega}=(\omega;b)$的多个解，它们都能使均方误差最小化。选择哪一个解作为输出与学习算法的归纳偏好决定，常见的做法是<strong>引入正则化(regularization)</strong></p>
  </li>
  <li>
    <p><strong>广义线性模型(generalized linear model)</strong>:</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/26.jpg" /></center>

<center>$g(y)=\omega^Tx+b$</center>

<p>其中g()单调可微，被称为联系函数。比如当g()=ln()时称为对数线性回归</p>

<h2 id="34-对数几率回归">3.4. 对数几率回归</h2>
<ul>
  <li>
    <p>上一节讨论的是线性回归进行回归学习。那么如果我们要做的是分类任务应该怎么改变？我们只需要找到一个单调可微函数将分类任务的真实标记y与线性回归模型的预测值联系起来。</p>
  </li>
  <li>
    <p>考虑二分类问题，那么我们可以用单位阶跃函数/Heaviside函数联系y与z，其中y是真是标记，z是预测值，$z=\omega^Tx+b$</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/27.jpg" /></center>

<ul>
  <li>
    <p>但是它有个问题就是不连续，所以我们希望找到能在一定程度上近似它的替代函数。</p>
  </li>
  <li>
    <p><strong>对数几率函数(logistic function)</strong>就是一个替代函数：</p>
  </li>
</ul>

<center>$y=\frac{1}{1+e^{-z}}$</center>

<center><img src="../assets/img/posts/20211222/28.jpg" /></center>

<ul>
  <li>那么这个式子可以转化为：可以把y视为样本x作为正例的可能性，则1-y是其反例的可能性，两者的比值称为几率(odds)：</li>
</ul>

<center><img src="../assets/img/posts/20211222/29.jpg" /></center>

<ul>
  <li>若将y视为类后验概率估计。则式子可以重写为：</li>
</ul>

<center><img src="../assets/img/posts/20211222/30.jpg" /></center>

<ul>
  <li>接下来我们可以通过<strong>极大似然法(maximum likelihood method)</strong>来估计$\omega$和$b$。给定数据集，对数似然函数<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>为：</li>
</ul>

<center><img src="../assets/img/posts/20211222/31.jpg" /></center>

<p>即每个样本属于其真实标记的概率越大越好。</p>

<ul>
  <li>推导过程：</li>
</ul>

<center><img src="../assets/img/posts/20211222/32.jpg" /></center>

<p>上面有个式子应该有问题，(3.26)应该是</p>

<center>$p(y_i|x_i;\omega,b) = p_1(\hat{x_i};\beta)^{y_i}p_0(\hat{x_i};\beta)^{1-y_i}$</center>

<p>因为$\beta$是高阶可导连续凸函数，根据凸优化理论，经典的数值优化算法如<strong>梯度下降法(gradient descent method)</strong>和牛顿法都可以求得最优解</p>

<h2 id="35-线性判别分析">3.5. 线性判别分析</h2>

<ul>
  <li>
    <p>线性判别分析(Linear Discriminant Analysis，简称LDA)是一种经典的线性学习方法。</p>
  </li>
  <li>
    <p>LDA的思想非常朴素: 给定训练样例集，设法将样例投影到一条直线上，使得同类样例的投影点尽可能接近、异类样例的投影点尽可能远离;在对新样本进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定样本的类别。</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/33.jpg" /></center>

<ul>
  <li>令$X_i$、$\mu_i$、$\Sigma_i$分别表示第i类示例的集合、均值向量<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>、协方差矩阵<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>。</li>
</ul>

<ul>
  <li>欲使同类样例的投影点尽可能接近，可以让同类样例投影点的协方差尽可能小，即$\omega^T\Sigma_0\omega+\omega^T\Sigma_1\omega$尽可能小;而欲使异类样例的投影点尽可能远离，可以让类中心之间的距离尽可能大，即$||\omega^T\mu_0-\omega^T\mu_1||$尽可能大:</li>
</ul>

<center><img src="../assets/img/posts/20211222/34.jpg" /></center>

<ul>
  <li>剩余推导过程：</li>
</ul>

<center><img src="../assets/img/posts/20211222/35.jpg" /></center>

<p> </p>

<center><img src="../assets/img/posts/20211222/36.jpg" /></center>

<ul>
  <li>值得一提的是，LDA可从贝时斯决策理论的角度来阐释，并可证明，当两类数据同先验、满足高斯分布且协方差相等时，LDA可达到最优分类。</li>
</ul>

<h2 id="36-多分类学习">3.6. 多分类学习</h2>
<ul>
  <li>
    <p>现实中常遇到多分类学习任务，有些二分类学习方法可直接推广到多分类，但在更多情形下，我们是基于一些基本策略，利用二分类学习器来解决多分类问题。</p>
  </li>
  <li>
    <p>不失一般性，考虑N个类别$C_1$、$C_2$…$C_N$，多分类学习的基本思路是”<strong>拆解法</strong>”，即将多分类任务拆为若干个二分类任务求解。具体来说，先对问题进行拆分，然后为拆出的每个二分类任务训练一个分类器;在测试时，对这些分类器的预测结果进行集成以获得最终的多分类结果。</p>
  </li>
  <li>
    <p>这里我们着重介绍如何拆分，最经典的拆分策略有三种：一对一(One vs One)、一对其余(One vs Rest)、多对多(Many vs Many)</p>
  </li>
  <li>
    <p>一对一：将这N个类别两两配对，从而产生 N(N-1)/2个二分类任务。在测试阶段，新样本将同时提交给所有分类器，于是我们将得到N(N-1)/2个分类结果，最终结果可通过投票产生:即把被预测得最
多的类别作为最终分类结果。</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/37.jpg" /></center>

<ul>
  <li>一对其余：OvR则是每次将一个类的样例作为正例，所有其他类的样例作为反例来训练N个分类器。在测试时若仅有一个分类器预测为正类，则对应的类别标记作为最终分类结果。若有多个分类器预测为正类，则通常考虑各分类器的预测置信度，选择置信度最大的类别标记作为分类结果。</li>
</ul>

<center><img src="../assets/img/posts/20211222/38.jpg" /></center>

<ul>
  <li>
    <p>多对多MvM是每次将若干个类作为正类，若干个其他类作为反类。这里我们介绍一种最常用的MvM技术：<strong>纠错输出码(ECOC)</strong></p>
  </li>
  <li>
    <p>ECOC是将编码的思想引入类别拆分，主要分为两步：</p>
  </li>
</ul>

<p>  1.编码： 对N个类别做M次划分，每次划分将一部分类别划为正类，一部分划为反类，从而形成一个二分类训练集;这样一共产生M个训练集，可训练出M个分类器</p>

<p>  2.解码：:M个分类器分别对测试样本进行预测，这些预测标记组成一个编码.将这个预测编码与每个类别各自的编码进行比较，返回其中距离最小的类别作为最终预测结果。</p>

<ul>
  <li>类别划分通过<strong>编码矩阵</strong>指定。编码矩阵有多种形式，常见的有二元码和三元码，前者将每个类别分别指定为正类和反类，后者在正、反类之外，还可指定“停用类”</li>
</ul>

<center><img src="../assets/img/posts/20211222/39.jpg" /></center>

<h2 id="37-类别不平衡问题">3.7. 类别不平衡问题</h2>

<ul>
  <li>
    <p>前面介绍的分类学习方法都有一个共同的基本假设：即不同类别的训练样例数目相当。如果不同类别的样例数差别很大，会对学习过程造成困扰。</p>
  </li>
  <li>
    <p><strong>类别不平衡(class-imbalance)</strong>就是指分类任务中不同类别的训练样例数目差别很大的情况。</p>
  </li>
  <li>
    <p><strong>再缩放(rescaling)</strong>是类别不平衡中的一个基本策略：比如在最简单的二分类问题中，我们假设y大于0.5为正例，y小于0.5为负例，但是在类别不平衡时，我们可以改变阈值来达到再平衡：</p>
  </li>
</ul>

<p>  将</p>

<center><img src="../assets/img/posts/20211222/40.jpg" /></center>

<p>  变成</p>

<center><img src="../assets/img/posts/20211222/41.jpg" /></center>

<ul>
  <li>现有的解决类别不平衡的技术大体上有三类做法(这里我们均假设正例样本少):</li>
</ul>

<p>  1.第一类是直接对训练集里的反类样例进行”欠采样” (undersampling)，即去除一些反例使得正、反例数日接近，然后再进行学习;</p>

<p>  2.第二类是对训练集里的正类样例进行”过采样” (oversampling)，即增加一些正例使得正、反例数目接近，然后再进行学习;</p>

<p>  3.第三类则是直接基于原始训练集进行学习，但在用训练好的分类器进行预测时，将上面的公式(改变阈值)嵌入到其决策过程中，称为”阔值移动” (threshold-moving)</p>

<ul>
  <li>需注意的是，过采样法不能简单地对初始正例样本进行重复来样，否则会招致严重的过拟合；过采样法的代表性算法SMOTE是通过对训练集里的正例进行插值来产生额外的正例.另一方面，欠采样法若随机丢弃反例可能丢失一些重要信息;欠采样法的代表性算法EasyEnsemble则是利用集成学习机制，将反例划分为若干个集合供不同学习器使用，这样对每个学习器来看都进行了欠采样，但在全局来看却不会丢失重要信息。</li>
</ul>

<h1 id="4-第4章-决策树">4. 第4章 决策树</h1>
<h2 id="41-思维导图">4.1. 思维导图</h2>
<h3 id="411-章节导图">4.1.1. 章节导图</h3>

<center><img src="../assets/img/posts/20211222/61.jpg" /></center>

<h3 id="412-如何生成一棵决策树">4.1.2. 如何生成一棵决策树</h3>

<center><img src="../assets/img/posts/20211222/62.jpg" /></center>

<h2 id="42-基本流程">4.2. 基本流程</h2>
<ul>
  <li>决策树是基于树结构来进行决策，其中包含一个根结点，多个内部结点和多个叶结点</li>
  <li>叶结点对应决策结果，其他每个结点都对应一个属性测试</li>
  <li>每个结点包含的样本集合根据属性测试被划分到子结点中，那么根结点包含样本全集</li>
  <li>决策树学习的目的是为了产生一棵泛化能力强的决策树</li>
  <li>决策树的生成是一个递归过程，下面这张图展示了递归的过程：</li>
</ul>

<center><img src="../assets/img/posts/20211222/43.jpg" /></center>

<p>对于每个结点，首先判断该结点的样本集是否属于同一个类别C，如果是，则将该结点标记为C类叶结点。再判断该结点的样本集的属性值是否完全相同(或者是否为空集)，如果是，则将该结点标记为D类叶结点，其中D类是这些样本中最多的类别。如果该结点即不是<strong>同属于一个类别</strong>也不是<strong>属性值取值相同</strong>，那么则需要继续划分，选择一个最优的划分属性$a_*$,创建新的分支，对于每个分支结点首先判断是否为空，如果为空则判定为E类叶结点，其中E类是父结点中类别最多的类。如果子结点不为空则递归。</p>

<h2 id="43-划分选择">4.3. 划分选择</h2>
<p>可以发现生成决策树最关键的步骤就是选择最优划分属性，我们希望决策树的分支结点所包含的样本尽可能属于同一类别，即结点的<strong>纯度</strong>越来越高。我们有很多指标来确定选择哪一个属性作为最优划分选择，下面将分别介绍：</p>

<h3 id="431-信息增益">4.3.1. 信息增益</h3>
<ul>
  <li><strong>信息熵(information entropy)</strong>是度量样本集合纯度最常用的一种指标。下面是信息熵的定义公式：</li>
</ul>

<center><img src="../assets/img/posts/20211222/44.jpg" /></center>

<p>  其中$p_k$表示第k类样本在样本集D中所占比例，信息熵越小表示D的纯度越高。</p>

<ul>
  <li>假设离散属性a有V个可能的取值${a^1,a^2…a^V}$,那么我们可以计算出在使用a作为划分属性前后的信息熵差别，也就是<strong>信息增益(information gain)</strong>：</li>
</ul>

<center><img src="../assets/img/posts/20211222/45.jpg" /></center>

<p>  对每一个子结点$D^v$都赋予权重同时相加。</p>

<ul>
  <li>
    <p>著名的ID3决策树学习算法就是以信息增益作为准则来选择划分属性，我们希望找到信息增益最大的属性。</p>
  </li>
  <li>
    <p>书上使用信息增益划分的例子：</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/46.jpg" /></center>

<h3 id="432-增益率">4.3.2. 增益率</h3>
<ul>
  <li>
    <p>信息增益对可取值数目较多的属性有所偏好，比如我们使用编号这一属性来划分，每一个编号都只有一个样本，那么信息增益肯定增大了，但是决策树的泛化能力显然下降了。</p>
  </li>
  <li>
    <p><strong>增益率(gain ratio)</strong>，我们通过对信息增益除以IV来平衡属性数目带来的影响，增益率的定义如下：</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/47.jpg" /></center>

<p>  IV(intrinsic value)的定义如下：</p>

<center><img src="../assets/img/posts/20211222/48.jpg" /></center>

<p>  IV是属性a的固有值，属性a可取的数值数目越多，那么IV就越大</p>

<ul>
  <li>但是增益率也有问题，那就是对于可取值数目较少的属性有偏好，所以著名的C4.5决策树算法并不是直接使用增益率，而是先从候选划分属性中找出信息增益高于平均水平的属性，然后再从中选择增益率最高的属性</li>
</ul>

<h3 id="433-基尼指数">4.3.3. 基尼指数</h3>
<ul>
  <li>CART决策树使用基尼指数来选择划分属性</li>
  <li>数据集D的纯度定义如下</li>
</ul>

<center><img src="../assets/img/posts/20211222/49.jpg" /></center>

<p>  直观来说，Gini反映了从数据集随便抽取两个样本，它们类别不一致概率</p>

<ul>
  <li><strong>基尼指数</strong>定义如下：</li>
</ul>

<center><img src="../assets/img/posts/20211222/50.jpg" /></center>

<p>  很明显，我们希望基尼指数越小越好，所以我们选择基尼指数最小的属性最为最优划分属性。</p>

<h2 id="44-剪枝处理">4.4. 剪枝处理</h2>
<ul>
  <li>不难发现，上面对于属性的划分很容易过拟合，所以针对过拟合现象，决策树选择<strong>剪枝(pruning)</strong>来对付过拟合</li>
  <li>剪枝就是去掉一些分支来降低过拟合的风险，剪枝可以分为预剪枝和后剪枝</li>
  <li><strong>预剪枝(prepruning)</strong>:在决策树生成的过程中，对每个结点在划分前进行估计，若当前结点的划分不能带来决策树泛化性能的提升，则停止划分</li>
  <li><strong>后剪枝(postpruning)</strong>:从训练集生成了一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能的提升，则将该子树替换为叶结点。</li>
</ul>

<h3 id="441-预剪枝">4.4.1. 预剪枝</h3>
<ul>
  <li>如何判断决策树泛化性能？可以使用留出法预留一部分数据用作验证集进行性能评估，性能度量可以用之前介绍的那些，本小节使用精度作为性能度量</li>
  <li>预剪枝生成的决策树：</li>
</ul>

<center><img src="../assets/img/posts/20211222/51.jpg" /></center>

<ul>
  <li>可以发现预剪枝显著减少了分支的数量，这样可以减少决策树的训练时间开销。但是这样也有一个问题，就是有些分支的当前划分虽然不能提升泛化性能，但是后续划分却有可能导致性能显著提高，这样就带来了欠拟合的风险</li>
</ul>

<h3 id="442-后剪枝">4.4.2. 后剪枝</h3>
<ul>
  <li>首先生成决策树，然后对每个结点进行评估是否需要剪枝</li>
</ul>

<center><img src="../assets/img/posts/20211222/52.jpg" /></center>

<ul>
  <li>虽然后剪枝决策树的欠拟合风险小，泛化性能也往往优于预剪枝决策树，但是后剪枝的时间开销大</li>
</ul>

<h2 id="45-连续与缺失值">4.5. 连续与缺失值</h2>
<h3 id="451-连续值处理">4.5.1. 连续值处理</h3>
<ul>
  <li>到目前为止仅讨论了基于离散属性来生成决策树，但是现实学习任务中通常会遇到连续属性</li>
  <li>很明显连续属性不能根据连续属性的可取值来对结点进行划分，我们需要用到<strong>连续属性离散化</strong>的技术，最简单的策略是<strong>二分法</strong></li>
  <li>给定样本集D和和连续属性a，假定a在D上出现了n个不同的取值，将这些值从小到大排序，然后每次选择每两个数的中位数t作为划分点，那么连续值就可以当作离散值来处理了，分出的子样本集分别记作$D_t^+$和$D_t^-$</li>
</ul>

<center><img src="../assets/img/posts/20211222/53.jpg" /></center>

<ul>
  <li>划分结果：</li>
</ul>

<center><img src="../assets/img/posts/20211222/54.jpg" /></center>

<ul>
  <li>需要注意的是：<strong>连续属性在划分后并不会被丢失，后续划分仍然可以使用</strong></li>
</ul>

<h3 id="452-缺失值处理">4.5.2. 缺失值处理</h3>
<ul>
  <li>在实际数据中一般都有很多缺失值，所以我们需要考虑如何对含有缺失值的数据进行学习</li>
  <li>给几个定义：$\tilde{D}$表示D中属性a上没有缺失值的样本子集，假设属性值a可取值{$a^1$,$a^2$…$a^V$}, $\tilde{D}^v$表示$\tilde{D}$中属性值a取值为$a^v$的子集，$\tilde{D}_k$表示样本子集，我们为每个样本赋予权重$\omega_x$(决策树开始阶段，根结点中权重初始化为1)并定义：</li>
</ul>

<center><img src="../assets/img/posts/20211222/55.jpg" /></center>

<ul>
  <li>
    <p>直观地看，对属性a，$\rho$表示无缺失值样本所占比例，$\tilde{p}_k$表示无缺失样本中第k类样本所占的比例，$\tilde{r}_v$表示无缺失值样本在属性上取值为$a^v$所占的比例</p>
  </li>
  <li>
    <p>那么我们可以将信息增益的公式推广为</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/56.jpg" /></center>

<p> </p>

<center><img src="../assets/img/posts/20211222/57.jpg" /></center>

<ul>
  <li>
    <p>那么对于那些在该属性上缺失的值如何处理呢？分两种情况：若样本$x$在划分属性$a$上的取值己知, 则将$x$划入与其取值对应的子结点，且样本权值在于结点中保持为$\omega_x$, 若样本$x$在划分属性$a$上的取值未知，则将$x$同时划入所有子结点, 且样本权值在与属性值$a^v$对应的子结点中调整为$\tilde{r}_v*\omega_x$，直观地看，这就是让同一个样本以不同的概率划入到不同的子结点中去。</p>
  </li>
  <li>
    <p>C4.5就是使用了上述的解决方法</p>
  </li>
</ul>

<h2 id="46-多变量决策树">4.6. 多变量决策树</h2>
<ul>
  <li>若我们把每个属性视为坐标空间中的一个坐标轴，则d个属性描述的样本就对应了d维空间中的一个数据点，对样本分类则意味着在这个坐标空间中寻找不同类样本之间的分类边界，决策树生成的分类边界有个明显的特点：<strong>轴平行</strong>，即它的分类边界由若干个与坐标轴平行的分段组成</li>
</ul>

<center><img src="../assets/img/posts/20211222/58.jpg" /></center>

<ul>
  <li>这样的决策树由于要进行大量的属性测试，预测时间开销会很大，所以我们希望使用如下图红线所示的斜划分。<strong>多变量决策树</strong>就是能实现这样斜划分甚至更复杂划分的决策树</li>
</ul>

<center><img src="../assets/img/posts/20211222/59.jpg" /></center>

<ul>
  <li>以实现斜划分的决策树为例，非叶结点不再是仅对某一个属性，而是对属性的线性组合进行测试</li>
</ul>

<center><img src="../assets/img/posts/20211222/60.jpg" /></center>

<h2 id="47-阅读材料">4.7. 阅读材料</h2>
<ul>
  <li>
    <p>多变量决策树算法主要有OC1，还有一些算法试图在决策树的叶结点上嵌入神经网络，比如感知机树在每个叶结点上训练一个感知机</p>
  </li>
  <li>
    <p>有些决策树学习算法可进行<strong>“增量学习”(incrementallearning)</strong>，即在接收到新样本后可对己学得的模型进行调整，而不用完全重新学习。主要机制是通过调整分支路径上的划分属性次序来对树进行部分重构，代表性算法ID4、ID5R、ITI等。增量学习可有效地降低每次接收到新样本后的训练时间开销，但多步增量学习后的模型会与基于全部数据训练而得的模型有较大差别。</p>
  </li>
</ul>

<h1 id="5-第5章-神经网络">5. 第5章 神经网络</h1>

<h2 id="50-思维导图">5.0. 思维导图</h2>

<center><img src="../assets/img/posts/20211222/73.jpg" /></center>

<h2 id="51-神经元模型">5.1. 神经元模型</h2>
<ul>
  <li>神经网络定义: 神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应</li>
  <li>神经网络中最基本的成分是神经元模型(neuron)</li>
  <li>M-P神经元模型:</li>
</ul>

<center><img src="../assets/img/posts/20211222/63.jpg" /></center>

<ul>
  <li>在这个模型中，神经元接收来自n个其他神经元传递过来的输入信号，这些输入信号通过带权重的连接进行传递，神经元接收到的总输入值将与神经元的阈值进行比较，然后通过激活函数处理以产生神经元的输出</li>
  <li>激活函数: 有<strong>阶越函数</strong>和<strong>Sigmoid函数</strong>等等</li>
</ul>

<center><img src="../assets/img/posts/20211222/64.jpg" /></center>

<h2 id="52-感知机与多层网络">5.2. 感知机与多层网络</h2>
<ul>
  <li>感知机(perceptron)由两层神经元组成，如下图所示</li>
</ul>

<center><img src="../assets/img/posts/20211222/65.jpg" /></center>

<ul>
  <li>
    <p>权重$\omega_i$以及阈值$\theta$可通过学习得到</p>
  </li>
  <li>
    <p>感知机的学习规则非常简单，对训练样例(x, y)，若当前感知机的输出为$\hat{y}$, 则感知机权重将这样调整</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/66.jpg" /></center>

<ul>
  <li>其中$\eta$称为学习率(learning rate)</li>
  <li>感知机只有输出层神经元进行激活函数处理，即只拥有一层功能神经元，其学习能力非常有限</li>
  <li>要解决非线性可分问题，需考虑使用多层功能神经元，比如下图，输入层和输出层之间的一层神经元被称为隐含层(hidden layer)，隐含层和输出层神经元都是拥有激活函数的功能神经元</li>
</ul>

<center><img src="../assets/img/posts/20211222/67.jpg" /></center>

<ul>
  <li>多层前馈神经网络(multi-layer feedforward neural networks): 每层神经元与下一层神经元全互连，神经元之间不存在同层连接，也不存在跨层连接</li>
</ul>

<h2 id="53-误差逆传播算法">5.3. 误差逆传播算法</h2>
<ul>
  <li>误差逆传播算法(error BackPropagation)简称BP算法，可用于很多类型的神经网络</li>
</ul>

<center><img src="../assets/img/posts/20211222/68.jpg" /></center>

<ul>
  <li>误差采用均方误差:</li>
</ul>

<center><img src="../assets/img/posts/20211222/69.jpg" /></center>

<ul>
  <li>BP算法基于梯度下降(gradient descent)策略，以目标的负梯度方向对参数进行调整</li>
</ul>

<center><img src="../assets/img/posts/20211222/70.jpg" /></center>

<ul>
  <li>
    <p>学习率控制着算法每一轮迭代中的更新步长，若太大则容易振荡，太小则收敛速度又会过慢</p>
  </li>
  <li>上面介绍的标准BP算法每次仅针对<strong>一个训练样例</strong>更新连接权和阈值，我们也可以简单推出基于累积误差最小化的更新规则，就得到了累积BP算法</li>
  <li>正是由于其强大的表达能力，BP神经网络经常遭遇过拟合，其训练误差持续降低，但测试误差却可能上升，由两种策略常用来缓解BP网络的过拟合。
    <ul>
      <li>第一种策略是<strong>早停(early stopping)</strong>: 若训练集误差降低但验证集误差升高，则停止训练</li>
      <li>第二种策略是正则化，其基本思路是在误差目标函数中增加一个用于描述网络复杂度的部分，例如连接权和阈值的平方和，那么误差目标函数变成:</li>
    </ul>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/71.jpg" /></center>

<h2 id="54-全局最小与局部极小">5.4. 全局最小与局部极小</h2>
<ul>
  <li>我们常常会谈到两种最优: <strong>局部极小(local minimum)</strong>和<strong>全局最小(global minimum)</strong></li>
  <li>直观地看，局部极小解是参数空间中的某个点，其领域点的误差函数值均不小于该点的函数值</li>
  <li>全局最小解是指参数空间中所有点的误差函数值均不小于该点的误差函数值</li>
</ul>

<center><img src="../assets/img/posts/20211222/72.jpg" /></center>

<ul>
  <li>在现实任务中，人们常采用以下策略来试图跳出局部极小，从而进一步实现全局最小
    <ul>
      <li>以多组不同参数值初始化多个神经网络</li>
      <li>使用“模拟退火”(simulated annealing)技术，每一步都以一定概率接受比当前解更差的结果，从而有助于跳出局部极小</li>
      <li>随机梯度下降，即每次使用随机的样本进行误差计算</li>
    </ul>
  </li>
</ul>

<h2 id="55-其他常见神经网络">5.5. 其他常见神经网络</h2>

<h3 id="551-rbf网络">5.5.1. RBF网络</h3>
<ul>
  <li>RBF(Radial Basis Function, 径向基函数)网络是一种单隐层前馈神经网络，它使用径向基函数作为隐层神经元激活函数，而输出层则是对隐层神经元输出的线性组合</li>
  <li>具有足够多隐层神经元的RBF网络能以任意精度逼近任意连续函数</li>
</ul>

<h3 id="552-art网络">5.5.2. ART网络</h3>
<ul>
  <li>竞争型学习(competitive learning)是神经网络中一种常用的无监督学习策略，在使用该策略时，网络的输出神经元相互竞争，每一时刻仅有一个竞争获胜的神经元被激活，其他神经元的状态被抑制。这种机制亦称胜者通吃(winner-take-all)原则</li>
  <li>ART(Adaptive Resonance Theory，自适应谐振理论)网络是竞争型学习的重要代表。该网络由比较层、识别层、识别阔值和重置模块构成。其中，比较层负责接受输入样本，并将其传递给识别层神经元。识别层每个神经元对应一个模式类，神经元数目可在训练过程中动态增长以增加新的模式类</li>
</ul>

<h3 id="553-som网络">5.5.3. SOM网络</h3>
<ul>
  <li>SOM(Self-Organizing Map，自组织映射)网络是一种竞争学习型的无监督神经网络，它能将高维输入数据映射到低维空间(通常为二维) ，同时保持输入数据在高维空间的拓扑结构，即将高维空间中相似的样本点映射到网络输出层中的邻近神经元</li>
</ul>

<center><img src="../assets/img/posts/20211222/74.jpg" /></center>

<h3 id="554-级联相关网络">5.5.4. 级联相关网络</h3>
<ul>
  <li>一般的神经网络模型通常假定网络结构是事先固定的，训练的目的是利用训练样本来确定合适的连接权、阈值等参数。与此不同，结构自适网络则将网络结构也当作学习的目标之一，并希望能在训练过程中找到最符合数据特点的网络结构-级联相关(Cascade-Correlation)网络是结构自适应网络的重要代表</li>
</ul>

<center><img src="../assets/img/posts/20211222/75.jpg" /></center>

<h3 id="555-elman网络">5.5.5. Elman网络</h3>
<ul>
  <li>与前馈神经网络不同<strong>递归神经网络(recurrent neural networks)</strong>允许网络中出现环形结构，从而可让一些神经元的输出反馈回来作为输入信号。这样的结构与信息反馈过程，使得网络在t时刻的输出状态不仅与t时刻的输入有关，还与t-1时刻的网络状态有关，从而能处理与时间有关的动态变化</li>
  <li>Elman网络是最常用的递归神经网络之一，其结构如图所示，它的结构与多层前馈网络很相似，但隐层神经元的输出被反馈回来，与下一时刻输入层神经元提供的信号一起，作为隐层神经元在下一时刻的输入。隐层神经元通常采用Sigmoid激活函数，而网络的训练则常通过推广的BP算法进行</li>
</ul>

<center><img src="../assets/img/posts/20211222/76.jpg" /></center>

<h3 id="556-boltzmann机">5.5.6. Boltzmann机</h3>
<ul>
  <li>神经网络中有一类模型是为网络状态定义一个能量(energy)，能量最小化时网络达到理想状态，而网络的训练就是在最小化这个能量函数。Boltzmann机就是一种基于能量的模型(energy-based model)，常见结构如图所示，其神经元分为两层:显层与隐层。显层用于表示数据的输入与输出，隐层则被理解为数据的内在表达</li>
</ul>

<center><img src="../assets/img/posts/20211222/77.jpg" /></center>

<h2 id="56-深度学习">5.6. 深度学习</h2>
<ul>
  <li>理论上来说，参数越多的模型复杂度越高、 “容量” (capacity) 越大，这意味着它能完成更复杂的学习任务。但一般情形下，复杂模型的训练效率低，易陷入过拟合，因此难以受到人们青睐。而随着云计算、大数据时代的到来，计算能力的大幅提高可缓解训练低效性，训练数据的大幅增加则可降低过拟合风险，因此，以”深度学习”(deep learning)为代表的复杂模型开始受到人们的关注。</li>
  <li>无监督逐层训练(unsupervised layer-wise training)是多隐层网络训练的有效手段，其基本思想是每次训练一层隐结点，训练时将上一层隐结点的输出作为输入，向本层隐结点的输出作为下一层隐结点的输入，这称为<strong>预训练(pre-training)</strong>;在预训练全部完成后，再对整个网络进行<strong>微调(fine-tuning)</strong>训练</li>
  <li>另一种节省训练开销的策略是权共享，即让一组神经元使用相同的连接权，比如CNN</li>
  <li>以往在机器学习用于现实任务时，描述样本的特征通常需由人类专家来设计，这称为<strong>特征工程(feature engineering)</strong>，深度学习则通过机器学习技术自身产生好特征</li>
  <li>神经网络是一种难以解释的黑箱模型</li>
</ul>

<h1 id="6-第6章-支持向量机">6. 第6章 支持向量机</h1>

<h2 id="60-思维导图">6.0. 思维导图</h2>

<center><img src="../assets/img/posts/20211222/134.jpg" /></center>

<h2 id="61-间隔与支持向量">6.1. 间隔与支持向量</h2>
<ul>
  <li>给定训练样本集$D={(x_1, y_1),(x_2, y_2),…,(x_m, y_m)}$, 其中$y_i\in${$-1, +1$}, 也就是一个传统的分类问题。分类学习最基本的想法就是基于训练集D在样本空间中找到一个划分超平面，将不同类别的样本分开，但能将训练样本分开的划分超平面可能有很多，如下图</li>
</ul>

<center><img src="../assets/img/posts/20211222/78.jpg" /></center>

<ul>
  <li>直观上看，应该去找位于两类训练样本正中间的划分超平面，因为该划分超平面对训练样本局部扰动的容忍性最好</li>
  <li>在样本空间中，划分超平面可通过如下线性方程来描述: $\omega^Tx+b=0$, 其中$\omega$为法向量, 决定了超平面的方向, b为位移项, 决定了超平面与原点的距离, 显然划分超平面可被法向量$\omega$和b确定</li>
  <li>样本空间中任意点x到超平面的距离可写为</li>
</ul>

<center><img src="../assets/img/posts/20211222/79.jpg" /></center>

<ul>
  <li>假设超平面能将训练样本正确分类, 即对($x_i, y_i$)$\in$D, 我们有以下结果:</li>
</ul>

<center><img src="../assets/img/posts/20211222/80.jpg" /></center>

<ul>
  <li><strong>支持向量</strong>: 距离超平面最近的几个训练样本点使得上述条件等号成立，它们就被称为支持向量(support vector), 两个异类支持向量到超平面的距离之和为<strong>间隔</strong>$\gamma$</li>
</ul>

<center><img src="../assets/img/posts/20211222/81.jpg" /></center>

<ul>
  <li>图示:</li>
</ul>

<center><img src="../assets/img/posts/20211222/82.jpg" /></center>

<ul>
  <li>欲找到具有最大间隔的划分超平面，也就是找到能满足约束的最大的$\gamma$</li>
</ul>

<center><img src="../assets/img/posts/20211222/83.jpg" /></center>

<ul>
  <li>为了最大化间隔，仅需最大化||$\omega$||$^{-1}$, 这等价于最小化||$\omega$||$^{2}$, 于是上述式子可重写为:</li>
</ul>

<center><img src="../assets/img/posts/20211222/84.jpg" /></center>

<ul>
  <li>这就是支持向量机(Support Vector Machine, SVM)的基本型</li>
</ul>

<h2 id="62-对偶问题">6.2. 对偶问题</h2>
<ul>
  <li>我们注意到SVM的基本型本身是一个凸二次规划问题<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>, 能直接用现成的优化计算包求解，但我们可以有更高效的方法</li>
</ul>

<ul>
  <li>对上述式子使用拉格朗日乘子法<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>可得到其对偶问题，则该问题的拉格朗日函数可写为</li>
</ul>

<center><img src="../assets/img/posts/20211222/91.jpg" /></center>

<ul>
  <li>其中$\alpha$=($\alpha_1$;$\alpha_2$…;$\alpha_m$), 令L($\omega$, b, $\alpha$)对$\omega$和b的偏导为零可得</li>
</ul>

<center><img src="../assets/img/posts/20211222/92.jpg" /></center>

<ul>
  <li>将这两个条件带入之前的拉格朗日函数中，即可将$\omega$和b消去，得到以下的对偶问题:</li>
</ul>

<center><img src="../assets/img/posts/20211222/93.jpg" /></center>

<center><img src="../assets/img/posts/20211222/94.jpg" /></center>

<ul>
  <li>从对偶问题中解出的$\alpha_i$是拉格朗日乘子，它恰对应着训练样本($x_i$, $y_i$), 在主问题中有不等式约束，因此上述过程需满足<strong>KTT条件</strong>, 即要求:</li>
</ul>

<center><img src="../assets/img/posts/20211222/96.jpg" /></center>

<ul>
  <li>解出$\alpha$后，求出$\omega$与b即可得到模型:</li>
</ul>

<center><img src="../assets/img/posts/20211222/95.jpg" /></center>

<ul>
  <li>于是, 对任意训练样本($x_i$, $y_i$), 总有$\alpha_i=0$或者$y_if(x_i)=1$。若$\alpha_i=0$，则该样本将不会在最终的模型的求和中出现，也就不会对f(x)有任何影响;若$\alpha_i&gt;0$, 则必有$y_if(x_i)=1$，所对应的样本点位于最大间隔边界上，是一个支持向量。这显示出支持向量机的一个重要性质:训练完成后, 大部分的训练样本都不需保留，最终模型仅与支持向量有关</li>
  <li>那么如何求解对偶问题解出$\alpha_i$呢？这是一个二次规划问题, 可使用通用的二次规划算法求解，然而，该问题的规模正比于训练样本数，这会在实际任务中造成很大的开销，为了避开这个障碍，人们通过利用问题本身的特性，提出了很多高效算法, SMO是其中一个著名的代表</li>
  <li>SMO的基本思路是先固定$\alpha_i$之外的所有参数，然后求$\alpha_i$上的极值，由于存在约束$\sum_1^m\alpha_iy_i=0$,若固定$\alpha_i$之外的其他变量，则$\alpha_i$可由其他变量导出，于是SMO每次选择两个变量$\alpha_i$和$\alpha_j$，并固定其他参数。这样，在参数初始化后，SMO不断执行如下两个步骤直至收敛
    <ul>
      <li>选取一对需更新的变量$\alpha_i$和$\alpha_j$</li>
      <li>固定$\alpha_i$和$\alpha_j$以外的参数，求解获得更新后的$\alpha_i$和$\alpha_j$</li>
    </ul>
  </li>
  <li>如何确定偏移项b呢？注意到对任意支持向量($x_s$, $y_s$)都有$y_sf(x_s)=1$:</li>
</ul>

<center><img src="../assets/img/posts/20211222/97.jpg" /></center>

<ul>
  <li>其中S为所有支持向量的下标集，理论上可以选取任意支持向量来求出b，但现实任务中常采用一种更鲁棒的做法: 使用所有支持向量求解的平均值</li>
</ul>

<center><img src="../assets/img/posts/20211222/98.jpg" /></center>

<h2 id="63-核函数">6.3. 核函数</h2>
<ul>
  <li>在本章前面的讨论中，我们假设训练样本是线性可分的，然而在现实任务中，原始样本空间内也许并不存在一个能正确划分两类样本的超平面，例如异或问题就不是线性可分的</li>
  <li>对这样的问题，可将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分，例如将异或问题的原始二维空间映射到一个合适的三维空间，就能找到一个合适的划分超平面。如果原始空间是有限维，即属性数有限，那么一定存在一个高维特征空间使样本可分</li>
</ul>

<center><img src="../assets/img/posts/20211222/99.jpg" /></center>

<ul>
  <li>令$\phi(x)$表示将x映射后的特征向量，于是在特征空间中划分超平面所对应的模型可表示为</li>
</ul>

<center><img src="../assets/img/posts/20211222/100.jpg" /></center>

<ul>
  <li>其中$\omega$和b是模型参数，我们有以下二次规划:</li>
</ul>

<center><img src="../assets/img/posts/20211222/101.jpg" /></center>

<ul>
  <li>其对偶问题是:</li>
</ul>

<center><img src="../assets/img/posts/20211222/102.jpg" /></center>

<center><img src="../assets/img/posts/20211222/103.jpg" /></center>

<ul>
  <li>我们观察到在对偶问题中涉及到计算$\phi(x_i)^T\phi(x_j)$, 这是样本$x_i$与$x_j$映射到特征空间之后的内积。由于特征空间维数可能很高，甚至是无穷维，因此直接计算$\phi(x_i)^T\phi(x_j)$通常是困难的，为了避开这个障碍，可以设想这样一个函数:</li>
</ul>

<center><img src="../assets/img/posts/20211222/104.jpg" /></center>

<ul>
  <li>即$x_i$与$x_j$在特征空间的内积等于它们在原始样本空间中通过函数$\kappa(·,·)$计算的结果, 有了这样的函数，我们就不必直接去计算高维甚至无穷维特征空间中的内积，于是式子可重写为</li>
</ul>

<center><img src="../assets/img/posts/20211222/105.jpg" /></center>

<ul>
  <li>求解后可得到:</li>
</ul>

<center><img src="../assets/img/posts/20211222/106.jpg" /></center>

<ul>
  <li>上面式子显示出模型最优解可通过训练样本的核函数展开，这一展式亦称<strong>支持向量展式</strong></li>
  <li>显然，若已知合适映射$\phi(·)$的具体形式，则可写出核函数$\kappa(·,·)$，但在现实任务中我们通常不知道$\phi(·)$是什么形式，那么合适的核函数是否一定存在呢？什么样的函数能做核函数呢？我们有以下定理:</li>
</ul>

<center><img src="../assets/img/posts/20211222/107.jpg" /></center>

<ul>
  <li>核函数选择成为支持向量机的最大变数，若核函数选择不合适，则意味着将样本映射到一个不合适的特征空间，很可能导致性能不佳</li>
  <li>常用核函数:</li>
</ul>

<center><img src="../assets/img/posts/20211222/108.jpg" /></center>

<ul>
  <li>此外，还可通过函数组合得到:
    <ul>
      <li>两个核函数的线性组合</li>
      <li>两个核函数的直积</li>
    </ul>

    <center><img src="../assets/img/posts/20211222/109.jpg" /></center>

    <ul>
      <li>若$\kappa_1$为核函数，则对任意函数g(x):</li>
    </ul>

    <center><img src="../assets/img/posts/20211222/110.jpg" /></center>

    <p>也是核函数</p>
  </li>
</ul>

<h2 id="64-软间隔与正则化">6.4. 软间隔与正则化</h2>
<ul>
  <li>在前面的讨论中，我们一直假定训练样本在样本空间或特征空间中是线性可分的，即存在一个超平面能将不同类的样本完全划分开。然而，在现实任务中往往很难确定合适的核函数使得训练样本在特征空间中线性可分</li>
  <li>缓解该问题的一个方法是允许支持向量机在一些样本上出错，为此，要引入软间隔(soft margin)的概念</li>
  <li>具体来说，前面介绍的支持向量机形式都是要求所有样本均满足约束，即所有样本必须划分正确，这称为硬间隔，而软间隔则允许某些样本不满足约束</li>
  <li>优化目标可写为:</li>
</ul>

<center><img src="../assets/img/posts/20211222/111.jpg" /></center>

<ul>
  <li>其中C&gt;0是一个常数，$l_{0/1}$是0/1损失函数</li>
</ul>

<center><img src="../assets/img/posts/20211222/112.jpg" /></center>

<ul>
  <li>显然，当C无穷大时，上面式子迫使所有样本均满足约束，当C取有限值时，式子允许一些样本不满足约束</li>
  <li>然而0/1损失函数非凸、非连续，数学性质不太好，于是人们通常用其他一些函数来替代它，下面给出三个常用的替代损失函数：</li>
</ul>

<center><img src="../assets/img/posts/20211222/113.jpg" /></center>

<ul>
  <li>若采用hinge损失，则式子变成:</li>
</ul>

<center><img src="../assets/img/posts/20211222/114.jpg" /></center>

<ul>
  <li>引入松弛变量$\xi_i$≥0，可将式子重写为</li>
</ul>

<center><img src="../assets/img/posts/20211222/115.jpg" /></center>

<center><img src="../assets/img/posts/20211222/116.jpg" /></center>

<ul>
  <li>这就是常用的软间隔支持向量机，可以看出每个样本都有一个对应的松弛变量，用以表征样本不满足约束的程度</li>
  <li>这仍是一个二次规划的问题，于是，通过拉格朗日乘子法可得到拉格朗日函数:</li>
</ul>

<center><img src="../assets/img/posts/20211222/117.jpg" /></center>

<ul>
  <li>其中$\alpha_i≥0$, $\mu_i≥0$是拉格朗日乘子</li>
  <li>偏导为0后可得到对偶问题:</li>
</ul>

<center><img src="../assets/img/posts/20211222/118.jpg" /></center>

<ul>
  <li>KTT条件:</li>
</ul>

<center><img src="../assets/img/posts/20211222/119.jpg" /></center>

<ul>
  <li>可以发现软间隔支持向量机的最终模型仅与支持向量有关</li>
  <li>我们还可以把0/1损失函数替换成别的替代损失函数以得到其他学习模型，这些模型的性质与所用的替代函数直接相关，但它们具有一个共性: 优化目标中的第一项用来描述划分超平面的间隔大小，另一项用来描述训练集上的误差</li>
</ul>

<center><img src="../assets/img/posts/20211222/120.jpg" /></center>

<ul>
  <li>其中$\Omega(f)$称为“结构风险”(structural risk)，用于描述模型f的某些性质;第二项$\sum_i^ml(f(x_i),y_i)$称为“经验风险”(empirical risk)，用于描述模型与训练数据的契合程度; C用于对二者进行折中。从经验风险最小化的角度来看，$\Omega(f)$表述了我们希望获得具有何种性质的模型(例如希望获得复杂度较小的模型)，这为引入领域知识和用户意图提供了途径; 另一方面，该信息有助于削减假设空间，从而降低了最小化训练误差的过拟合风险。从这个角度来说，上面的公式为“正则化”(regularization)问题，$\Omega(f)$称为正则化项，C则称为正则化常数。$L_p$范数(norm)是常用的正则化项，其中$L_2$范数$||\omega||_2$倾向于$\omega$的分量取值尽量均衡，即非零分量个数尽量稠密，而$L_0$范数$||\omega||_0$和$L_1$范数$||\omega||_1$则倾向于$\omega$的分量尽量稀疏，即非零分量个数尽量少</li>
</ul>

<h2 id="65-支持向量回归">6.5. 支持向量回归</h2>
<ul>
  <li>现在我们来考虑回归问题，给定训练样本$D={(x_1, y_1), (x_2, y_2), …, (x_m, y_m))}，希望学得一个形如$f(x)=\omega^Tx+b$的回归模型，使得f(x)与y尽可能接近。</li>
  <li>传统回归模型通常直接基于输出f(x)与真实输出y之间的差别来计算损失，当且仅当f(x)与y完全相同时，损失才为0。与此不同，支持向量回归(Support Vector Regression, 简称SVR)假设我们能容忍f(x)与y之间最多有$\epsilon$的偏差，如下图所示，若样本落入此间隔带，则被认为预测正确</li>
</ul>

<center><img src="../assets/img/posts/20211222/121.jpg" /></center>

<ul>
  <li>于是SVR问题可形式化为:</li>
</ul>

<center><img src="../assets/img/posts/20211222/122.jpg" /></center>

<ul>
  <li>其中C为正则化常数，$l_{\epsilon}$是$\epsilon$-不敏感损失函数:</li>
</ul>

<center><img src="../assets/img/posts/20211222/123.jpg" /></center>

<ul>
  <li>引入松弛变量$\xi_i$和$\hat{\xi_i}$，可将上述式子重写为:</li>
</ul>

<center><img src="../assets/img/posts/20211222/124.jpg" /></center>

<center><img src="../assets/img/posts/20211222/125.jpg" /></center>

<ul>
  <li>类似地，通过引入拉格朗日乘子可得到拉格朗日函数:</li>
</ul>

<center><img src="../assets/img/posts/20211222/126.jpg" /></center>

<ul>
  <li>偏导为零得到对偶问题:</li>
</ul>

<center><img src="../assets/img/posts/20211222/127.jpg" /></center>

<ul>
  <li>KTT条件:</li>
</ul>

<center><img src="../assets/img/posts/20211222/128.jpg" /></center>

<ul>
  <li>将上述条件代入，SVR的解形如:</li>
</ul>

<center><img src="../assets/img/posts/20211222/129.jpg" /></center>

<ul>
  <li>能使式子中$(\hat{\alpha}_i-\alpha_i)≠0$的样本即为SVR的支持向量，它们必落在$\epsilon$-间隔带之外</li>
  <li>由KTT条件可看出，对每个样本($x_i, y_i$)都有$(C-\alpha_i)\xi_i=0$且$\alpha_i(f(x_i)-y_i-\epsilon-\xi_i)=0$，于是在得到$\alpha_i$后，若0&lt;$\alpha_i$&lt;C, 则必有$\xi_i=0$,进而有:</li>
</ul>

<center><img src="../assets/img/posts/20211222/130.jpg" /></center>

<ul>
  <li>理论上说，可任意选取满足的$\alpha_i$来得到b，但是实践中常采用一种更鲁棒的方法: 选取多个满足0&lt;$\alpha_i$&lt;C的样本通过上述公式求解b后取平均值</li>
  <li>若考虑特征映射，则:</li>
</ul>

<center><img src="../assets/img/posts/20211222/131.jpg" /></center>

<center><img src="../assets/img/posts/20211222/132.jpg" /></center>

<h2 id="66-核方法">6.6. 核方法</h2>
<ul>
  <li>若不考虑偏移项b，则无论SVM还是SVR，学得的模型总能表示成核函数的线性组合。不仅如此，事实上我们有下面这个称为“表示定理”(representer theorem)的更一般的结论</li>
</ul>

<center><img src="../assets/img/posts/20211222/133.jpg" /></center>

<ul>
  <li>人们发展出一系列基于核函数的学习方法，统称为核方法，最常见的是通过引入核函数来将线性学习器拓展为非线性学习器</li>
  <li>支持向量机是针对二分类任务设计的，对多分类任务要进行专门的推广</li>
</ul>

<h1 id="7-第7章-贝叶斯分类器">7. 第7章 贝叶斯分类器</h1>

<h2 id="70-思维导图">7.0. 思维导图</h2>

<center><img src="../assets/img/posts/20211222/162.jpg" /></center>

<h2 id="71-贝叶斯决策论">7.1. 贝叶斯决策论</h2>
<ul>
  <li>贝叶斯决策论是概率框架下实施决策的基本方法。对于分类任务来说，在所有相关概率都已知的理想情形下，贝叶斯决策论考虑如何基于这些概率和误判损失来选择最优的类别标记。</li>
  <li>以多分类任务为例: 假设有N种可能的类别标记，即$Y=${$c_1, c_2,…,c_N$}, $\lambda_{ij}$是将真实标记为$c_j$的样本误分类为$c_i$所产生的损失。基于后验概率<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>$P(c_i|x)$可获得将样本x分类为$c_i$所产生的期望损失，即在样本上的<u>条件风险</u>:</li>
</ul>

<center><img src="../assets/img/posts/20211222/135.jpg" /></center>

<ul>
  <li>我们的任务是寻找一个判定准则h: X -&gt; Y以最小化总体风险</li>
</ul>

<center><img src="../assets/img/posts/20211222/136.jpg" /></center>

<ul>
  <li>显然，对每个样本x，若h能最小化条件风险R(h(x)|x)，则总体风险R(h)也将被最小化。这就产生了贝叶斯判定准则: 为最小化总体风险，只需在每个样本上选择那个能使条件风险R(c|x)最小的类别标记，即:</li>
</ul>

<center><img src="../assets/img/posts/20211222/137.jpg" /></center>

<ul>
  <li>此时，$h^*$称为贝叶斯最优分类器，与之对应的总体风险R($h^*$)称为贝叶斯风险。1-R($h^*$)反映了分类器所能达到的最好性能。</li>
</ul>

<ul>
  <li>具体来说，若目标是最小化分类错误率，则误判损失$\lambda_{ij}$可写为:</li>
</ul>

<center><img src="../assets/img/posts/20211222/138.jpg" /></center>

<ul>
  <li>此时条件风险为:</li>
</ul>

<center><img src="../assets/img/posts/20211222/139.jpg" /></center>

<ul>
  <li>于是，最小化分类错误率的贝叶斯最优分类器为:</li>
</ul>

<center><img src="../assets/img/posts/20211222/140.jpg" /></center>

<ul>
  <li>
    <p>即对每个样本，选择能使后验概率$P(c|x)$最大的类别标记</p>
  </li>
  <li>
    <p>不难看出，欲使用贝叶斯判定准则来最小化决策风险，首先要获得后验概率$P(c|x)$。然而，在现实任务中这通常难以直接获得，从这个角度来看，机器学习所要实现的是基于有限的训练样本集尽可能准确地估计出后验概率$P(c|x)$。大体来说，主要有两种策略: 给定x，可通过直接建模$P(c|x)$来预测c，这样得到的是<u>判别式模型</u>。也可以先对联合概率分布P(x,c)建模，然后再由此获得$P(c|x)$，这样得到的是<u>生成式模型</u>。</p>
  </li>
  <li>
    <p>对于生成式模型来说，必须考虑:</p>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/141.jpg" /></center>

<ul>
  <li>基于贝叶斯定理，$P(c|x)$可写为:</li>
</ul>

<center><img src="../assets/img/posts/20211222/142.jpg" /></center>

<ul>
  <li>其中，P(c)是类先验概率，P(x|c)是样本x相对于类标记c的类条件概率，或称为似然(likelihood)。P(x)是用于归一化的证据因子，P(x)对所有类标记均相同。因此估计P(c|x)的问题就转化为如何基于训练数据D来估计先验概率P(c)和似然P(x|c).</li>
  <li>类先验概率P(c)表达了样本空间中各类样本所占的比例，根据大数定律，当训练集包含充足独立同分布的样本时，P(c)可通过各类样本出现的频率进行估计</li>
  <li>对类条件概率P(x|c)来说，由于它涉及关于x所有属性的联合概率，直接根据样本出现的频率来估计将会遇到严重的困难，例如样本d个属性都是二值的，则样本空间将有$2^d$种可能取值，在现实应用中，这个值往往远大于训练样本数m，因此不能用频率估计概率</li>
</ul>

<h2 id="72-极大似然估计">7.2. 极大似然估计</h2>
<ul>
  <li>估计类条件概率的一种常用策略是先假定其具有某种确定的概率分布形式，再基于训练样本对概率分布进行参数估计。具体来说，记关于类别c的类条件概率为P(x|c)，假设P(x|c)具有确定的形式且被参数向量$\theta_c$唯一确定，则我们的任务就是利用训练集D估计参数$\theta_c$</li>
  <li>概率模型的训练过程就是参数估计的过程，统计学界的两个学派提出了不同的解决方案，频率主义学派认为参数虽然未知，但却客观存在固定值，因此可以通过优化似然函数等准则来确定参数值。本节介绍源自频率主义学派的极大似然估计<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup></li>
</ul>

<ul>
  <li>令$D_c$表示训练集D中第c类样本组成的集合，假设这些样本是独立同分布的，则参数$\theta_c$对于数据集$D_c$的似然是:</li>
</ul>

<center><img src="../assets/img/posts/20211222/143.jpg" /></center>

<ul>
  <li>对$\theta_c$进行极大似然估计，就是去寻找最大化似然$P(D_c|\theta_c)$的参数值$\hat{\theta_c}$</li>
  <li>上述似然中的连乘操作易造成下溢，通常使用对数似然(log-likelihood)</li>
</ul>

<center><img src="../assets/img/posts/20211222/144.jpg" /></center>

<ul>
  <li>此时参数$\hat{\theta_c}$的极大似然估计$\hat{\theta_c}$为</li>
</ul>

<center><img src="../assets/img/posts/20211222/145.jpg" /></center>

<ul>
  <li>例如，再连续属性情形下，假设概率密度函数p(x|c)~N($\mu_c, \sigma_c^2$)， 则参数$\mu_c$和$\sigma_c^2$的极大似然估计为:</li>
</ul>

<center><img src="../assets/img/posts/20211222/146.jpg" /></center>

<ul>
  <li>也就是说，通过极大似然法得到的正态分布均值就是样本均值，方差就是$(x-\hat{mu_c})(x-\hat{\mu_c})^T$的均值</li>
  <li>虽然这种参数化方法虽然能使类条件概率估计变得相对简单，但估计结果的准确性严重依赖于所假设的概率分布形式是否符合潜在的真实数据分布</li>
</ul>

<h2 id="73-朴素贝叶斯分类器">7.3. 朴素贝叶斯分类器</h2>
<ul>
  <li>不难发现，基于贝叶斯公式来估计后验概率P(c|x)的主要困难在于: 类条件概率P(x|c)是所有属性上的联合概率，难以从有限的训练样本直接估计而得。为了避开这个障碍，<strong>朴素贝叶斯分类器(naïve Bayes classifier)</strong>采用了属性条件独立性假设</li>
  <li>基于这个假设，贝叶斯公式可以重写为:</li>
</ul>

<center><img src="../assets/img/posts/20211222/147.jpg" /></center>

<ul>
  <li>对于所有类别来说P(x)相同，因此基于贝叶斯判定准则有:</li>
</ul>

<center><img src="../assets/img/posts/20211222/148.jpg" /></center>

<ul>
  <li>对于P(c)和$P(x_i|c)$都用频率估计概率(对于离散属性而言)，对于连续属性则考虑概率密度函数为正态分布，参数由极大似然估计求出</li>
  <li>但是这种方法存在一个问题: 如果某个属性值在训练样本中没有出现过，那么对概率进行连乘的时候会乘上一个零，这样显然不太合理。解决方法: 可以在估计概率值时进行平滑处理，常用拉普拉斯修正。具体来说，令N表示训练集D中所有的类别数，$N_i$表示第i个属性可能的取值数，则修正为:</li>
</ul>

<center><img src="../assets/img/posts/20211222/149.jpg" /></center>

<ul>
  <li>在现实任务中朴素贝叶斯分类器有多种使用方式。例如，若任务对预测速度要求较高，则对给定训练集，可将朴素贝叶斯分类器涉及的所有概率估值事先计算好存储起来，这样在进行预测时只需”查表”即可进行判别;若任务数据更替频繁，则可采用”懒惰学习”(lazy learning)方式，先不进行任何训练，待收到预测请求时再根据当前数据集进行概率估值;若数据不断增加，则可在现有估值基础上，仅对新增样本的属性值所涉及的概率估值进行计数修正即可实现增量学习</li>
</ul>

<h2 id="74-半朴素贝叶斯分类器">7.4. 半朴素贝叶斯分类器</h2>
<ul>
  <li>朴素贝叶斯的假设在现实任务中往往难以实现，人们尝试对属性条件独立性假设进行一定程度的放松，由此产生了一类称为<strong>半朴素贝叶斯分类器</strong>的方法</li>
  <li>半朴素贝叶斯分类器的基本想法是适当考虑一部分属性间的相互依赖信息，从而既不需要进行完全联合概率，又不至于彻底忽略了比较强的属性依赖关系。<u>独依赖估计</u>(one-dependent estimator 简称ODE)是半朴素贝叶斯分类器最常用的一种策略。独依赖就是假设每个属性在类别之外最多仅依赖于一个其他属性，即:</li>
</ul>

<center><img src="../assets/img/posts/20211222/150.jpg" /></center>

<ul>
  <li>其中$pa_i$为属性$x_i$所依赖的属性，称为$x_i$的父属性，此时如果每个属性的父属性已知，则可采用之前的方法估计概率值，但是问题的关键在于如何确定每个属性的父属性，不同的做法产生不同的独依赖分类器</li>
  <li>最直接的做法是假设所有属性都依赖于同一个属性，称为<strong>超父</strong>，然后通过交叉验证等模型选择方法来确定超父属性，由此形成了SPODE(super parent ODE)方法。例如下图中，$x_1$是超父属性</li>
</ul>

<center><img src="../assets/img/posts/20211222/151.jpg" /></center>

<ul>
  <li>另一种TAN(Tree Augmented naïve Bayes)则是最大带权生成树算法的基础上，通过以下步骤将属性间依赖关系简约为如图所示的树形结构:
    <ul>
      <li>1.计算任意两个属性间的条件相互信息</li>
    </ul>

    <center><img src="../assets/img/posts/20211222/152.jpg" /></center>

    <ul>
      <li>2.以属性为结点构建完全图，任意两个结点之间边的权重设为$I(x_i,x_j)|y$</li>
      <li>3.构建此完全图的最大带权生成树，挑选根变量，将边置为有向</li>
      <li>4.加入类别结点y，增加从y到每个属性的有向边</li>
    </ul>
  </li>
</ul>

<center><img src="../assets/img/posts/20211222/153.jpg" /></center>

<ul>
  <li>TAN实际保留了强相关属性之间的依赖性</li>
  <li>AODE(averaged one-dependent estimator)是一种基于集成学习机制、更为强大的独依赖分类器，于SPODE通过模型选择确定超父属性不同，AODE尝试将每个属性作为超父来构建SPODE，然后将那些具有足够训练数据支撑的SPODE集成起来作为最终结果:</li>
</ul>

<center><img src="../assets/img/posts/20211222/154.jpg" /></center>

<ul>
  <li>与朴素贝叶斯分类器类似，AODE的训练过程也是计数，即在训练数据上对符合条件的样本进行计数的过程</li>
  <li>既然将属性条件独立性假设放松为独依赖假设可能获得泛化性能的提升，那么，能否通过考虑属性间的高阶依赖来进一步提升泛化性能呢?也就是说，将式中的属性$pa_i$替换为包含k个属性的集合<strong>$pa_i$</strong>，从而将ODE拓展为kDE。需注意的是，随着k的增加，准确估计概率$P(x_i|y,pa_i)$所需的训练样本数量将以指数级增加。因此，若训练数据非常充分，泛化性能有可能提升;但在有限样本条件下，则又陷入估计高阶联合概率的泥沼</li>
</ul>

<h2 id="75-贝叶斯网">7.5. 贝叶斯网</h2>
<ul>
  <li>贝叶斯网亦称信念图，它借助有向无环图来刻画属性之间的依赖关系，并使用条件概率表来描述属性的联合概率分布，一个贝叶斯网B由结构G和参数$\Theta$两部分组成，即$B=&lt;G,\Theta&gt;$</li>
</ul>

<center><img src="../assets/img/posts/20211222/155.jpg" /></center>

<h3 id="751-结构">7.5.1. 结构</h3>
<ul>
  <li>贝叶斯网结构有效地表达了属性间的条件独立性，给定父结点集，贝叶斯网假设每个属性与它的非后裔属性独立，于是联合概率分布定义为:</li>
</ul>

<center><img src="../assets/img/posts/20211222/156.jpg" /></center>

<ul>
  <li>上图中，$x_3$和$x_4$在给定$x_1$的取值时独立，简记为$x_3$⊥$x_4$|$x_1$</li>
  <li>下图给出了贝叶斯网的三个变量之间的典型依赖关系</li>
</ul>

<center><img src="../assets/img/posts/20211222/157.jpg" /></center>

<ul>
  <li>在顺序结构中，给定x的值，则y与z条件独立。V型结构(V-structure)亦称冲撞的结构，给定子结点$x_4$的取值，$x_1$与$x_2$必不独立，奇妙的是，若$x_4$的取值完全未知，则V型结构下$x_1$和$x_2$却是相互独立的，我们做一个简单的验证:</li>
</ul>

<center><img src="../assets/img/posts/20211222/158.jpg" /></center>

<ul>
  <li>这样的独立性称为边际独立性，记为$x_1$╨$x_2$</li>
  <li>为了分析有向图中变量间的条件独立性，可使用有向分离，将有向图变为无向图:
    <ul>
      <li>找出有向图中的所有V型结构，在V型结构的两个父结点之间加上一条无向边</li>
      <li>将所有有向边改为无向边</li>
    </ul>
  </li>
  <li>这样产生的无向图称为道德图。基于道德图能直观、迅速地找到变量间的条件独立性。假定道德图中有变量x, y和变量集合z={$z_i$}，若变量x和y能在图上被z分开，即从道德图中将变量集合z去除后，x和y分属两个连通分支，则称变量x和y被z有向分离，x⊥y|z成立</li>
</ul>

<h3 id="752-学习">7.5.2. 学习</h3>
<ul>
  <li>若网络结构已知，即属性间的依赖关系已知，则贝叶斯网的学习过程相对简单，只需要通过对训练样本计数，估计出每个结点的条件概率表即可。但在现实应用中我们往往并不知晓网络结构，于是，贝叶斯网学习的首要任务就是根据训练数据集来找出结构最”恰当”的贝叶斯网。”评分搜索”是求解这一问题的常用办法。具体来说，我们先定义一个评分函数(score function)，以此来评估贝叶斯网与训练数据的契合程度，然后基于这个评分函数来寻找结构最优的贝叶斯网。显然，评分函数引入了关于我们希望获得什么样的贝叶斯网的归纳偏好</li>
  <li>细节参见书中</li>
</ul>

<h3 id="753-推断">7.5.3. 推断</h3>
<ul>
  <li>贝叶斯网训练好之后就能用来回答”查询”(query)，即通过一些属性变量的观测值来推测其他属性变量的取值。例如在西瓜问题中，若我们观测到西瓜色泽青绿、敲声烛响、根蒂蜷缩，想知道它是否成熟、甜度如何。这样通过已知变量观测值来推测待查询变量的过程称为”推断”(inference)，已知变量观测值称为”证据” (evidence)</li>
  <li>最理想的是直接根据贝叶斯网定义的联合概率分布来精确计算后验概率，不幸的是，这样的精确推断已被证明是NP难，在现实应用中，贝叶斯网的近似推断常使用吉布斯采样来完成</li>
</ul>

<h2 id="76-em算法">7.6. EM算法</h2>
<ul>
  <li>在前面的讨论中，我们一直假设训练样本所有属性变量的值都已被观测到，即训练样本是完整的，但在现实应用中往往会遇到不完整的训练样本，在这种存在未观测变量的情形下，是否仍能对模型参数进行估计呢？未观测变量的学名是隐变量(latent variable)</li>
  <li>令X表示已观测变量集，Z表示隐变量集，$\Theta$表示模型参数，若欲对$\Theta$做极大似然估计，则应最大化对数似然:</li>
</ul>

<center><img src="../assets/img/posts/20211222/159.jpg" /></center>

<ul>
  <li>然而由于Z是隐变量，上式无法直接求解，因此我们可通过对Z计算期望，来最大化已观测数据的对数边际似然(marginal likelihood)</li>
</ul>

<center><img src="../assets/img/posts/20211222/160.jpg" /></center>

<ul>
  <li><strong>EM(Expectation-Maximization)算法</strong>是常用的估计隐变量的利器，它是一种迭代式的方法。其基本想法是:若参数$\Theta$己知，则可根据训练数据推断出最优隐变量Z的值(E步);反之，若Z的值已知，则可方便地对参数$\Theta$做极大似然估计(M步)</li>
  <li>于是，以初始值$\Theta^0$为起点，可迭代执行以下步骤直至收敛:
    <ul>
      <li>基于$\Theta^t$推断隐变量Z的期望，记为$Z^t$;</li>
      <li>基于已观测变量X和$Z^t$对参数$\Theta$做极大似然估计，记为$\Theta^{t+1}$;</li>
    </ul>
  </li>
  <li>这就是EM算法的原型，进一步，若我们不是取Z的期望，而是基于$\Theta^t$计算隐变量Z的概率分布$P(Z|X,\Theta^t)$, 则算法的步骤为:</li>
</ul>

<center><img src="../assets/img/posts/20211222/161.jpg" /></center>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>注意这里的测试集其实是验证集，我们通常把实际情况中遇到的数据集称为测试集。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>满秩矩阵指方阵的秩等于矩阵的行数/列数，满秩矩阵有逆矩阵且对于y=Xb有唯一的解 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>统计学中，似然函数是一种关于统计模型参数的函数。给定输出x时，关于参数θ的似然函数L(θ|x)（在数值上）等于给定参数θ后变量X的概率：L(θ|x)=P(X=x|θ)。 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>随机变量的期望组成的向量称为期望向量或者均值向量 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>协方差矩阵的每个元素是各个向量元素之间的协方差。协方差就是Covariance <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>二次规划(Quadratic Programming)是一种典型的优化问题，在此类问题中，目标函数是变量的二次函数，而约束条件是变量的线性不等式，假定变量个数为d，约束条件的个数为m，则标准的二次规划问题形如: <center><img src="../assets/img/posts/20211222/85.jpg" /></center> 其中x为d维向量，Q为实对称矩阵，A为实矩阵，若Q为半正定矩阵，则目标函数为凸函数，相应的二次规划是凸二次优化问题。半正定矩阵即满足: A是n阶方阵，如果对任何非零向量X，都有X’AX≥0，其中X’表示X的转置，就称A为半正定矩阵。正定矩阵定义类似，只是把大于等于变成大于。此时若约束条件Ax≤b定义的可行域不为空，且目标函数在此可行域有下界，则该问题将有全局最小值。若Q为正定矩阵，则该问题有唯一全局最小值 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>拉格朗日乘子法是一种寻找多元函数在一组约束下的极值的方法，通过引入拉格朗日乘子, 可将d个变量与k个约束条件的最优化问题转化为具有d+k个变量的无约束优化问题求解。首先考虑等式约束的优化问题，假定x为d维向量，欲寻找x的某个取值$x^*$, 使目标函数f(x)最小且同时满足g(x)=0的约束，从几何角度看，该问题的目标是在由方程g(x)=0确定的d-1维曲面上寻找能使目标函数f(x)最小化的点，此时不难得到如下结论: 1.对于约束曲面上的任意点x, 该点的梯度▽g(x)正交于约束曲面; 2.在最优点$x^*$，目标函数在该点的梯度▽f($x^*$)正交于约束曲面<center><img src="../assets/img/posts/20211222/86.jpg" /></center> 由此可知，在最优点$x^*$，存在$\lambda$≠0使得<center><img src="../assets/img/posts/20211222/87.jpg" /></center>$\lambda$称为拉格朗日算子，定义拉格朗日函数<center><img src="../assets/img/posts/20211222/88.jpg" /></center>现在考虑不等式约束g(x)≤0,如图所示<center><img src="../assets/img/posts/20211222/89.jpg" /></center> 此时最优点$x^*$或在g(x)&lt;0的区域中，或在边界g(x)=0上。对于g(x)&lt;0的情形，约束g(x)≤0不起作用，可直接通过条件▽f(x)=0来获得最优点，这相当于将$\lambda$置零，g(x)=0的情形类似于上面等式约束的分析。因此，在约束g(x)≤0下最小化f(x)，可转化为在如下约束下最小化拉格朗日函数: <center><img src="../assets/img/posts/20211222/90.jpg" /></center>上述约束条件称为KTT条件。一个优化问题可以从两个角度来考察，即主问题和对偶问题，主问题就是没有引入拉格朗日乘子的原始目标函数，对偶问题就是加上了拉格朗日乘子的目标函数，这个目标函数是原始目标函数的最优值的一个下界，所以我们希望找到最好的下界，也就是最大的下界，所以对偶函数是寻找最大值 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>提到后验概率，不得不提到先验概率，先验概率是根据以往经验和分析得到的概率，而后验概率可以视为条件概率，它可以通过贝叶斯公式算出 <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>它是建立在极大似然原理的基础上的一个统计方法，极大似然原理的直观想法是，一个随机试验如有若干个可能的结果A，B，C，…，若在一次试验中，结果A出现了，那么可以认为实验条件对A的出现有利，也即出现的概率P(A)较大。极大似然原理的直观想法我们用下面例子说明。设甲箱中有99个白球，1个黑球；乙箱中有1个白球．99个黑球。现随机取出一箱，再从抽取的一箱中随机取出一球，结果是黑球，这一黑球从乙箱抽取的概率比从甲箱抽取的概率大得多，这时我们自然更多地相信这个黑球是取自乙箱的。一般说来，事件A发生的概率与某一未知参数$\theta$有关，$\theta$取值不同，则事件A发生的概率$P(A|\theta)$也不同，当我们在一次试验中事件A发生了，则认为此时的$\theta$值应是t的一切可能取值中使$P(A|\theta)$达到最大的那一个，极大似然估计法就是要选取这样的t值作为参数t的估计值，使所选取的样本在被选的总体中出现的可能性为最大 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

        <aside class="sidebar inline" id="post-end">
    



<div class="tag-cloud">
    
        <ul class="tags inline">
            
                <li><a href="./tag.html?tag=note" class="tag inline">note</a></li>
            
    
        </ul>
</div>
    <div class="share-options inline">
    <div class="share-hover inline">
        <span class="share-button inline"><svg fill="currentColor" width="25" height="25" class="inline"><g fill-rule="evenodd"><path d="M15.6 5a.42.42 0 0 0 .17-.3.42.42 0 0 0-.12-.33l-2.8-2.79a.5.5 0 0 0-.7 0l-2.8 2.8a.4.4 0 0 0-.1.32c0 .12.07.23.16.3h.02a.45.45 0 0 0 .57-.04l2-2V10c0 .28.23.5.5.5s.5-.22.5-.5V2.93l2.02 2.02c.08.07.18.12.3.13.11.01.21-.02.3-.08v.01"></path><path d="M18 7h-1.5a.5.5 0 0 0 0 1h1.6c.5 0 .9.4.9.9v10.2c0 .5-.4.9-.9.9H6.9a.9.9 0 0 1-.9-.9V8.9c0-.5.4-.9.9-.9h1.6a.5.5 0 0 0 .35-.15A.5.5 0 0 0 9 7.5a.5.5 0 0 0-.15-.35A.5.5 0 0 0 8.5 7H7a2 2 0 0 0-2 2v10c0 1.1.9 2 2 2h11a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2"></path></g></svg></span>
        <div class="share-icons inline" id="post-end-icons">
            <a class="twitter" href="https://twitter.com/intent/tweet?text=机器学习&url=http://localhost:4000/Machine-Learning.html" title="Share on Twitter" rel="nofollow" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a>
            <a class="facebook" href="https://facebook.com/sharer.php?u=http://localhost:4000/Machine-Learning.html" title="Share on Facebook" rel="nofollow" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i></a>
            <a class="reddit" href="http://www.reddit.com/submit?url=http://localhost:4000/Machine-Learning.html&title=机器学习" title="Submit to Reddit" rel="nofollow" target="_blank"><i class="fa fa-reddit" aria-hidden="true"></i></a>
            <a class="linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/Machine-Learning.html&title=机器学习&summary=《机器学习》周志华读书笔记&source=http://localhost:4000/Machine-Learning.html" title="Share on LinkedIn" rel="nofollow" target="_blank"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
            <a class="email" href="mailto:?subject=机器学习&body=《机器学习》周志华读书笔记%0A%0ARead more here: http://localhost:4000/Machine-Learning.html" title="Share via e-mail" rel="nofollow" target="_blank"><i class="fa fa-envelope" aria-hidden="true"></i></a>
            <a class="copy-link" onclick="copyToClipboard()" title="Copy to clipboard" rel="nofollow" target="_blank"><svg width="20px" fill="currentColor" class="inline" viewBox="0 0 18 18"><path d="M16.94 1.1A3.7 3.7 0 0 0 14.3 0c-1 0-1.94.39-2.64 1.1L7.43 5.3c-.91.92-2.09 3.2 0 5.27a.75.75 0 0 0 .82.16c.09-.03.17-.09.24-.15a.74.74 0 0 0 0-1.06c-1.16-1.15-.77-2.39-.02-3.16l4.24-4.22a2.2 2.2 0 0 1 1.58-.65c.6 0 1.16.23 1.58.65.86.87.86 2.29 0 3.16L12.7 8.47a.74.74 0 0 0 1.04 1.05l3.17-3.16a3.73 3.73 0 0 0 0-5.27h.03zM9.54 7.4a.74.74 0 0 0 0 1.06c1.16 1.15.76 2.39 0 3.16l-4.22 4.22c-.42.42-.99.65-1.59.65a2.23 2.23 0 0 1-1.58-3.82l3.17-3.16A.73.73 0 0 0 5.54 9a.78.78 0 0 0-.22-.52.77.77 0 0 0-1.05 0L1.1 11.64A3.72 3.72 0 0 0 3.74 18c1 0 1.94-.39 2.65-1.1l4.23-4.2c.21-.22.94-1.02 1.13-2.2.18-1.12-.2-2.15-1.12-3.07-.27-.27-.78-.27-1.06 0l-.02-.02z" clip-rule="evenodd" fill-rule="evenodd"></path></svg></a>
        </div>
    </div>
    <div class='alert' style='font-size:.6em;color:var(--accent);text-align:center;'></div>
</div>
</aside>

        <div class="separator"></div>
        



<section class="author-box">
  <div class="narrow-column">
    <a href='https://quehry.github.io'><img src="./assets/img/Dog.jpg" alt="Quehry" class="author-img"></a>
    <ul class="contact-icons">
      
      <li class="twitter"><a class="twitter" href="https://twitter.com/@QuehryS" target="_blank"><i class="fa fa-twitter"></i></a></li>
      
      
      <li class="linkedin"><a class="linkedin" href="https://in.linkedin.com/in/quehry" target="_blank"><i class="fa fa-linkedin"></i></a></li>
      
      
      <li class="github"><a class="github" href="http://github.com/Quehry" target="_blank"><i class="fa fa-github"></i></a></li>
      
      
      <li class="email"><a class="email" href="mailto:quehry@gmail.com"><i class="fa fa-envelope-o"></i></a></li>
      
    </ul>
  </div>
  <div class="author-desc">
    <h3>Quehry</h3>
    <p>Student</p>
  </div>
</section>

        



<div class="recent-box">
  <h2 class="page-subtitle">Recent posts</h2>
  <div class="recent-list">
    
      
        <div class="recent-item">
          
          

          <a href="./%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%E4%BC%9A%E7%AC%94%E8%AE%B0.html" class="recent-item-img" style="background: url('./assets/img/posts/20220919/1.jpg') center no-repeat; background-size: cover;">
            <div class="recent-item-title">
              <span>技术分享会笔记(关于text2image)</span>
              

  <span class = "recent-item-meta">
  
  
  
  
    
    
    <p class="page_meta-readtime">
      
        less than 1 minute read
      
    </p>
  
  
  </span>

            </div>
          </a>
        </div>
      
    
      
        <div class="recent-item">
          
          

          <a href="./T5%E6%A8%A1%E5%9E%8B.html" class="recent-item-img" style="background: url('./assets/img/posts/20220919/2.jpg') center no-repeat; background-size: cover;">
            <div class="recent-item-title">
              <span>T5模型</span>
              

  <span class = "recent-item-meta">
  
  
  
  
    
    
    <p class="page_meta-readtime">
      
        1 minute read
      
    </p>
  
  
  </span>

            </div>
          </a>
        </div>
      
    
      
        <div class="recent-item">
          
          

          <a href="./%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0.html" class="recent-item-img" style="background: url('./assets/img/posts/20220905/1.jpg') center no-repeat; background-size: cover;">
            <div class="recent-item-title">
              <span>动手学深度学习</span>
              

  <span class = "recent-item-meta">
  
  
  
  
    
    
    <p class="page_meta-readtime">
      
        2 minute read
      
    </p>
  
  
  </span>

            </div>
          </a>
        </div>
      
    
      
        <div class="recent-item">
          
          

          <a href="./Web%E9%80%9F%E6%88%90.html" class="recent-item-img" style="background: url('./assets/img/posts/20220803/1.jpg') center no-repeat; background-size: cover;">
            <div class="recent-item-title">
              <span>Web速成</span>
              

  <span class = "recent-item-meta">
  
  
  
  
    
    
    <p class="page_meta-readtime">
      
        less than 1 minute read
      
    </p>
  
  
  </span>

            </div>
          </a>
        </div>
      
    
  </div>
</div> <!-- End Recent-Box -->

        <div class="newsletter" id="mc_embed_signup">
  <h2 class="page-subtitle">Newsletter</h2>
  <div class="form-container">
    <p>Subscribe here to get our latest updates</p>
    <form action="https://github.us1.list-manage.com/subscribe/post?u=8ece198b3eb260e6838461a60&amp;id=397d90b5f4" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
      <label class="screen-reader-text" for="mce-EMAIL">Email Address</label>
      <div class="newsletter-box" id="mc_embed_signup_scroll">
        <input type="email" name="EMAIL" placeholder="Email address" class="email-input" id="mce-EMAIL" required>
        <input type="submit" value="Subscribe" name="subscribe" class="subscribe-btn" id="mc-embedded-subscribe">
      </div>
    </form>
  </div>
</div> <!-- End Newsletter -->

        
  <section class="comment-area">
    <div class="comment-wrapper">
        
            <div class="row" id="comment-curtain">
                <div class="col-lg-8 col-sm-10 mr-auto ml-auto">
                    <h2 class="page-subtitle">Comments</h2>
                    <div class="comments-trigger" onClick="toggle_comments()">
                        <i class="fa fa-comments"></i>&nbsp;&nbsp;Write a comment ...
                    </div>
                </div>
            </div>
        
      <div id="disqus_thread"></div>
          <script>
            (function() {
                var d = document, s = d.createElement('script');
                s.src = '//amaynez-github-io.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
          </script>
      <noscript>Please enable JavaScript to view the comments.</noscript>
    </div>
  </section> <!-- End Comment Area -->


      </div>
    </div> <!-- End Wrapper -->
  </article>
  <div class="search-box">
  <div class="wrapper">
    <div class="search-grid">
      <form class="search-form">
        <div id="search-container">
          <input type="text" id="search-input" class="search" placeholder="Search">
        </div>
      </form>
      <ul id="results-container" class="results-search"></ul>
      <div class="icon-close-container">
        <span class="search-icon-close"><i class="fa fa-times" aria-hidden="true"></i></span>
      </div>
    </div>
  </div>
</div>

  




<footer class="main-footer">
    <div class="footer-wrapper">
        <div class="logo-symbol">
            <a class="logo-link" title="Quehry" href="./">
                <svg width="45px" height="45px" class="logo-symbol" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet" version="1.0" viewBox="0 0 649 649"><g fill="currentColor" stroke="none"><path d="M2938 6380 c-551 -53 -1031 -220 -1478 -514 -306 -201 -588 -470 -810 -771 -276 -374 -475 -850 -559 -1336 -64 -371 -53 -836 29 -1211 155 -712 552 -1347 1130 -1810 450 -360 1021 -589 1640 -659 58 -6 202 -12 320 -12 282 0 503 26 756 87 902 220 1680 841 2079 1661 303 622 402 1333 279 2005 -90 496 -313 984 -634 1390 -111 140 -378 404 -519 513 -456 352 -957 560 -1549 643 -126 17 -558 26 -684 14z m687 -220 c77 -11 189 -32 250 -46 127 -29 345 -94 345 -103 0 -4 -341 -188 -757 -409 l-757 -403 -41 22 c-22 13 -58 26 -79 29 l-40 5 -148 370 c-82 204 -150 377 -153 386 -10 29 325 119 570 153 169 24 174 24 430 21 183 -3 273 -8 380 -25z m-1292 -546 l157 -387 -24 -28 c-13 -16 -30 -44 -36 -64 -6 -19 -17 -35 -23 -35 -7 -1 -382 -54 -834 -119 -453 -64 -823 -115 -823 -111 0 3 43 62 95 132 269 358 584 630 980 844 90 49 321 153 341 154 6 0 81 -174 167 -386z m2026 347 l37 -20 129 -440 128 -440 -35 -39 c-20 -22 -37 -44 -39 -50 -3 -8 -290 13 -929 66 -775 65 -925 80 -928 92 -2 11 223 134 785 432 433 228 794 416 801 417 7 0 30 -8 51 -18z m204 -92 c420 -211 850 -600 1137 -1027 34 -51 60 -95 57 -98 -4 -4 -805 157 -859 172 -10 3 -18 12 -18 21 0 58 -78 133 -137 133 -18 0 -33 2 -33 5 0 3 -52 184 -116 403 -63 218 -117 405 -120 415 -3 9 -3 17 1 17 3 0 42 -19 88 -41z m-913 -894 c494 -41 904 -75 912 -75 7 -1 24 -23 36 -51 l24 -50 -169 -269 -168 -270 -44 0 c-24 0 -63 -9 -86 -21 l-42 -21 -679 402 c-373 222 -688 409 -699 416 -18 13 -18 14 -1 14 10 0 422 -34 916 -75z m-1175 18 l48 -48 -31 -225 c-18 -124 -60 -417 -94 -652 l-62 -428 -44 0 c-24 0 -51 -4 -61 -10 -16 -8 -146 87 -777 566 -418 317 -761 578 -763 580 -3 3 0 9 5 14 8 8 1633 247 1700 249 25 1 42 -9 79 -46z m915 -414 l690 -411 0 -38 0 -37 -147 -46 c-82 -26 -453 -148 -825 -271 l-676 -223 -22 30 -22 29 98 669 c82 557 101 669 114 669 8 0 31 9 50 19 19 11 38 20 43 20 4 1 318 -184 697 -410z m1959 175 c251 -53 457 -97 457 -98 9 -9 123 -247 153 -320 113 -272 189 -599 209 -901 l9 -130 -231 -273 c-224 -265 -232 -273 -264 -270 l-34 3 -418 1013 -419 1013 26 30 c15 16 33 29 41 29 8 0 220 -43 471 -96z m-593 2 c6 -5 804 -1949 802 -1952 -2 -2 -274 272 -605 609 l-600 612 13 32 c20 46 17 82 -9 128 l-23 41 170 271 171 272 40 -6 c22 -3 41 -6 41 -7z m-3341 -611 c402 -307 733 -561 737 -564 31 -26 -38 -31 -947 -65 -516 -19 -941 -33 -944 -30 -2 2 6 77 18 165 49 346 162 693 324 986 44 82 52 91 66 79 9 -7 345 -264 746 -571z m2710 -142 c17 -16 39 -32 48 -38 15 -9 13 -64 -23 -695 -22 -377 -40 -686 -40 -687 0 -2 -8 -3 -19 -3 -10 0 -30 -9 -45 -21 l-27 -21 -342 200 c-188 110 -542 317 -787 460 -245 144 -445 266 -445 273 0 8 312 116 820 285 451 150 822 272 824 273 2 1 18 -11 36 -26z m590 -425 c220 -222 500 -505 623 -629 l223 -225 -17 -31 -18 -30 -585 -82 c-322 -45 -602 -85 -621 -88 -31 -4 -37 -1 -53 27 -11 17 -34 39 -53 47 -19 9 -34 21 -34 27 -1 6 16 316 37 688 l37 678 26 9 c14 5 27 10 30 10 3 1 185 -180 405 -401z m-2587 -114 c-2 -9 -224 -178 -494 -375 l-492 -359 -38 16 c-26 11 -53 14 -84 10 -25 -3 -55 -7 -67 -8 -16 -2 -106 76 -362 316 -204 192 -341 327 -341 338 0 16 10 18 83 19 45 0 431 13 857 28 984 36 942 35 938 15z m59 -88 l22 -23 -104 -467 c-58 -256 -105 -468 -105 -470 0 -2 -14 -6 -32 -10 -17 -3 -47 -18 -65 -32 l-34 -26 -339 122 -338 122 -7 45 c-5 37 -3 47 12 58 10 7 229 169 488 359 258 190 472 346 475 346 3 0 15 -11 27 -24z m1013 -430 c421 -245 769 -452 775 -460 5 -8 7 -18 3 -21 -3 -4 -417 -41 -920 -84 l-913 -77 -16 26 c-9 15 -29 36 -45 47 l-28 21 104 465 105 465 43 7 c27 4 55 17 75 35 18 16 37 28 42 26 6 -2 354 -204 775 -450z m-2307 -276 c-7 -71 -4 -98 10 -126 l15 -30 -206 -248 -206 -248 -27 59 c-140 314 -228 733 -229 1086 l0 138 323 -303 c270 -254 322 -307 320 -328z m5277 366 c-17 -270 -58 -489 -135 -721 -38 -117 -134 -350 -140 -343 -1 2 -35 117 -75 256 l-72 253 26 25 c51 52 58 134 15 189 -21 26 -21 26 -2 48 11 12 102 120 203 240 100 120 184 216 186 214 2 -2 -1 -74 -6 -161z m-642 -487 l21 -41 -456 -782 c-251 -429 -461 -787 -467 -794 -9 -9 -19 -10 -42 -2 l-29 10 -174 676 -174 675 35 37 c20 20 40 51 45 67 l10 30 584 82 c321 44 594 82 605 82 16 1 27 -10 42 -40z m-4015 -145 c301 -109 327 -120 327 -142 0 -12 7 -39 15 -58 l15 -36 -411 -469 c-226 -259 -413 -468 -415 -466 -2 2 1 219 6 483 5 263 10 538 10 610 l0 132 29 12 c16 6 39 23 52 36 13 14 28 23 34 21 5 -2 157 -57 338 -123z m-517 -413 c-3 -262 -9 -527 -12 -589 -8 -134 -2 -135 -120 20 -93 121 -192 278 -272 428 l-61 115 215 257 c181 216 218 255 235 251 l22 -6 -7 -476z m4695 460 c3 -3 43 -133 88 -289 l82 -282 -62 -108 c-75 -130 -175 -278 -265 -392 -140 -176 -514 -528 -595 -558 -13 -5 -72 -13 -130 -17 l-105 -7 -16 40 -16 40 462 796 461 796 45 -6 c25 -4 48 -9 51 -13z m-1736 -69 c-6 -5 -361 -192 -790 -417 -429 -224 -806 -422 -838 -439 -52 -28 -59 -29 -70 -15 -17 22 -78 59 -99 59 -19 0 -16 -14 -68 300 -29 169 -38 246 -30 248 27 9 62 50 74 87 11 32 19 41 43 44 67 8 1683 139 1733 140 30 0 50 -3 45 -7z m90 -62 c10 -11 38 -26 62 -31 38 -10 44 -16 52 -48 90 -346 333 -1280 337 -1292 3 -11 -7 -23 -29 -36 -19 -11 -42 -38 -53 -60 l-19 -40 -1050 297 c-859 244 -1050 301 -1050 315 0 12 239 141 860 465 473 247 863 449 866 449 3 1 14 -8 24 -19z m-2076 -210 c13 0 21 -9 25 -27 10 -47 86 -497 86 -508 0 -5 -13 -19 -29 -29 -35 -24 -57 -59 -66 -108 -4 -22 -14 -39 -24 -42 -143 -41 -861 -236 -870 -236 -7 0 -11 5 -9 11 2 6 190 224 418 484 349 399 416 472 431 464 10 -5 27 -9 38 -9z m1376 -1065 c741 -208 1053 -300 1060 -312 6 -9 24 -32 41 -52 l31 -35 -30 -68 c-34 -77 -25 -71 -205 -139 -310 -116 -653 -180 -984 -183 -97 0 -178 1 -181 4 -89 106 -817 1053 -817 1063 0 18 9 27 23 21 7 -2 485 -137 1062 -299z m-1319 264 c31 -35 81 -51 134 -44 l46 6 380 -487 c208 -268 385 -496 392 -506 13 -17 10 -18 -45 -12 -640 65 -1267 346 -1732 776 l-61 57 42 12 c271 74 805 218 814 218 6 1 19 -9 30 -20z m2814 -563 c0 -5 -223 -138 -278 -165 -24 -13 -46 -20 -49 -18 -2 3 3 19 11 36 12 22 27 33 59 42 27 7 56 26 81 52 35 37 44 41 105 47 36 4 67 8 69 9 1 0 2 -1 2 -3z" transform="translate(0.000000,644.000000) scale(0.100000,-0.100000)"/></g></svg>
            </a>
        </div>
        <div class="copyright">
          <p>2022 &copy; Quehry</p>
        </div>
        <div class="footer-nav">
            <div>
                <a href="./archive.html">
                    Posts
                </a>
            </div>
            <div>
                <a href="./tags.html">
                    Tags
                </a>
            </div>
            <div>
                <a href="./about.html">
                    About
                </a>
            </div>
        </div>
    </div>
</footer> <!-- End Footer -->

</div>

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

<style>
  table {
  margin: auto;
  }
</style>
    <div class="top" title="Top">
      <svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="angle-up" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512" class="svg-inline--fa fa-angle-up fa-w-8 fa-2x"><path fill="currentColor" d="M136.5 185.1l116 117.8c4.7 4.7 4.7 12.3 0 17l-7.1 7.1c-4.7 4.7-12.3 4.7-17 0L128 224.7 27.6 326.9c-4.7 4.7-12.3 4.7-17 0l-7.1-7.1c-4.7-4.7-4.7-12.3 0-17l116-117.8c4.7-4.6 12.3-4.6 17 .1z" class=""></path></svg>
    </div>
    




<!-- JS -->








<script>
(function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var logo = document.getElementById('logo');
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
    storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
    var data = storage.getItem('theme');
    try {
        data = JSON.parse(data ? data : '');
    } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
    }
    return data;
    }

    function handleThemeToggle(nightShift) {
    themeData.nightShift = nightShift;
    saveThemeData(themeData);
    html.dataset.theme = nightShift ? 'dark' : 'light';
    if (nightShift) {
        logo.setAttribute("src", "./assets/img/branding/MVM-logo-full-dark.svg");
    } else {
        logo.setAttribute("src", "./assets/img/branding/MVM-logo-full.svg");
    }
    setTimeout(function() {
        sw.checked = nightShift ? true : false;
    }, 50);
    }

    function autoThemeToggle() {
    // Next time point of theme toggle
    var now = new Date();
    var toggleAt = new Date();
    var hours = now.getHours();
    var nightShift = hours >= 19 || hours <=7;

    if (nightShift) {
        if (hours > 7) {
        toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
    } else {
        toggleAt.setHours(19);
    }

    toggleAt.setMinutes(0);
    toggleAt.setSeconds(0);
    toggleAt.setMilliseconds(0)

    var delay = toggleAt.getTime() - now.getTime();

    // auto toggle theme mode
    setTimeout(function() {
        handleThemeToggle(!nightShift);
    }, delay);

    return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
    };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
    handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
    var data = autoThemeToggle();

    // Toggle theme by local setting
    if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
    } else {
        handleThemeToggle(themeData.nightShift);
    }
    } else if (nightModeOption == 'manual') {
    handleThemeToggle(themeData.nightShift);
    } else {
    var nightShift = themeData.nightShift;
    if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
    }
    handleThemeToggle(nightShift);
    }
})();
</script>

<script src="./assets/js/jekyll-search.js"></script>
<script src="./assets/js/jquery-3.6.0.min.js"></script>







<script src="./assets/js/main.js"></script>
<script>
  SimpleJekyllSearch({
      searchInput: document.getElementById('search-input'),
      resultsContainer: document.getElementById('results-container'),
      json: './search.json',
      searchResultTemplate: '<li><a href="{url}" title="{description}">{title}</a><p>{description}</p></li>',
      noResultsText: 'No results found',
      fuzzy: false,
      exclude: ['Welcome']
    });
</script>




    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R8SZS2YBZK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R8SZS2YBZK');
</script>
  </body>
</html>
