I"<!-- TOC -->

<ul>
  <li><a href="#1-推荐系统总览">1. 推荐系统总览</a>
    <ul>
      <li><a href="#11-协同过滤-collaborative-filtering">1.1. 协同过滤 Collaborative Filtering</a></li>
      <li><a href="#12-显式反馈和隐式反馈">1.2. 显式反馈和隐式反馈</a></li>
      <li><a href="#13-推荐任务">1.3. 推荐任务</a></li>
    </ul>
  </li>
  <li><a href="#2-矩阵分解-matrix-factorization">2. 矩阵分解 Matrix Factorization</a></li>
  <li><a href="#3-autorec">3. AutoRec</a>
    <ul>
      <li><a href="#31-overview">3.1. overview</a></li>
      <li><a href="#32-formula">3.2. formula</a></li>
    </ul>
  </li>
  <li><a href="#4-personalized-ranking-for-recommender-system">4. Personalized Ranking for Recommender System</a></li>
</ul>

<!-- /TOC -->

<h2 id="1-推荐系统总览">1. 推荐系统总览</h2>
<h3 id="11-协同过滤-collaborative-filtering">1.1. 协同过滤 Collaborative Filtering</h3>
<p>协同过滤最早出现在1992年Tapestry system，“人们相互协作，相互帮助，执行过滤程序，以处理大量的电子邮件和张贴到新闻组的信息。”现在协同过滤的概念更加广泛，从广义上讲，它是利用涉及多个用户、代理和数据源之间协作的技术来过滤<strong>信息或模式</strong>的过程。</p>

<p>协同过滤模型可以分为:1.memory-based CF; 2.model-based CF. 其中Memory-based CF又可以分为item-based和user-based CF。model-based CF有矩阵分解模型。</p>

<p>总的来说，协同过滤就是利用用户-物品的数据来预测和推荐。</p>

<h3 id="12-显式反馈和隐式反馈">1.2. 显式反馈和隐式反馈</h3>
<p>为了学习用户的偏好，系统需要收集用户的反馈feedback。反馈可以分为显式和隐式。</p>

<p>显式反馈就是需要用户主动提供兴趣偏好。比如点赞、点踩。</p>

<p>隐式反馈则是间接反映用户的喜好，比如购物历史记录，浏览记录，观看记录甚至是鼠标移动。</p>

<h3 id="13-推荐任务">1.3. 推荐任务</h3>
<p>电影推荐、新闻推荐、评分预测rating prediction task、top-n reommendation。如果使用了时间戳信息，那么我们构建了sequence-aware recommendation。针对新用户推荐新物品称为cold-start recommendation冷启动推荐。</p>

<h2 id="2-矩阵分解-matrix-factorization">2. 矩阵分解 Matrix Factorization</h2>
<p>The Matrix Factorization Model矩阵分解模型</p>

<p>R是user-item矩阵，行数是用户数量，列数是物品数量,那么R∈R<sup>mxn</sup>。P是user latent matrix，P∈R<sup>mxk</sup>，Q是item latent matrix，Q∈R<sup>nxk</sup></p>

<p>矩阵分解就是把R分解成P和Q，那么预测的评分就是：</p>

<p><img src="../assets/img/posts/20211216/2.jpg" /></p>

<p>但是上面这个式子没有考虑偏置，我们会有下面这个完整的式子：</p>

<p><img src="../assets/img/posts/20211216/3.jpg" /></p>

<p>那么<strong>目标函数</strong>可以定义为：</p>

<p><img src="../assets/img/posts/20211216/4.jpg" /></p>

<p>右边那一串是正则项，为了避免过拟合</p>

<p>下面这张图值观的展示了矩阵分解过程：</p>

<p><img src="../assets/img/posts/20211216/5.jpg" /></p>

<h2 id="3-autorec">3. AutoRec</h2>
<h3 id="31-overview">3.1. overview</h3>
<p>使用autoencoder预测评分，上小节介绍的矩阵分解模型是线性模型，它不能捕捉复杂的非线性关系，比如用户的偏好。这一小节介绍一个非线性协同过滤神经网络模型AutoRec。</p>

<p>AutoRec是基于自编码器的结构，自编码器是一种特殊的神经网络架构，他的输入和输出的架构是相同的，自编码器通过无监督学习来训练获取输入数据在较低维度的表达，在神经网络的后段，这些低纬度的信息再次被重构回高维的数据表达。</p>

<p>所以AutoRec的架构也是输入层，隐藏层和重构输出层。它的目的是输入一个只有部分兴趣矩阵，输出一个完整的兴趣矩阵。</p>

<p>AutoRec可以分为user-based 和 item-based</p>

<h3 id="32-formula">3.2. formula</h3>
<p>针对item-based：</p>

<p>$R_{*i}$表示兴趣矩阵的第i列，不知道的项填为0。那么神经网络的构架可以定义为：</p>

<center><img src="../assets/img/posts/20211216/6.jpg" /></center>

<p>h()表示最终的输出，输出一个完整的兴趣矩阵，那么误差定义为：</p>

<center><img src="../assets/img/posts/20211216/7.jpg" /></center>

<h2 id="4-personalized-ranking-for-recommender-system">4. Personalized Ranking for Recommender System</h2>
<p>在上一节中，我们用到了显式反馈，同时模型只在能观察到的评分上训练。那么这种模型有两个缺点：第一个是很多的反馈并不是显式的。第二个是没有观察到的评分被完全忽略了。</p>

:ET