I"E<h1 id="目录">目录</h1>
<!-- TOC -->

<ul>
  <li><a href="#目录">目录</a></li>
  <li><a href="#0-简介">0. 简介</a></li>
  <li><a href="#1-第一周-枚举">1. 第一周 枚举</a>
    <ul>
      <li><a href="#11-完美立方">1.1. 完美立方</a></li>
      <li><a href="#12-生理周期">1.2. 生理周期</a></li>
      <li><a href="#13-称硬币">1.3. 称硬币</a></li>
      <li><a href="#14-熄灯问题">1.4. 熄灯问题</a></li>
    </ul>
  </li>
  <li><a href="#2-第二周-递归一">2. 第二周 递归(一)</a>
    <ul>
      <li><a href="#21-求阶乘">2.1. 求阶乘</a></li>
      <li><a href="#22-汉诺塔问题">2.2. 汉诺塔问题</a></li>
      <li><a href="#23-n皇后问题">2.3. n皇后问题</a></li>
      <li><a href="#24-逆波兰表达式求值">2.4. 逆波兰表达式求值</a></li>
    </ul>
  </li>
  <li><a href="#3-第三周-递归二">3. 第三周 递归(二)</a>
    <ul>
      <li><a href="#31-表达式求值">3.1. 表达式求值</a></li>
      <li><a href="#32-上台阶问题">3.2. 上台阶问题</a></li>
      <li><a href="#33-放苹果问题">3.3. 放苹果问题</a></li>
      <li><a href="#34-算24问题">3.4. 算24问题</a></li>
    </ul>
  </li>
  <li><a href="#4-第四周-二分算法">4. 第四周 二分算法</a>
    <ul>
      <li><a href="#41-程序或算法的时间复杂度">4.1. 程序或算法的时间复杂度</a></li>
      <li><a href="#42-二分查找的原理和实现">4.2. 二分查找的原理和实现</a></li>
      <li><a href="#43-二分法求方程的根">4.3. 二分法求方程的根</a></li>
    </ul>
  </li>
  <li><a href="#5-第五周-分治">5. 第五周 分治</a>
    <ul>
      <li><a href="#51-归并排序">5.1. 归并排序</a></li>
      <li><a href="#52-快速排序">5.2. 快速排序</a></li>
      <li><a href="#53-例题-输出前m大的数">5.3. 例题: 输出前m大的数</a></li>
      <li><a href="#54-例题-求排序的逆序数">5.4. 例题: 求排序的逆序数</a></li>
    </ul>
  </li>
  <li><a href="#6-第六周-动态规划一">6. 第六周 动态规划(一)</a>
    <ul>
      <li><a href="#61-数字三角形">6.1. 数字三角形</a></li>
      <li><a href="#62-动态规划解题的一般思路">6.2. 动态规划解题的一般思路</a></li>
    </ul>
  </li>
</ul>

<!-- /TOC -->

<h1 id="0-简介">0. 简介</h1>
<ul>
  <li>课程来源于北大郭炜老师的MOOC，在中国大学MOOC平台上有网课，课程名为<a href="https://www.icourse163.org/course/PKU-1001894005?tid=1450413466" target="_blank">程序设计与算法(二)算法基础</a>，选择第九次开课</li>
</ul>

<h1 id="1-第一周-枚举">1. 第一周 枚举</h1>

<h2 id="11-完美立方">1.1. 完美立方</h2>
<ul>
  <li>枚举: 基于逐个尝试答案的一种问题求解策略</li>
  <li>例如: 求小于N的最小素数</li>
  <li>完美立方:</li>
</ul>

<center><img src="../assets/img/posts/20220413/1.jpg" /></center>

<ul>
  <li>解题思路:</li>
</ul>

<center><img src="../assets/img/posts/20220413/2.jpg" /></center>

<h2 id="12-生理周期">1.2. 生理周期</h2>
<ul>
  <li>题干:</li>
</ul>

<center><img src="../assets/img/posts/20220413/3.jpg" /></center>

<center><img src="../assets/img/posts/20220413/4.jpg" /></center>

<ul>
  <li>解题思路:</li>
</ul>

<center><img src="../assets/img/posts/20220413/5.jpg" /></center>

<h2 id="13-称硬币">1.3. 称硬币</h2>
<ul>
  <li>题干:</li>
</ul>

<center><img src="../assets/img/posts/20220413/6.jpg" /></center>

<center><img src="../assets/img/posts/20220413/7.jpg" /></center>

<ul>
  <li>解题思路</li>
</ul>

<center><img src="../assets/img/posts/20220413/8.jpg" /></center>

<h2 id="14-熄灯问题">1.4. 熄灯问题</h2>
<ul>
  <li>题干:</li>
</ul>

<center><img src="../assets/img/posts/20220413/9.jpg" /></center>

<center><img src="../assets/img/posts/20220413/10.jpg" /></center>

<center><img src="../assets/img/posts/20220413/11.jpg" /></center>

<ul>
  <li>解题思路:</li>
</ul>

<center><img src="../assets/img/posts/20220413/12.jpg" /></center>

<center><img src="../assets/img/posts/20220413/13.jpg" /></center>

<p>局部的思想，化繁为简</p>

<ul>
  <li>可以用0-31的十进制数来表示第一列的数据，因为其二进制数刚好对应开关的状态</li>
</ul>

<h1 id="2-第二周-递归一">2. 第二周 递归(一)</h1>
<h2 id="21-求阶乘">2.1. 求阶乘</h2>
<ul>
  <li>递归的基本概念: 一个函数调用其自身就是递归</li>
</ul>

<center><img src="../assets/img/posts/20220413/14.jpg" /></center>

<ul>
  <li>递归和普通函数调用一样是通过栈实现</li>
</ul>

<center><img src="../assets/img/posts/20220413/15.jpg" /></center>

<ul>
  <li>递归的作用
    <ul>
      <li>替代多重循环</li>
      <li>解决本来就是递归形式定义的问题</li>
      <li>将问题分解为规模更小的问题进行求解: 比如n！变成n * (n-1)</li>
    </ul>
  </li>
</ul>

<h2 id="22-汉诺塔问题">2.2. 汉诺塔问题</h2>
<ul>
  <li>任务描述:</li>
</ul>

<center><img src="../assets/img/posts/20220413/16.jpg" /></center>

<ul>
  <li>解决思路: 把盘子从A移动到C的过程分解为三个小问题，分别是移动n-1个盘子从A到B，然后移动1个盘子从A到C，最后移动n-1个盘子从B到C，这就是一个递归问题</li>
  <li>递归的核心思想是将大问题分解为规模更小的问题，同时还要保证是从n变成n-1</li>
  <li>代码实现:</li>
</ul>

<center><img src="../assets/img/posts/20220413/17.jpg" /></center>
<p><br /></p>
<center><img src="../assets/img/posts/20220413/18.jpg" /></center>
<p><br /></p>

<h2 id="23-n皇后问题">2.3. n皇后问题</h2>
<ul>
  <li>问题描述:</li>
</ul>

<center><img src="../assets/img/posts/20220413/19.jpg" /></center>

<p>用递归代替多重循环，皇后的攻击范围是横竖斜</p>
<ul>
  <li>解决思路: 同样是从第1行开始逐个往后摆放，但是这里的n是未知数，所以循环的层数不确定，这个时候就可以用递归代替循环，构造一个函数，表示从第k行开始摆放棋子，然后在循环内部判断每一列的位置是否能摆放，就是一个穷举问题了</li>
  <li>代码实现:</li>
</ul>

<center><img src="../assets/img/posts/20220413/20.jpg" /></center>
<p><br /></p>
<center><img src="../assets/img/posts/20220413/21.jpg" /></center>
<p><br /></p>
<center><img src="../assets/img/posts/20220413/22.jpg" /></center>
<p><br /></p>

<p>这个代码设计很巧妙的地方是，它会遍历所有的情况，只要是满足条件的就会输出，所以会返回所有可能的结果</p>

<h2 id="24-逆波兰表达式求值">2.4. 逆波兰表达式求值</h2>
<ul>
  <li>问题描述:</li>
</ul>

<center><img src="../assets/img/posts/20220413/23.jpg" /></center>

<ul>
  <li>输入输出例子:</li>
</ul>

<center><img src="../assets/img/posts/20220413/24.jpg" /></center>

<ul>
  <li>解决思路: 一个数也可以看成一个逆波兰表达式，那么就可以直接用递归求解，实现过程中需要边输入边递归</li>
  <li>代码实现:</li>
</ul>

<center><img src="../assets/img/posts/20220413/25.jpg" /></center>

<h1 id="3-第三周-递归二">3. 第三周 递归(二)</h1>
<h2 id="31-表达式求值">3.1. 表达式求值</h2>
<ul>
  <li>问题描述:</li>
</ul>

<center><img src="../assets/img/posts/20220413/26.jpg" /></center>

<ul>
  <li>解决思路: 
先看看表达式递归的定义</li>
</ul>
<center><img src="../assets/img/posts/20220413/27.jpg" /></center>
<center><img src="../assets/img/posts/20220413/28.jpg" /></center>
<p>即然把表达式的递归过程弄清楚了，那么只需要定义表达式、项、因子的函数即可</p>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/29.jpg" /></center>
<center><img src="../assets/img/posts/20220413/30.jpg" /></center>
<center><img src="../assets/img/posts/20220413/31.jpg" /></center>
<center><img src="../assets/img/posts/20220413/32.jpg" /></center>

<h2 id="32-上台阶问题">3.2. 上台阶问题</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/33.jpg" /></center>
<ul>
  <li>输入输出样例:</li>
</ul>
<center><img src="../assets/img/posts/20220413/34.jpg" /></center>
<ul>
  <li>解决思路: 将n级台阶的走法看成n-1级台阶的走法+n-2级台阶的走法，分别代表在第一步走一阶还是两阶，这里需要设置边界条件来防止无限递归</li>
</ul>
<center><img src="../assets/img/posts/20220413/35.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/36.jpg" /></center>

<h2 id="33-放苹果问题">3.3. 放苹果问题</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/37.jpg" /></center>
<ul>
  <li>解决思路: 又是计算方法的总数，那么和上台阶问题一样，用表达式来表示递归，分类讨论。假设i个苹果，k个盘子，如果k&gt;i，那么等价于把i个苹果放到i个盘子里，因为一定有k-i个盘子空着；如果k&lt;=i，那么又将问题分为有没有空盘子，如果有空盘子，那么至少有一个空盘子，表示为把i个苹果放到k-1个盘子里，如果没有空盘子，那么等价于把i-k个苹果放到k个盘子里</li>
</ul>
<center><img src="../assets/img/posts/20220413/38.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/39.jpg" /></center>

<h2 id="34-算24问题">3.4. 算24问题</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/40.jpg" /></center>
<ul>
  <li>输入输出样例:</li>
</ul>
<center><img src="../assets/img/posts/20220413/41.jpg" /></center>
<ul>
  <li>判断两个浮点数是否相等，用两个浮点数的差是否小于某个值</li>
  <li>解决思路: 不论给了多少个数计算24，都需要首先计算出两个数的计算结果，这个计算过程可以是加减乘除任意，然后得到的结果再和剩下的n-1个数算24，这样就可以变成一个递归问题，边界条件是只剩一个数的时候是否是24</li>
</ul>
<center><img src="../assets/img/posts/20220413/42.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/43.jpg" /></center>
<center><img src="../assets/img/posts/20220413/44.jpg" /></center>
<center><img src="../assets/img/posts/20220413/45.jpg" /></center>
<center><img src="../assets/img/posts/20220413/46.jpg" /></center>

<h1 id="4-第四周-二分算法">4. 第四周 二分算法</h1>
<h2 id="41-程序或算法的时间复杂度">4.1. 程序或算法的时间复杂度</h2>
<ul>
  <li>时间复杂度的定义:</li>
</ul>
<center><img src="../assets/img/posts/20220413/47.jpg" /></center>
<p>重点是明白程序中固定的操作是什么</p>
<ul>
  <li>复杂度有平均复杂度和最坏复杂度两种，两者可能一致，也可能不一致，一般来说只要平均复杂度不太高，算法的效率就还可以</li>
  <li>常见的时间复杂度:</li>
</ul>
<center><img src="../assets/img/posts/20220413/48.jpg" /></center>
<center><img src="../assets/img/posts/20220413/49.jpg" /></center>

<h2 id="42-二分查找的原理和实现">4.2. 二分查找的原理和实现</h2>
<ul>
  <li>首先可以看这么一个问题:</li>
</ul>
<center><img src="../assets/img/posts/20220413/50.jpg" /></center>
<ul>
  <li>二分查找的实现: 时间复杂度是O(log(n))</li>
</ul>
<center><img src="../assets/img/posts/20220413/51.jpg" /></center>
<ul>
  <li>查找比待查找数小的最大坐标的函数实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/52.jpg" /></center>
<ul>
  <li>二分查找的问题前提是序列必须是递增或者递减的，即有序的</li>
  <li>为了防止数据溢出，写中点的时候要这么写: int mid = L + (R - L) / 2</li>
  <li>整型在转型的时候是向下取整</li>
</ul>

<h2 id="43-二分法求方程的根">4.3. 二分法求方程的根</h2>
<ul>
  <li>二分法求方程的根需要方程满足一定的条件，不是所有的方程都可以用二分法求根</li>
  <li>问题描述及求解思路:</li>
</ul>
<center><img src="../assets/img/posts/20220413/53.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/54.jpg" /></center>
<ul>
  <li>如果一个序列不是有序的，可以用排序算法对序列先进行排序然后二分查找</li>
</ul>

<h1 id="5-第五周-分治">5. 第五周 分治</h1>
<h2 id="51-归并排序">5.1. 归并排序</h2>
<ul>
  <li>分治的基本概念:</li>
</ul>
<center><img src="../assets/img/posts/20220413/55.jpg" /></center>
<ul>
  <li>分治的典型应用: 归并排序</li>
</ul>
<center><img src="../assets/img/posts/20220413/56.jpg" /></center>
<ul>
  <li>归并排序的思路就是先分治，然后归并，代码实现如下：</li>
</ul>
<center><img src="../assets/img/posts/20220413/57.jpg" /></center>
<center><img src="../assets/img/posts/20220413/58.jpg" /></center>
<center><img src="../assets/img/posts/20220413/59.jpg" /></center>
<ul>
  <li>归并排序的时间复杂度:</li>
</ul>
<center><img src="../assets/img/posts/20220413/60.jpg" /></center>

<h2 id="52-快速排序">5.2. 快速排序</h2>
<ul>
  <li>快速排序的思想:</li>
</ul>
<center><img src="../assets/img/posts/20220413/61.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/62.jpg" /></center>
<center><img src="../assets/img/posts/20220413/63.jpg" /></center>
<center><img src="../assets/img/posts/20220413/64.jpg" /></center>
<ul>
  <li>快速排序的时间复杂度是O(nlog(n))，这是在运气不坏的情况下得出的结果(平均复杂度)，运气最坏的情况下时间复杂度为O($n^2$)(最坏复杂度)</li>
</ul>

<h2 id="53-例题-输出前m大的数">5.3. 例题: 输出前m大的数</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/65.jpg" /></center>
<ul>
  <li>解决思路:</li>
</ul>
<center><img src="../assets/img/posts/20220413/66.jpg" /></center>
<p>用分治的思想解决问题，先把前m个元素移到数组的最右边，然后在对这m个元素进行快排</p>
<ul>
  <li>具体解决方法:</li>
</ul>
<center><img src="../assets/img/posts/20220413/67.jpg" /></center>
<center><img src="../assets/img/posts/20220413/68.jpg" /></center>
<ul>
  <li>时间复杂度计算:</li>
</ul>
<center><img src="../assets/img/posts/20220413/69.jpg" /></center>

<h2 id="54-例题-求排序的逆序数">5.4. 例题: 求排序的逆序数</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/70.jpg" /></center>
<ul>
  <li>解决思路:</li>
</ul>
<center><img src="../assets/img/posts/20220413/71.jpg" /></center>
<center><img src="../assets/img/posts/20220413/72.jpg" /></center>
<p>分治一般都使用了递归</p>

<h1 id="6-第六周-动态规划一">6. 第六周 动态规划(一)</h1>
<h2 id="61-数字三角形">6.1. 数字三角形</h2>
<ul>
  <li>问题描述:</li>
</ul>
<center><img src="../assets/img/posts/20220413/73.jpg" /></center>
<ul>
  <li>输入格式:</li>
</ul>
<center><img src="../assets/img/posts/20220413/74.jpg" /></center>
<ul>
  <li>解题思路: 
看成递归问题</li>
</ul>
<center><img src="../assets/img/posts/20220413/75.jpg" /></center>
<ul>
  <li>递归程序代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/76.jpg" /></center>
<ul>
  <li>虽然说在代码逻辑这一方面，递归算法没有问题，但是这个算法的时间复杂度太高，程序很容易超时:</li>
</ul>
<center><img src="../assets/img/posts/20220413/77.jpg" /></center>
<ul>
  <li>之前的递归算法中存在过多的重复计算，如果能把每一步的计算结果保存起来，那么即可避免重复计算，算法的时间复杂度为O($n^2$)</li>
</ul>
<center><img src="../assets/img/posts/20220413/78.jpg" /></center>
<ul>
  <li>记忆递归型动规程序:</li>
</ul>
<center><img src="../assets/img/posts/20220413/79.jpg" /></center>
<p>用一个二维数组存储每一个结点的max值，那么读取到这个结点时，就可以直接获得数值，避免了重复计算</p>
<ul>
  <li>也可以用递推的思想解决问题，先把最后一行的结果计算出来，然后从下到上逐步计算，用一个双重循环解决</li>
</ul>
<center><img src="../assets/img/posts/20220413/80.jpg" /></center>
<ul>
  <li>代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/81.jpg" /></center>
<ul>
  <li>还可以对空间进行优化，因为下一层的数值在计算上一层的数值后就没有用了，那么完全不需要用一个二维数组存储maxsum，完全可以用一个一维数组存放。再进一步来说，连maxSum数组都可以不要，直接用D的第n行替代maxSum</li>
</ul>
<center><img src="../assets/img/posts/20220413/82.jpg" /></center>
<ul>
  <li>空间优化后的代码实现:</li>
</ul>
<center><img src="../assets/img/posts/20220413/83.jpg" /></center>

<h2 id="62-动态规划解题的一般思路">6.2. 动态规划解题的一般思路</h2>
<ul>
  <li>递归到动规的一般转化方法:</li>
</ul>
<center><img src="../assets/img/posts/20220413/84.jpg" /></center>
<ul>
  <li>动规解题的一般思路:
    <ul>
      <li>第一步: 将原问题分解为子问题</li>
    </ul>
    <center><img src="../assets/img/posts/20220413/85.jpg" /></center>
    <ul>
      <li>第二步: 确定状态</li>
    </ul>
    <center><img src="../assets/img/posts/20220413/86.jpg" /></center>
    <ul>
      <li>第三步: 确定一些初始状态的值</li>
    </ul>
    <center><img src="../assets/img/posts/20220413/87.jpg" /></center>
    <ul>
      <li>第四步:</li>
    </ul>
  </li>
</ul>
:ET